;;; All the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include "compiler.s"

section .bss
;;; This pointer is used to manage allocations on our heap.
malloc_pointer:
    resq 1

;;; here we REServe enough Quad-words (64-bit "cells") for the free variables
;;; each free variable has 8 bytes reserved for a 64-bit pointer to its value
fvar_tbl:
    resq 40

section .data
const_tbl:
db T_VOID	; offset 0, #<void>
db T_NIL	; offset 1, ()
db T_BOOL, 0	; offset 2, #f
db T_BOOL, 1	; offset 4, #t
MAKE_LITERAL_STRING "whatever"	; offset 6, "whatever"
MAKE_LITERAL_SYMBOL(const_tbl+6)	; offset 23, whatever
MAKE_LITERAL_CHAR(0)	; offset 32, char 0
MAKE_LITERAL_RATIONAL(0, 1)	; offset 34, 0/1
MAKE_LITERAL_RATIONAL(1, 1)	; offset 51, 1/1
MAKE_LITERAL_RATIONAL(-1, 1)	; offset 68, -1/1
MAKE_LITERAL_RATIONAL(2, 1)	; offset 85, 2/1

;;; These macro definitions are required for the primitive
;;; definitions in the epilogue to work properly
%define SOB_VOID_ADDRESS const_tbl+0
%define SOB_NIL_ADDRESS const_tbl+1
%define SOB_FALSE_ADDRESS const_tbl+2
%define SOB_TRUE_ADDRESS const_tbl+4

global main
section .text
main:
    ;; set up the heap
    mov rdi, GB(2)
    call malloc
    mov [malloc_pointer], rax

    ;; Set up the dummy activation frame
    ;; The dummy return address is T_UNDEFINED
    ;; (which a is a macro for 0) so that returning
    ;; from the top level (which SHOULD NOT HAPPEN
    ;; AND IS A BUG) will cause a segfault.
    push 0                ; argument count
    push SOB_NIL_ADDRESS  ; lexical environment address
    push T_UNDEFINED      ; return address
    push rbp                    
    mov rbp, rsp                ; anchor the dummy frame

    ;; Set up the primitive stdlib fvars:
    ;; Since the primtive procedures are defined in assembly,
    ;; they are not generated by scheme (define ...) expressions.
    ;; This is where we simulate the missing (define ...) expressions
    ;; for all the primitive procedures.
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, flonum?)
mov [fvar_tbl+8*23], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, rational?)
mov [fvar_tbl+8*24], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, pair?)
mov [fvar_tbl+8*12], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, null?)
mov [fvar_tbl+8*1], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char?)
mov [fvar_tbl+8*36], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string?)
mov [fvar_tbl+8*37], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_length)
mov [fvar_tbl+8*34], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_ref)
mov [fvar_tbl+8*33], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, make_string)
mov [fvar_tbl+8*13], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char_to_integer)
mov [fvar_tbl+8*39], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, exact_to_inexact)
mov [fvar_tbl+8*25], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, eq?)
mov [fvar_tbl+8*38], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, add)
mov [fvar_tbl+8*15], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, mul)
mov [fvar_tbl+8*16], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, div)
mov [fvar_tbl+8*17], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, eq)
mov [fvar_tbl+8*21], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, lt)
mov [fvar_tbl+8*22], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, numerator)
mov [fvar_tbl+8*18], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, denominator)
mov [fvar_tbl+8*19], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, gcd)
mov [fvar_tbl+8*20], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, car)
mov [fvar_tbl+8*2], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cdr)
mov [fvar_tbl+8*3], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cons)
mov [fvar_tbl+8*4], rax

user_code_fragment:
;;; The code you compiled will be added here.
;;; It will be executed immediately after the closures for 
;;; the primitive procedures are set up.
;; Starting: Set fvar map to ((lambda (null? car cdr cons apply) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(car, 1) Box(VarParam(car, 1)))  (set! VarParam(cdr, 2) Box(VarParam(cdr, 2)))  (set! VarParam(cons, 3) Box(VarParam(cons, 3)))  (set! VarParam(apply, 4) Box(VarParam(apply, 4)))  ((lambda (map-many map-one) (begin (set! VarParam(map-many, 0) Box(VarParam(map-many, 0)))  (set! VarParam(map-one, 1) Box(VarParam(map-one, 1)))  BoxSet(VarParam(map-many, 0), (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))))))  BoxSet(VarParam(map-one, 1), (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))))))  (lambda (f . args) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(args, 1) Box(VarParam(args, 1)))  (BoxGet(VarBound(map-many, 0, 0)) BoxGet(VarParam(f, 0))  BoxGet(VarParam(args, 1))))))) whatever  whatever))) VarFree(null?)  VarFree(car)  VarFree(cdr)  VarFree(cons)  VarFree(apply))
;; Starting: Perform Applic#1 of: ((lambda (null? car cdr cons apply) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(car, 1) Box(VarParam(car, 1)))  (set! VarParam(cdr, 2) Box(VarParam(cdr, 2)))  (set! VarParam(cons, 3) Box(VarParam(cons, 3)))  (set! VarParam(apply, 4) Box(VarParam(apply, 4)))  ((lambda (map-many map-one) (begin (set! VarParam(map-many, 0) Box(VarParam(map-many, 0)))  (set! VarParam(map-one, 1) Box(VarParam(map-one, 1)))  BoxSet(VarParam(map-many, 0), (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))))))  BoxSet(VarParam(map-one, 1), (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))))))  (lambda (f . args) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(args, 1) Box(VarParam(args, 1)))  (BoxGet(VarBound(map-many, 0, 0)) BoxGet(VarParam(f, 0))  BoxGet(VarParam(args, 1))))))) whatever  whatever))) VarFree(null?)  VarFree(car)  VarFree(cdr)  VarFree(cons)  VarFree(apply))
;; Starting: Argument 4 of Applic statement #1
mov rax, qword [fvar_tbl+8*5]	; mov fvar apply to rax
;; Finished: Argument 4 of Applic statement #1

push rax ; Push argument to stack;; Starting: Argument 3 of Applic statement #1
mov rax, qword [fvar_tbl+8*4]	; mov fvar cons to rax
;; Finished: Argument 3 of Applic statement #1

push rax ; Push argument to stack;; Starting: Argument 2 of Applic statement #1
mov rax, qword [fvar_tbl+8*3]	; mov fvar cdr to rax
;; Finished: Argument 2 of Applic statement #1

push rax ; Push argument to stack;; Starting: Argument 1 of Applic statement #1
mov rax, qword [fvar_tbl+8*2]	; mov fvar car to rax
;; Finished: Argument 1 of Applic statement #1

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #1
mov rax, qword [fvar_tbl+8*1]	; mov fvar null? to rax
;; Finished: Argument 0 of Applic statement #1

push rax ; Push argument to stack
push qword 5 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #1)
;; Starting: Creating CLOSURE of LambdaSimple#2 -> (lambda (null? car cdr cons apply) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(car, 1) Box(VarParam(car, 1)))  (set! VarParam(cdr, 2) Box(VarParam(cdr, 2)))  (set! VarParam(cons, 3) Box(VarParam(cons, 3)))  (set! VarParam(apply, 4) Box(VarParam(apply, 4)))  ((lambda (map-many map-one) (begin (set! VarParam(map-many, 0) Box(VarParam(map-many, 0)))  (set! VarParam(map-one, 1) Box(VarParam(map-one, 1)))  BoxSet(VarParam(map-many, 0), (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))))))  BoxSet(VarParam(map-one, 1), (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))))))  (lambda (f . args) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(args, 1) Box(VarParam(args, 1)))  (BoxGet(VarBound(map-many, 0, 0)) BoxGet(VarParam(f, 0))  BoxGet(VarParam(args, 1))))))) whatever  whatever)))
push rbx
; Env Extend Code Section For Closure#2
mov rbx, 0 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend2
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End2

LClosureEnvExtend2:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, -1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 0
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop2:
  jz LClosureEnvExtend_LoopEnd2
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop2

LClosureEnvExtend_LoopEnd2:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd2
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop2:
  jz LClosureEnvExtend_ParamsLoopEnd2

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop2

LClosureEnvExtend_ParamsLoopEnd2:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End2:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode2)
pop rbx
jmp LClosureCont2
LClosureCode2:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #3: (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(car, 1) Box(VarParam(car, 1)))  (set! VarParam(cdr, 2) Box(VarParam(cdr, 2)))  (set! VarParam(cons, 3) Box(VarParam(cons, 3)))  (set! VarParam(apply, 4) Box(VarParam(apply, 4)))  ((lambda (map-many map-one) (begin (set! VarParam(map-many, 0) Box(VarParam(map-many, 0)))  (set! VarParam(map-one, 1) Box(VarParam(map-one, 1)))  BoxSet(VarParam(map-many, 0), (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))))))  BoxSet(VarParam(map-one, 1), (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))))))  (lambda (f . args) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(args, 1) Box(VarParam(args, 1)))  (BoxGet(VarBound(map-many, 0, 0)) BoxGet(VarParam(f, 0))  BoxGet(VarParam(args, 1))))))) whatever  whatever))
;; Starting: Item 0 in Seq statement #3
;; Starting: Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(null?, 0)
;; Starting: Get VarParam(name=null?, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=null?, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(null?, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0))

;; Finished: Item 0 in Seq statement #3


;; Starting: Item 1 in Seq statement #3
;; Starting: Set VarParam(name=car, minor=1) with Box(VarParam(car, 1))
;; Starting: Evaluating rhs for [ Set VarParam(name=car, minor=1) with Box(VarParam(car, 1)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(car, 1)
;; Starting: Get VarParam(name=car, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=car, minor=1)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(car, 1)

;; Finished: Evaluating rhs for [ Set VarParam(name=car, minor=1) with Box(VarParam(car, 1)) ], value is expected in rax

mov PVAR(1), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=car, minor=1) with Box(VarParam(car, 1))

;; Finished: Item 1 in Seq statement #3


;; Starting: Item 2 in Seq statement #3
;; Starting: Set VarParam(name=cdr, minor=2) with Box(VarParam(cdr, 2))
;; Starting: Evaluating rhs for [ Set VarParam(name=cdr, minor=2) with Box(VarParam(cdr, 2)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(cdr, 2)
;; Starting: Get VarParam(name=cdr, minor=2)
mov rax, PVAR(2)
;; Finished: Get VarParam(name=cdr, minor=2)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(cdr, 2)

;; Finished: Evaluating rhs for [ Set VarParam(name=cdr, minor=2) with Box(VarParam(cdr, 2)) ], value is expected in rax

mov PVAR(2), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=cdr, minor=2) with Box(VarParam(cdr, 2))

;; Finished: Item 2 in Seq statement #3


;; Starting: Item 3 in Seq statement #3
;; Starting: Set VarParam(name=cons, minor=3) with Box(VarParam(cons, 3))
;; Starting: Evaluating rhs for [ Set VarParam(name=cons, minor=3) with Box(VarParam(cons, 3)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(cons, 3)
;; Starting: Get VarParam(name=cons, minor=3)
mov rax, PVAR(3)
;; Finished: Get VarParam(name=cons, minor=3)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(cons, 3)

;; Finished: Evaluating rhs for [ Set VarParam(name=cons, minor=3) with Box(VarParam(cons, 3)) ], value is expected in rax

mov PVAR(3), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=cons, minor=3) with Box(VarParam(cons, 3))

;; Finished: Item 3 in Seq statement #3


;; Starting: Item 4 in Seq statement #3
;; Starting: Set VarParam(name=apply, minor=4) with Box(VarParam(apply, 4))
;; Starting: Evaluating rhs for [ Set VarParam(name=apply, minor=4) with Box(VarParam(apply, 4)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(apply, 4)
;; Starting: Get VarParam(name=apply, minor=4)
mov rax, PVAR(4)
;; Finished: Get VarParam(name=apply, minor=4)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(apply, 4)

;; Finished: Evaluating rhs for [ Set VarParam(name=apply, minor=4) with Box(VarParam(apply, 4)) ], value is expected in rax

mov PVAR(4), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=apply, minor=4) with Box(VarParam(apply, 4))

;; Finished: Item 4 in Seq statement #3


;; Starting: Item 5 in Seq statement #3
;; Starting: Perform Applic#4 of: ((lambda (map-many map-one) (begin (set! VarParam(map-many, 0) Box(VarParam(map-many, 0)))  (set! VarParam(map-one, 1) Box(VarParam(map-one, 1)))  BoxSet(VarParam(map-many, 0), (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))))))  BoxSet(VarParam(map-one, 1), (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))))))  (lambda (f . args) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(args, 1) Box(VarParam(args, 1)))  (BoxGet(VarBound(map-many, 0, 0)) BoxGet(VarParam(f, 0))  BoxGet(VarParam(args, 1))))))) whatever  whatever)
;; Starting: Argument 1 of Applic statement #4
mov rax, const_tbl+23	; mov const whatever to rax
;; Finished: Argument 1 of Applic statement #4

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #4
mov rax, const_tbl+23	; mov const whatever to rax
;; Finished: Argument 0 of Applic statement #4

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #4)
;; Starting: Creating CLOSURE of LambdaSimple#5 -> (lambda (map-many map-one) (begin (set! VarParam(map-many, 0) Box(VarParam(map-many, 0)))  (set! VarParam(map-one, 1) Box(VarParam(map-one, 1)))  BoxSet(VarParam(map-many, 0), (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))))))  BoxSet(VarParam(map-one, 1), (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))))))  (lambda (f . args) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(args, 1) Box(VarParam(args, 1)))  (BoxGet(VarBound(map-many, 0, 0)) BoxGet(VarParam(f, 0))  BoxGet(VarParam(args, 1)))))))
push rbx
; Env Extend Code Section For Closure#5
mov rbx, 1 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend5
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End5

LClosureEnvExtend5:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 0
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 8
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop5:
  jz LClosureEnvExtend_LoopEnd5
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop5

LClosureEnvExtend_LoopEnd5:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd5
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop5:
  jz LClosureEnvExtend_ParamsLoopEnd5

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop5

LClosureEnvExtend_ParamsLoopEnd5:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End5:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode5)
pop rbx
jmp LClosureCont5
LClosureCode5:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #6: (begin (set! VarParam(map-many, 0) Box(VarParam(map-many, 0)))  (set! VarParam(map-one, 1) Box(VarParam(map-one, 1)))  BoxSet(VarParam(map-many, 0), (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))))))  BoxSet(VarParam(map-one, 1), (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))))))  (lambda (f . args) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(args, 1) Box(VarParam(args, 1)))  (BoxGet(VarBound(map-many, 0, 0)) BoxGet(VarParam(f, 0))  BoxGet(VarParam(args, 1))))))
;; Starting: Item 0 in Seq statement #6
;; Starting: Set VarParam(name=map-many, minor=0) with Box(VarParam(map-many, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=map-many, minor=0) with Box(VarParam(map-many, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(map-many, 0)
;; Starting: Get VarParam(name=map-many, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=map-many, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(map-many, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=map-many, minor=0) with Box(VarParam(map-many, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=map-many, minor=0) with Box(VarParam(map-many, 0))

;; Finished: Item 0 in Seq statement #6


;; Starting: Item 1 in Seq statement #6
;; Starting: Set VarParam(name=map-one, minor=1) with Box(VarParam(map-one, 1))
;; Starting: Evaluating rhs for [ Set VarParam(name=map-one, minor=1) with Box(VarParam(map-one, 1)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(map-one, 1)
;; Starting: Get VarParam(name=map-one, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=map-one, minor=1)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(map-one, 1)

;; Finished: Evaluating rhs for [ Set VarParam(name=map-one, minor=1) with Box(VarParam(map-one, 1)) ], value is expected in rax

mov PVAR(1), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=map-one, minor=1) with Box(VarParam(map-one, 1))

;; Finished: Item 1 in Seq statement #6


;; Starting: Item 2 in Seq statement #6
;; Starting: BoxSet of VarParam(map-many, 0) with (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1))))))
;; Starting: Evaluating rhs for [ BoxSet of VarParam(map-many, 0) with (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))))) ], the VALUE is expected in rax
;; Starting: Creating CLOSURE of LambdaSimple#7 -> (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1))))))
push rbx
; Env Extend Code Section For Closure#7
mov rbx, 2 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend7
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End7

LClosureEnvExtend7:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 16
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop7:
  jz LClosureEnvExtend_LoopEnd7
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop7

LClosureEnvExtend_LoopEnd7:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd7
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop7:
  jz LClosureEnvExtend_ParamsLoopEnd7

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop7

LClosureEnvExtend_ParamsLoopEnd7:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End7:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode7)
pop rbx
jmp LClosureCont7
LClosureCode7:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: If statement (#8): (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))))
Lif8:
;; Starting: Perform Applic#9 of: (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1)))
;; Starting: Argument 0 of Applic statement #9
;; Starting: Perform Applic#10 of: (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))
;; Starting: Argument 0 of Applic statement #10
;; Starting: Get VarParam(name=lists, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=lists, minor=1)

;; Finished: Argument 0 of Applic statement #10

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #10)
;; Starting: BoxGet of VarBound(car, 1, 1)
;; Starting: Evaluating val for [ BoxGet of VarBound(car, 1, 1) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=car, major=1, minor=1)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
;; Finished: Get VarBound(name=car, major=1, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarBound(car, 1, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(car, 1, 1)

;; Finished: Evaluating proc to apply (in Applic #10)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic10
int 3
ContinueApplic10:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #10
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#10 of: (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))

;; Finished: Argument 0 of Applic statement #9

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #9)
;; Starting: BoxGet of VarBound(null?, 1, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(null?, 1, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=null?, major=1, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=null?, major=1, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(null?, 1, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(null?, 1, 0)

;; Finished: Evaluating proc to apply (in Applic #9)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic9
int 3
ContinueApplic9:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #9
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#9 of: (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1)))

cmp rax, SOB_FALSE_ADDRESS
je Lelse8
mov rax, const_tbl+1	; mov const () to rax
jmp LendIf8
Lelse8:
;; Starting: Perform Applic#11 of: (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1))))
;; Starting: Argument 1 of Applic statement #11
;; Starting: Perform Applic#14 of: (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))
;; Starting: Argument 1 of Applic statement #14
;; Starting: Perform Applic#15 of: (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1))
;; Starting: Argument 1 of Applic statement #15
;; Starting: Get VarParam(name=lists, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=lists, minor=1)

;; Finished: Argument 1 of Applic statement #15

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #15
;; Starting: BoxGet of VarBound(cdr, 1, 2)
;; Starting: Evaluating val for [ BoxGet of VarBound(cdr, 1, 2) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=cdr, major=1, minor=2)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]
;; Finished: Get VarBound(name=cdr, major=1, minor=2)

;; Finished: Evaluating val for [ BoxGet of VarBound(cdr, 1, 2) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(cdr, 1, 2)

;; Finished: Argument 0 of Applic statement #15

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #15)
;; Starting: BoxGet of VarBound(map-one, 0, 1)
;; Starting: Evaluating val for [ BoxGet of VarBound(map-one, 0, 1) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=map-one, major=0, minor=1)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]
;; Finished: Get VarBound(name=map-one, major=0, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarBound(map-one, 0, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(map-one, 0, 1)

;; Finished: Evaluating proc to apply (in Applic #15)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic15
int 3
ContinueApplic15:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #15
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#15 of: (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1))

;; Finished: Argument 1 of Applic statement #14

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #14
;; Starting: Get VarParam(name=f, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=f, minor=0)

;; Finished: Argument 0 of Applic statement #14

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #14)
;; Starting: BoxGet of VarBound(map-many, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(map-many, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=map-many, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=map-many, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(map-many, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(map-many, 0, 0)

;; Finished: Evaluating proc to apply (in Applic #14)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic14
int 3
ContinueApplic14:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #14
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#14 of: (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))

;; Finished: Argument 1 of Applic statement #11

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #11
;; Starting: Perform Applic#12 of: (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))
;; Starting: Argument 1 of Applic statement #12
;; Starting: Perform Applic#13 of: (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1))
;; Starting: Argument 1 of Applic statement #13
;; Starting: Get VarParam(name=lists, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=lists, minor=1)

;; Finished: Argument 1 of Applic statement #13

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #13
;; Starting: BoxGet of VarBound(car, 1, 1)
;; Starting: Evaluating val for [ BoxGet of VarBound(car, 1, 1) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=car, major=1, minor=1)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
;; Finished: Get VarBound(name=car, major=1, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarBound(car, 1, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(car, 1, 1)

;; Finished: Argument 0 of Applic statement #13

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #13)
;; Starting: BoxGet of VarBound(map-one, 0, 1)
;; Starting: Evaluating val for [ BoxGet of VarBound(map-one, 0, 1) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=map-one, major=0, minor=1)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]
;; Finished: Get VarBound(name=map-one, major=0, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarBound(map-one, 0, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(map-one, 0, 1)

;; Finished: Evaluating proc to apply (in Applic #13)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic13
int 3
ContinueApplic13:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #13
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#13 of: (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1))

;; Finished: Argument 1 of Applic statement #12

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #12
;; Starting: Get VarParam(name=f, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=f, minor=0)

;; Finished: Argument 0 of Applic statement #12

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #12)
;; Starting: BoxGet of VarBound(apply, 1, 4)
;; Starting: Evaluating val for [ BoxGet of VarBound(apply, 1, 4) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=apply, major=1, minor=4)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 4]
;; Finished: Get VarBound(name=apply, major=1, minor=4)

;; Finished: Evaluating val for [ BoxGet of VarBound(apply, 1, 4) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(apply, 1, 4)

;; Finished: Evaluating proc to apply (in Applic #12)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic12
int 3
ContinueApplic12:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #12
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#12 of: (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))

;; Finished: Argument 0 of Applic statement #11

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #11)
;; Starting: BoxGet of VarBound(cons, 1, 3)
;; Starting: Evaluating val for [ BoxGet of VarBound(cons, 1, 3) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=cons, major=1, minor=3)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]
;; Finished: Get VarBound(name=cons, major=1, minor=3)

;; Finished: Evaluating val for [ BoxGet of VarBound(cons, 1, 3) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(cons, 1, 3)

;; Finished: Evaluating proc to apply (in Applic #11)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic11
int 3
ContinueApplic11:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #11
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#11 of: (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1))))

LendIf8:
;; Finished: If statement (#8): (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont7:

;; Finished: Creating CLOSURE of LambdaSimple#7 -> (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1))))))

;; Finished: Evaluating rhs for [ BoxSet of VarParam(map-many, 0) with (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))))) ], the VALUE is expected in rax

; Save the value of rhs
push rax
;; Starting: Evaluating var for [ BoxSet of VarParam(map-many, 0) with (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))))) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=map-many, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=map-many, minor=0)

;; Finished: Evaluating var for [ BoxSet of VarParam(map-many, 0) with (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))))) ], the VALUE is expected in rax

; in RAX there is a address of a box, put the value we saved on stack earlier (from rhs) inside it
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;; Finished: BoxSet of VarParam(map-many, 0) with (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1))))))

;; Finished: Item 2 in Seq statement #6


;; Starting: Item 3 in Seq statement #6
;; Starting: BoxSet of VarParam(map-one, 1) with (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1))))))
;; Starting: Evaluating rhs for [ BoxSet of VarParam(map-one, 1) with (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))))) ], the VALUE is expected in rax
;; Starting: Creating CLOSURE of LambdaSimple#16 -> (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1))))))
push rbx
; Env Extend Code Section For Closure#16
mov rbx, 3 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend16
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End16

LClosureEnvExtend16:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 2
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 24
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop16:
  jz LClosureEnvExtend_LoopEnd16
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop16

LClosureEnvExtend_LoopEnd16:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd16
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop16:
  jz LClosureEnvExtend_ParamsLoopEnd16

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop16

LClosureEnvExtend_ParamsLoopEnd16:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End16:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode16)
pop rbx
jmp LClosureCont16
LClosureCode16:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: If statement (#17): (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))))
Lif17:
;; Starting: Perform Applic#18 of: (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1))
;; Starting: Argument 0 of Applic statement #18
;; Starting: Get VarParam(name=s, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=s, minor=1)

;; Finished: Argument 0 of Applic statement #18

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #18)
;; Starting: BoxGet of VarBound(null?, 1, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(null?, 1, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=null?, major=1, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=null?, major=1, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(null?, 1, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(null?, 1, 0)

;; Finished: Evaluating proc to apply (in Applic #18)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic18
int 3
ContinueApplic18:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #18
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#18 of: (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1))

cmp rax, SOB_FALSE_ADDRESS
je Lelse17
mov rax, const_tbl+1	; mov const () to rax
jmp LendIf17
Lelse17:
;; Starting: Perform Applic#19 of: (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1))))
;; Starting: Argument 1 of Applic statement #19
;; Starting: Perform Applic#22 of: (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))
;; Starting: Argument 1 of Applic statement #22
;; Starting: Perform Applic#23 of: (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1))
;; Starting: Argument 0 of Applic statement #23
;; Starting: Get VarParam(name=s, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=s, minor=1)

;; Finished: Argument 0 of Applic statement #23

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #23)
;; Starting: BoxGet of VarBound(cdr, 1, 2)
;; Starting: Evaluating val for [ BoxGet of VarBound(cdr, 1, 2) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=cdr, major=1, minor=2)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]
;; Finished: Get VarBound(name=cdr, major=1, minor=2)

;; Finished: Evaluating val for [ BoxGet of VarBound(cdr, 1, 2) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(cdr, 1, 2)

;; Finished: Evaluating proc to apply (in Applic #23)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic23
int 3
ContinueApplic23:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #23
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#23 of: (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1))

;; Finished: Argument 1 of Applic statement #22

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #22
;; Starting: Get VarParam(name=f, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=f, minor=0)

;; Finished: Argument 0 of Applic statement #22

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #22)
;; Starting: BoxGet of VarBound(map-one, 0, 1)
;; Starting: Evaluating val for [ BoxGet of VarBound(map-one, 0, 1) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=map-one, major=0, minor=1)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]
;; Finished: Get VarBound(name=map-one, major=0, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarBound(map-one, 0, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(map-one, 0, 1)

;; Finished: Evaluating proc to apply (in Applic #22)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic22
int 3
ContinueApplic22:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #22
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#22 of: (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))

;; Finished: Argument 1 of Applic statement #19

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #19
;; Starting: Perform Applic#20 of: (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))
;; Starting: Argument 0 of Applic statement #20
;; Starting: Perform Applic#21 of: (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1))
;; Starting: Argument 0 of Applic statement #21
;; Starting: Get VarParam(name=s, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=s, minor=1)

;; Finished: Argument 0 of Applic statement #21

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #21)
;; Starting: BoxGet of VarBound(car, 1, 1)
;; Starting: Evaluating val for [ BoxGet of VarBound(car, 1, 1) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=car, major=1, minor=1)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
;; Finished: Get VarBound(name=car, major=1, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarBound(car, 1, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(car, 1, 1)

;; Finished: Evaluating proc to apply (in Applic #21)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic21
int 3
ContinueApplic21:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #21
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#21 of: (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1))

;; Finished: Argument 0 of Applic statement #20

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #20)
;; Starting: Get VarParam(name=f, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=f, minor=0)

;; Finished: Evaluating proc to apply (in Applic #20)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic20
int 3
ContinueApplic20:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #20
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#20 of: (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))

;; Finished: Argument 0 of Applic statement #19

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #19)
;; Starting: BoxGet of VarBound(cons, 1, 3)
;; Starting: Evaluating val for [ BoxGet of VarBound(cons, 1, 3) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=cons, major=1, minor=3)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]
;; Finished: Get VarBound(name=cons, major=1, minor=3)

;; Finished: Evaluating val for [ BoxGet of VarBound(cons, 1, 3) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(cons, 1, 3)

;; Finished: Evaluating proc to apply (in Applic #19)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic19
int 3
ContinueApplic19:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #19
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#19 of: (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1))))

LendIf17:
;; Finished: If statement (#17): (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont16:

;; Finished: Creating CLOSURE of LambdaSimple#16 -> (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1))))))

;; Finished: Evaluating rhs for [ BoxSet of VarParam(map-one, 1) with (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))))) ], the VALUE is expected in rax

; Save the value of rhs
push rax
;; Starting: Evaluating var for [ BoxSet of VarParam(map-one, 1) with (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))))) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=map-one, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=map-one, minor=1)

;; Finished: Evaluating var for [ BoxSet of VarParam(map-one, 1) with (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))))) ], the VALUE is expected in rax

; in RAX there is a address of a box, put the value we saved on stack earlier (from rhs) inside it
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;; Finished: BoxSet of VarParam(map-one, 1) with (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1))))))

;; Finished: Item 3 in Seq statement #6


;; Starting: Item 4 in Seq statement #6

;; Finished: Item 4 in Seq statement #6

;; Finished: Seq statement #6: (begin (set! VarParam(map-many, 0) Box(VarParam(map-many, 0)))  (set! VarParam(map-one, 1) Box(VarParam(map-one, 1)))  BoxSet(VarParam(map-many, 0), (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))))))  BoxSet(VarParam(map-one, 1), (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))))))  (lambda (f . args) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(args, 1) Box(VarParam(args, 1)))  (BoxGet(VarBound(map-many, 0, 0)) BoxGet(VarParam(f, 0))  BoxGet(VarParam(args, 1))))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont5:

;; Finished: Creating CLOSURE of LambdaSimple#5 -> (lambda (map-many map-one) (begin (set! VarParam(map-many, 0) Box(VarParam(map-many, 0)))  (set! VarParam(map-one, 1) Box(VarParam(map-one, 1)))  BoxSet(VarParam(map-many, 0), (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))))))  BoxSet(VarParam(map-one, 1), (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))))))  (lambda (f . args) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(args, 1) Box(VarParam(args, 1)))  (BoxGet(VarBound(map-many, 0, 0)) BoxGet(VarParam(f, 0))  BoxGet(VarParam(args, 1)))))))

;; Finished: Evaluating proc to apply (in Applic #4)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic4
int 3
ContinueApplic4:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #4
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#4 of: ((lambda (map-many map-one) (begin (set! VarParam(map-many, 0) Box(VarParam(map-many, 0)))  (set! VarParam(map-one, 1) Box(VarParam(map-one, 1)))  BoxSet(VarParam(map-many, 0), (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))))))  BoxSet(VarParam(map-one, 1), (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))))))  (lambda (f . args) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(args, 1) Box(VarParam(args, 1)))  (BoxGet(VarBound(map-many, 0, 0)) BoxGet(VarParam(f, 0))  BoxGet(VarParam(args, 1))))))) whatever  whatever)

;; Finished: Item 5 in Seq statement #3

;; Finished: Seq statement #3: (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(car, 1) Box(VarParam(car, 1)))  (set! VarParam(cdr, 2) Box(VarParam(cdr, 2)))  (set! VarParam(cons, 3) Box(VarParam(cons, 3)))  (set! VarParam(apply, 4) Box(VarParam(apply, 4)))  ((lambda (map-many map-one) (begin (set! VarParam(map-many, 0) Box(VarParam(map-many, 0)))  (set! VarParam(map-one, 1) Box(VarParam(map-one, 1)))  BoxSet(VarParam(map-many, 0), (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))))))  BoxSet(VarParam(map-one, 1), (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))))))  (lambda (f . args) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(args, 1) Box(VarParam(args, 1)))  (BoxGet(VarBound(map-many, 0, 0)) BoxGet(VarParam(f, 0))  BoxGet(VarParam(args, 1))))))) whatever  whatever))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont2:

;; Finished: Creating CLOSURE of LambdaSimple#2 -> (lambda (null? car cdr cons apply) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(car, 1) Box(VarParam(car, 1)))  (set! VarParam(cdr, 2) Box(VarParam(cdr, 2)))  (set! VarParam(cons, 3) Box(VarParam(cons, 3)))  (set! VarParam(apply, 4) Box(VarParam(apply, 4)))  ((lambda (map-many map-one) (begin (set! VarParam(map-many, 0) Box(VarParam(map-many, 0)))  (set! VarParam(map-one, 1) Box(VarParam(map-one, 1)))  BoxSet(VarParam(map-many, 0), (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))))))  BoxSet(VarParam(map-one, 1), (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))))))  (lambda (f . args) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(args, 1) Box(VarParam(args, 1)))  (BoxGet(VarBound(map-many, 0, 0)) BoxGet(VarParam(f, 0))  BoxGet(VarParam(args, 1))))))) whatever  whatever)))

;; Finished: Evaluating proc to apply (in Applic #1)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic1
int 3
ContinueApplic1:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #1
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#1 of: ((lambda (null? car cdr cons apply) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(car, 1) Box(VarParam(car, 1)))  (set! VarParam(cdr, 2) Box(VarParam(cdr, 2)))  (set! VarParam(cons, 3) Box(VarParam(cons, 3)))  (set! VarParam(apply, 4) Box(VarParam(apply, 4)))  ((lambda (map-many map-one) (begin (set! VarParam(map-many, 0) Box(VarParam(map-many, 0)))  (set! VarParam(map-one, 1) Box(VarParam(map-one, 1)))  BoxSet(VarParam(map-many, 0), (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))))))  BoxSet(VarParam(map-one, 1), (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))))))  (lambda (f . args) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(args, 1) Box(VarParam(args, 1)))  (BoxGet(VarBound(map-many, 0, 0)) BoxGet(VarParam(f, 0))  BoxGet(VarParam(args, 1))))))) whatever  whatever))) VarFree(null?)  VarFree(car)  VarFree(cdr)  VarFree(cons)  VarFree(apply))

mov qword [fvar_tbl+8*0], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar map to ((lambda (null? car cdr cons apply) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(car, 1) Box(VarParam(car, 1)))  (set! VarParam(cdr, 2) Box(VarParam(cdr, 2)))  (set! VarParam(cons, 3) Box(VarParam(cons, 3)))  (set! VarParam(apply, 4) Box(VarParam(apply, 4)))  ((lambda (map-many map-one) (begin (set! VarParam(map-many, 0) Box(VarParam(map-many, 0)))  (set! VarParam(map-one, 1) Box(VarParam(map-one, 1)))  BoxSet(VarParam(map-many, 0), (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))))))  BoxSet(VarParam(map-one, 1), (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))))))  (lambda (f . args) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(args, 1) Box(VarParam(args, 1)))  (BoxGet(VarBound(map-many, 0, 0)) BoxGet(VarParam(f, 0))  BoxGet(VarParam(args, 1))))))) whatever  whatever))) VarFree(null?)  VarFree(car)  VarFree(cdr)  VarFree(cons)  VarFree(apply))

	call write_sob_if_not_void

;; Starting: Set fvar fold-left to ((lambda (null? apply cons map car cdr) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(apply, 1) Box(VarParam(apply, 1)))  (set! VarParam(cons, 2) Box(VarParam(cons, 2)))  (set! VarParam(map, 3) Box(VarParam(map, 3)))  (set! VarParam(car, 4) Box(VarParam(car, 4)))  (set! VarParam(cdr, 5) Box(VarParam(cdr, 5)))  (lambda (f obj . lists) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(obj, 1) Box(VarParam(obj, 1)))  (set! VarParam(lists, 2) Box(VarParam(lists, 2)))  ((lambda (fold) (begin (set! VarParam(fold, 0) Box(VarParam(fold, 0)))  BoxSet(VarParam(fold, 0), (lambda (obj lists) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(car, 2, 4)) VarParam(lists, 1))) VarParam(obj, 0) (BoxGet(VarBound(fold, 0, 0)) (BoxGet(VarBound(apply, 2, 1)) BoxGet(VarBound(f, 1, 0))  (BoxGet(VarBound(cons, 2, 2)) VarParam(obj, 0)  (BoxGet(VarBound(map, 2, 3)) BoxGet(VarBound(car, 2, 4))  VarParam(lists, 1))))  (BoxGet(VarBound(map, 2, 3)) BoxGet(VarBound(cdr, 2, 5))  VarParam(lists, 1))))))  (BoxGet(VarParam(fold, 0)) BoxGet(VarBound(obj, 0, 1))  BoxGet(VarBound(lists, 0, 2))))) whatever))))) VarFree(null?)  VarFree(apply)  VarFree(cons)  VarFree(map)  VarFree(car)  VarFree(cdr))
;; Starting: Perform Applic#24 of: ((lambda (null? apply cons map car cdr) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(apply, 1) Box(VarParam(apply, 1)))  (set! VarParam(cons, 2) Box(VarParam(cons, 2)))  (set! VarParam(map, 3) Box(VarParam(map, 3)))  (set! VarParam(car, 4) Box(VarParam(car, 4)))  (set! VarParam(cdr, 5) Box(VarParam(cdr, 5)))  (lambda (f obj . lists) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(obj, 1) Box(VarParam(obj, 1)))  (set! VarParam(lists, 2) Box(VarParam(lists, 2)))  ((lambda (fold) (begin (set! VarParam(fold, 0) Box(VarParam(fold, 0)))  BoxSet(VarParam(fold, 0), (lambda (obj lists) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(car, 2, 4)) VarParam(lists, 1))) VarParam(obj, 0) (BoxGet(VarBound(fold, 0, 0)) (BoxGet(VarBound(apply, 2, 1)) BoxGet(VarBound(f, 1, 0))  (BoxGet(VarBound(cons, 2, 2)) VarParam(obj, 0)  (BoxGet(VarBound(map, 2, 3)) BoxGet(VarBound(car, 2, 4))  VarParam(lists, 1))))  (BoxGet(VarBound(map, 2, 3)) BoxGet(VarBound(cdr, 2, 5))  VarParam(lists, 1))))))  (BoxGet(VarParam(fold, 0)) BoxGet(VarBound(obj, 0, 1))  BoxGet(VarBound(lists, 0, 2))))) whatever))))) VarFree(null?)  VarFree(apply)  VarFree(cons)  VarFree(map)  VarFree(car)  VarFree(cdr))
;; Starting: Argument 5 of Applic statement #24
mov rax, qword [fvar_tbl+8*3]	; mov fvar cdr to rax
;; Finished: Argument 5 of Applic statement #24

push rax ; Push argument to stack;; Starting: Argument 4 of Applic statement #24
mov rax, qword [fvar_tbl+8*2]	; mov fvar car to rax
;; Finished: Argument 4 of Applic statement #24

push rax ; Push argument to stack;; Starting: Argument 3 of Applic statement #24
mov rax, qword [fvar_tbl+8*0]	; mov fvar map to rax
;; Finished: Argument 3 of Applic statement #24

push rax ; Push argument to stack;; Starting: Argument 2 of Applic statement #24
mov rax, qword [fvar_tbl+8*4]	; mov fvar cons to rax
;; Finished: Argument 2 of Applic statement #24

push rax ; Push argument to stack;; Starting: Argument 1 of Applic statement #24
mov rax, qword [fvar_tbl+8*5]	; mov fvar apply to rax
;; Finished: Argument 1 of Applic statement #24

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #24
mov rax, qword [fvar_tbl+8*1]	; mov fvar null? to rax
;; Finished: Argument 0 of Applic statement #24

push rax ; Push argument to stack
push qword 6 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #24)
;; Starting: Creating CLOSURE of LambdaSimple#25 -> (lambda (null? apply cons map car cdr) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(apply, 1) Box(VarParam(apply, 1)))  (set! VarParam(cons, 2) Box(VarParam(cons, 2)))  (set! VarParam(map, 3) Box(VarParam(map, 3)))  (set! VarParam(car, 4) Box(VarParam(car, 4)))  (set! VarParam(cdr, 5) Box(VarParam(cdr, 5)))  (lambda (f obj . lists) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(obj, 1) Box(VarParam(obj, 1)))  (set! VarParam(lists, 2) Box(VarParam(lists, 2)))  ((lambda (fold) (begin (set! VarParam(fold, 0) Box(VarParam(fold, 0)))  BoxSet(VarParam(fold, 0), (lambda (obj lists) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(car, 2, 4)) VarParam(lists, 1))) VarParam(obj, 0) (BoxGet(VarBound(fold, 0, 0)) (BoxGet(VarBound(apply, 2, 1)) BoxGet(VarBound(f, 1, 0))  (BoxGet(VarBound(cons, 2, 2)) VarParam(obj, 0)  (BoxGet(VarBound(map, 2, 3)) BoxGet(VarBound(car, 2, 4))  VarParam(lists, 1))))  (BoxGet(VarBound(map, 2, 3)) BoxGet(VarBound(cdr, 2, 5))  VarParam(lists, 1))))))  (BoxGet(VarParam(fold, 0)) BoxGet(VarBound(obj, 0, 1))  BoxGet(VarBound(lists, 0, 2))))) whatever)))))
push rbx
; Env Extend Code Section For Closure#25
mov rbx, 0 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend25
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End25

LClosureEnvExtend25:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, -1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 0
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop25:
  jz LClosureEnvExtend_LoopEnd25
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop25

LClosureEnvExtend_LoopEnd25:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd25
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop25:
  jz LClosureEnvExtend_ParamsLoopEnd25

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop25

LClosureEnvExtend_ParamsLoopEnd25:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End25:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode25)
pop rbx
jmp LClosureCont25
LClosureCode25:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #26: (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(apply, 1) Box(VarParam(apply, 1)))  (set! VarParam(cons, 2) Box(VarParam(cons, 2)))  (set! VarParam(map, 3) Box(VarParam(map, 3)))  (set! VarParam(car, 4) Box(VarParam(car, 4)))  (set! VarParam(cdr, 5) Box(VarParam(cdr, 5)))  (lambda (f obj . lists) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(obj, 1) Box(VarParam(obj, 1)))  (set! VarParam(lists, 2) Box(VarParam(lists, 2)))  ((lambda (fold) (begin (set! VarParam(fold, 0) Box(VarParam(fold, 0)))  BoxSet(VarParam(fold, 0), (lambda (obj lists) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(car, 2, 4)) VarParam(lists, 1))) VarParam(obj, 0) (BoxGet(VarBound(fold, 0, 0)) (BoxGet(VarBound(apply, 2, 1)) BoxGet(VarBound(f, 1, 0))  (BoxGet(VarBound(cons, 2, 2)) VarParam(obj, 0)  (BoxGet(VarBound(map, 2, 3)) BoxGet(VarBound(car, 2, 4))  VarParam(lists, 1))))  (BoxGet(VarBound(map, 2, 3)) BoxGet(VarBound(cdr, 2, 5))  VarParam(lists, 1))))))  (BoxGet(VarParam(fold, 0)) BoxGet(VarBound(obj, 0, 1))  BoxGet(VarBound(lists, 0, 2))))) whatever))))
;; Starting: Item 0 in Seq statement #26
;; Starting: Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(null?, 0)
;; Starting: Get VarParam(name=null?, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=null?, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(null?, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0))

;; Finished: Item 0 in Seq statement #26


;; Starting: Item 1 in Seq statement #26
;; Starting: Set VarParam(name=apply, minor=1) with Box(VarParam(apply, 1))
;; Starting: Evaluating rhs for [ Set VarParam(name=apply, minor=1) with Box(VarParam(apply, 1)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(apply, 1)
;; Starting: Get VarParam(name=apply, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=apply, minor=1)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(apply, 1)

;; Finished: Evaluating rhs for [ Set VarParam(name=apply, minor=1) with Box(VarParam(apply, 1)) ], value is expected in rax

mov PVAR(1), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=apply, minor=1) with Box(VarParam(apply, 1))

;; Finished: Item 1 in Seq statement #26


;; Starting: Item 2 in Seq statement #26
;; Starting: Set VarParam(name=cons, minor=2) with Box(VarParam(cons, 2))
;; Starting: Evaluating rhs for [ Set VarParam(name=cons, minor=2) with Box(VarParam(cons, 2)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(cons, 2)
;; Starting: Get VarParam(name=cons, minor=2)
mov rax, PVAR(2)
;; Finished: Get VarParam(name=cons, minor=2)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(cons, 2)

;; Finished: Evaluating rhs for [ Set VarParam(name=cons, minor=2) with Box(VarParam(cons, 2)) ], value is expected in rax

mov PVAR(2), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=cons, minor=2) with Box(VarParam(cons, 2))

;; Finished: Item 2 in Seq statement #26


;; Starting: Item 3 in Seq statement #26
;; Starting: Set VarParam(name=map, minor=3) with Box(VarParam(map, 3))
;; Starting: Evaluating rhs for [ Set VarParam(name=map, minor=3) with Box(VarParam(map, 3)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(map, 3)
;; Starting: Get VarParam(name=map, minor=3)
mov rax, PVAR(3)
;; Finished: Get VarParam(name=map, minor=3)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(map, 3)

;; Finished: Evaluating rhs for [ Set VarParam(name=map, minor=3) with Box(VarParam(map, 3)) ], value is expected in rax

mov PVAR(3), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=map, minor=3) with Box(VarParam(map, 3))

;; Finished: Item 3 in Seq statement #26


;; Starting: Item 4 in Seq statement #26
;; Starting: Set VarParam(name=car, minor=4) with Box(VarParam(car, 4))
;; Starting: Evaluating rhs for [ Set VarParam(name=car, minor=4) with Box(VarParam(car, 4)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(car, 4)
;; Starting: Get VarParam(name=car, minor=4)
mov rax, PVAR(4)
;; Finished: Get VarParam(name=car, minor=4)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(car, 4)

;; Finished: Evaluating rhs for [ Set VarParam(name=car, minor=4) with Box(VarParam(car, 4)) ], value is expected in rax

mov PVAR(4), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=car, minor=4) with Box(VarParam(car, 4))

;; Finished: Item 4 in Seq statement #26


;; Starting: Item 5 in Seq statement #26
;; Starting: Set VarParam(name=cdr, minor=5) with Box(VarParam(cdr, 5))
;; Starting: Evaluating rhs for [ Set VarParam(name=cdr, minor=5) with Box(VarParam(cdr, 5)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(cdr, 5)
;; Starting: Get VarParam(name=cdr, minor=5)
mov rax, PVAR(5)
;; Finished: Get VarParam(name=cdr, minor=5)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(cdr, 5)

;; Finished: Evaluating rhs for [ Set VarParam(name=cdr, minor=5) with Box(VarParam(cdr, 5)) ], value is expected in rax

mov PVAR(5), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=cdr, minor=5) with Box(VarParam(cdr, 5))

;; Finished: Item 5 in Seq statement #26


;; Starting: Item 6 in Seq statement #26

;; Finished: Item 6 in Seq statement #26

;; Finished: Seq statement #26: (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(apply, 1) Box(VarParam(apply, 1)))  (set! VarParam(cons, 2) Box(VarParam(cons, 2)))  (set! VarParam(map, 3) Box(VarParam(map, 3)))  (set! VarParam(car, 4) Box(VarParam(car, 4)))  (set! VarParam(cdr, 5) Box(VarParam(cdr, 5)))  (lambda (f obj . lists) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(obj, 1) Box(VarParam(obj, 1)))  (set! VarParam(lists, 2) Box(VarParam(lists, 2)))  ((lambda (fold) (begin (set! VarParam(fold, 0) Box(VarParam(fold, 0)))  BoxSet(VarParam(fold, 0), (lambda (obj lists) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(car, 2, 4)) VarParam(lists, 1))) VarParam(obj, 0) (BoxGet(VarBound(fold, 0, 0)) (BoxGet(VarBound(apply, 2, 1)) BoxGet(VarBound(f, 1, 0))  (BoxGet(VarBound(cons, 2, 2)) VarParam(obj, 0)  (BoxGet(VarBound(map, 2, 3)) BoxGet(VarBound(car, 2, 4))  VarParam(lists, 1))))  (BoxGet(VarBound(map, 2, 3)) BoxGet(VarBound(cdr, 2, 5))  VarParam(lists, 1))))))  (BoxGet(VarParam(fold, 0)) BoxGet(VarBound(obj, 0, 1))  BoxGet(VarBound(lists, 0, 2))))) whatever))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont25:

;; Finished: Creating CLOSURE of LambdaSimple#25 -> (lambda (null? apply cons map car cdr) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(apply, 1) Box(VarParam(apply, 1)))  (set! VarParam(cons, 2) Box(VarParam(cons, 2)))  (set! VarParam(map, 3) Box(VarParam(map, 3)))  (set! VarParam(car, 4) Box(VarParam(car, 4)))  (set! VarParam(cdr, 5) Box(VarParam(cdr, 5)))  (lambda (f obj . lists) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(obj, 1) Box(VarParam(obj, 1)))  (set! VarParam(lists, 2) Box(VarParam(lists, 2)))  ((lambda (fold) (begin (set! VarParam(fold, 0) Box(VarParam(fold, 0)))  BoxSet(VarParam(fold, 0), (lambda (obj lists) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(car, 2, 4)) VarParam(lists, 1))) VarParam(obj, 0) (BoxGet(VarBound(fold, 0, 0)) (BoxGet(VarBound(apply, 2, 1)) BoxGet(VarBound(f, 1, 0))  (BoxGet(VarBound(cons, 2, 2)) VarParam(obj, 0)  (BoxGet(VarBound(map, 2, 3)) BoxGet(VarBound(car, 2, 4))  VarParam(lists, 1))))  (BoxGet(VarBound(map, 2, 3)) BoxGet(VarBound(cdr, 2, 5))  VarParam(lists, 1))))))  (BoxGet(VarParam(fold, 0)) BoxGet(VarBound(obj, 0, 1))  BoxGet(VarBound(lists, 0, 2))))) whatever)))))

;; Finished: Evaluating proc to apply (in Applic #24)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic24
int 3
ContinueApplic24:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #24
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#24 of: ((lambda (null? apply cons map car cdr) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(apply, 1) Box(VarParam(apply, 1)))  (set! VarParam(cons, 2) Box(VarParam(cons, 2)))  (set! VarParam(map, 3) Box(VarParam(map, 3)))  (set! VarParam(car, 4) Box(VarParam(car, 4)))  (set! VarParam(cdr, 5) Box(VarParam(cdr, 5)))  (lambda (f obj . lists) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(obj, 1) Box(VarParam(obj, 1)))  (set! VarParam(lists, 2) Box(VarParam(lists, 2)))  ((lambda (fold) (begin (set! VarParam(fold, 0) Box(VarParam(fold, 0)))  BoxSet(VarParam(fold, 0), (lambda (obj lists) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(car, 2, 4)) VarParam(lists, 1))) VarParam(obj, 0) (BoxGet(VarBound(fold, 0, 0)) (BoxGet(VarBound(apply, 2, 1)) BoxGet(VarBound(f, 1, 0))  (BoxGet(VarBound(cons, 2, 2)) VarParam(obj, 0)  (BoxGet(VarBound(map, 2, 3)) BoxGet(VarBound(car, 2, 4))  VarParam(lists, 1))))  (BoxGet(VarBound(map, 2, 3)) BoxGet(VarBound(cdr, 2, 5))  VarParam(lists, 1))))))  (BoxGet(VarParam(fold, 0)) BoxGet(VarBound(obj, 0, 1))  BoxGet(VarBound(lists, 0, 2))))) whatever))))) VarFree(null?)  VarFree(apply)  VarFree(cons)  VarFree(map)  VarFree(car)  VarFree(cdr))

mov qword [fvar_tbl+8*6], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar fold-left to ((lambda (null? apply cons map car cdr) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(apply, 1) Box(VarParam(apply, 1)))  (set! VarParam(cons, 2) Box(VarParam(cons, 2)))  (set! VarParam(map, 3) Box(VarParam(map, 3)))  (set! VarParam(car, 4) Box(VarParam(car, 4)))  (set! VarParam(cdr, 5) Box(VarParam(cdr, 5)))  (lambda (f obj . lists) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(obj, 1) Box(VarParam(obj, 1)))  (set! VarParam(lists, 2) Box(VarParam(lists, 2)))  ((lambda (fold) (begin (set! VarParam(fold, 0) Box(VarParam(fold, 0)))  BoxSet(VarParam(fold, 0), (lambda (obj lists) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(car, 2, 4)) VarParam(lists, 1))) VarParam(obj, 0) (BoxGet(VarBound(fold, 0, 0)) (BoxGet(VarBound(apply, 2, 1)) BoxGet(VarBound(f, 1, 0))  (BoxGet(VarBound(cons, 2, 2)) VarParam(obj, 0)  (BoxGet(VarBound(map, 2, 3)) BoxGet(VarBound(car, 2, 4))  VarParam(lists, 1))))  (BoxGet(VarBound(map, 2, 3)) BoxGet(VarBound(cdr, 2, 5))  VarParam(lists, 1))))))  (BoxGet(VarParam(fold, 0)) BoxGet(VarBound(obj, 0, 1))  BoxGet(VarBound(lists, 0, 2))))) whatever))))) VarFree(null?)  VarFree(apply)  VarFree(cons)  VarFree(map)  VarFree(car)  VarFree(cdr))

	call write_sob_if_not_void

;; Starting: Set fvar fold-right to ((lambda (null? cons car cdr apply map append) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(cons, 1) Box(VarParam(cons, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  (set! VarParam(apply, 4) Box(VarParam(apply, 4)))  (set! VarParam(map, 5) Box(VarParam(map, 5)))  (set! VarParam(append, 6) Box(VarParam(append, 6)))  (lambda (f obj . lists) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(obj, 1) Box(VarParam(obj, 1)))  (set! VarParam(lists, 2) Box(VarParam(lists, 2)))  ((lambda (fold) (begin (set! VarParam(fold, 0) Box(VarParam(fold, 0)))  BoxSet(VarParam(fold, 0), (lambda (f obj lists) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(car, 2, 2)) VarParam(lists, 2))) VarParam(obj, 1) ((lambda (car-lists res) (BoxGet(VarBound(apply, 3, 4)) VarBound(f, 0, 0)  (BoxGet(VarBound(append, 3, 6)) VarParam(car-lists, 0)  (BoxGet(VarBound(cons, 3, 1)) VarParam(res, 1)  ())))) (BoxGet(VarBound(map, 2, 5)) BoxGet(VarBound(car, 2, 2))  VarParam(lists, 2))  (BoxGet(VarBound(fold, 0, 0)) VarParam(f, 0)  VarParam(obj, 1)  (BoxGet(VarBound(map, 2, 5)) BoxGet(VarBound(cdr, 2, 3))  VarParam(lists, 2)))))))  (BoxGet(VarParam(fold, 0)) BoxGet(VarBound(f, 0, 0))  BoxGet(VarBound(obj, 0, 1))  BoxGet(VarBound(lists, 0, 2))))) whatever))))) VarFree(null?)  VarFree(cons)  VarFree(car)  VarFree(cdr)  VarFree(apply)  VarFree(map)  (lambda (lst x) (begin (set! VarParam(lst, 0) Box(VarParam(lst, 0)))  (set! VarParam(x, 1) Box(VarParam(x, 1)))  (if (VarFree(null?) BoxGet(VarParam(lst, 0))) BoxGet(VarParam(x, 1)) (VarFree(cons) (VarFree(car) BoxGet(VarParam(lst, 0)))  (VarFree(append) (VarFree(cdr) BoxGet(VarParam(lst, 0)))  BoxGet(VarParam(x, 1))))))))
;; Starting: Perform Applic#27 of: ((lambda (null? cons car cdr apply map append) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(cons, 1) Box(VarParam(cons, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  (set! VarParam(apply, 4) Box(VarParam(apply, 4)))  (set! VarParam(map, 5) Box(VarParam(map, 5)))  (set! VarParam(append, 6) Box(VarParam(append, 6)))  (lambda (f obj . lists) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(obj, 1) Box(VarParam(obj, 1)))  (set! VarParam(lists, 2) Box(VarParam(lists, 2)))  ((lambda (fold) (begin (set! VarParam(fold, 0) Box(VarParam(fold, 0)))  BoxSet(VarParam(fold, 0), (lambda (f obj lists) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(car, 2, 2)) VarParam(lists, 2))) VarParam(obj, 1) ((lambda (car-lists res) (BoxGet(VarBound(apply, 3, 4)) VarBound(f, 0, 0)  (BoxGet(VarBound(append, 3, 6)) VarParam(car-lists, 0)  (BoxGet(VarBound(cons, 3, 1)) VarParam(res, 1)  ())))) (BoxGet(VarBound(map, 2, 5)) BoxGet(VarBound(car, 2, 2))  VarParam(lists, 2))  (BoxGet(VarBound(fold, 0, 0)) VarParam(f, 0)  VarParam(obj, 1)  (BoxGet(VarBound(map, 2, 5)) BoxGet(VarBound(cdr, 2, 3))  VarParam(lists, 2)))))))  (BoxGet(VarParam(fold, 0)) BoxGet(VarBound(f, 0, 0))  BoxGet(VarBound(obj, 0, 1))  BoxGet(VarBound(lists, 0, 2))))) whatever))))) VarFree(null?)  VarFree(cons)  VarFree(car)  VarFree(cdr)  VarFree(apply)  VarFree(map)  (lambda (lst x) (begin (set! VarParam(lst, 0) Box(VarParam(lst, 0)))  (set! VarParam(x, 1) Box(VarParam(x, 1)))  (if (VarFree(null?) BoxGet(VarParam(lst, 0))) BoxGet(VarParam(x, 1)) (VarFree(cons) (VarFree(car) BoxGet(VarParam(lst, 0)))  (VarFree(append) (VarFree(cdr) BoxGet(VarParam(lst, 0)))  BoxGet(VarParam(x, 1))))))))
;; Starting: Argument 6 of Applic statement #27
;; Starting: Creating CLOSURE of LambdaSimple#28 -> (lambda (lst x) (begin (set! VarParam(lst, 0) Box(VarParam(lst, 0)))  (set! VarParam(x, 1) Box(VarParam(x, 1)))  (if (VarFree(null?) BoxGet(VarParam(lst, 0))) BoxGet(VarParam(x, 1)) (VarFree(cons) (VarFree(car) BoxGet(VarParam(lst, 0)))  (VarFree(append) (VarFree(cdr) BoxGet(VarParam(lst, 0)))  BoxGet(VarParam(x, 1)))))))
push rbx
; Env Extend Code Section For Closure#28
mov rbx, 0 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend28
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End28

LClosureEnvExtend28:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, -1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 0
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop28:
  jz LClosureEnvExtend_LoopEnd28
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop28

LClosureEnvExtend_LoopEnd28:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd28
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop28:
  jz LClosureEnvExtend_ParamsLoopEnd28

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop28

LClosureEnvExtend_ParamsLoopEnd28:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End28:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode28)
pop rbx
jmp LClosureCont28
LClosureCode28:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #29: (begin (set! VarParam(lst, 0) Box(VarParam(lst, 0)))  (set! VarParam(x, 1) Box(VarParam(x, 1)))  (if (VarFree(null?) BoxGet(VarParam(lst, 0))) BoxGet(VarParam(x, 1)) (VarFree(cons) (VarFree(car) BoxGet(VarParam(lst, 0)))  (VarFree(append) (VarFree(cdr) BoxGet(VarParam(lst, 0)))  BoxGet(VarParam(x, 1))))))
;; Starting: Item 0 in Seq statement #29
;; Starting: Set VarParam(name=lst, minor=0) with Box(VarParam(lst, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=lst, minor=0) with Box(VarParam(lst, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(lst, 0)
;; Starting: Get VarParam(name=lst, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=lst, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(lst, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=lst, minor=0) with Box(VarParam(lst, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=lst, minor=0) with Box(VarParam(lst, 0))

;; Finished: Item 0 in Seq statement #29


;; Starting: Item 1 in Seq statement #29
;; Starting: Set VarParam(name=x, minor=1) with Box(VarParam(x, 1))
;; Starting: Evaluating rhs for [ Set VarParam(name=x, minor=1) with Box(VarParam(x, 1)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(x, 1)
;; Starting: Get VarParam(name=x, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=x, minor=1)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(x, 1)

;; Finished: Evaluating rhs for [ Set VarParam(name=x, minor=1) with Box(VarParam(x, 1)) ], value is expected in rax

mov PVAR(1), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=x, minor=1) with Box(VarParam(x, 1))

;; Finished: Item 1 in Seq statement #29


;; Starting: Item 2 in Seq statement #29
;; Starting: If statement (#30): (if (VarFree(null?) BoxGet(VarParam(lst, 0))) BoxGet(VarParam(x, 1)) (VarFree(cons) (VarFree(car) BoxGet(VarParam(lst, 0)))  (VarFree(append) (VarFree(cdr) BoxGet(VarParam(lst, 0)))  BoxGet(VarParam(x, 1)))))
Lif30:
;; Starting: Perform Applic#31 of: (VarFree(null?) BoxGet(VarParam(lst, 0)))
;; Starting: Argument 0 of Applic statement #31
;; Starting: BoxGet of VarParam(lst, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(lst, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=lst, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=lst, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(lst, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(lst, 0)

;; Finished: Argument 0 of Applic statement #31

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #31)
mov rax, qword [fvar_tbl+8*1]	; mov fvar null? to rax
;; Finished: Evaluating proc to apply (in Applic #31)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic31
int 3
ContinueApplic31:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #31
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#31 of: (VarFree(null?) BoxGet(VarParam(lst, 0)))

cmp rax, SOB_FALSE_ADDRESS
je Lelse30
;; Starting: BoxGet of VarParam(x, 1)
;; Starting: Evaluating val for [ BoxGet of VarParam(x, 1) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=x, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=x, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarParam(x, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(x, 1)

jmp LendIf30
Lelse30:
;; Starting: Perform Applic#32 of: (VarFree(cons) (VarFree(car) BoxGet(VarParam(lst, 0)))  (VarFree(append) (VarFree(cdr) BoxGet(VarParam(lst, 0)))  BoxGet(VarParam(x, 1))))
;; Starting: Argument 1 of Applic statement #32
;; Starting: Perform Applic#34 of: (VarFree(append) (VarFree(cdr) BoxGet(VarParam(lst, 0)))  BoxGet(VarParam(x, 1)))
;; Starting: Argument 1 of Applic statement #34
;; Starting: BoxGet of VarParam(x, 1)
;; Starting: Evaluating val for [ BoxGet of VarParam(x, 1) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=x, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=x, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarParam(x, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(x, 1)

;; Finished: Argument 1 of Applic statement #34

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #34
;; Starting: Perform Applic#35 of: (VarFree(cdr) BoxGet(VarParam(lst, 0)))
;; Starting: Argument 0 of Applic statement #35
;; Starting: BoxGet of VarParam(lst, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(lst, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=lst, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=lst, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(lst, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(lst, 0)

;; Finished: Argument 0 of Applic statement #35

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #35)
mov rax, qword [fvar_tbl+8*3]	; mov fvar cdr to rax
;; Finished: Evaluating proc to apply (in Applic #35)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic35
int 3
ContinueApplic35:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #35
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#35 of: (VarFree(cdr) BoxGet(VarParam(lst, 0)))

;; Finished: Argument 0 of Applic statement #34

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #34)
mov rax, qword [fvar_tbl+8*8]	; mov fvar append to rax
;; Finished: Evaluating proc to apply (in Applic #34)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic34
int 3
ContinueApplic34:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #34
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#34 of: (VarFree(append) (VarFree(cdr) BoxGet(VarParam(lst, 0)))  BoxGet(VarParam(x, 1)))

;; Finished: Argument 1 of Applic statement #32

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #32
;; Starting: Perform Applic#33 of: (VarFree(car) BoxGet(VarParam(lst, 0)))
;; Starting: Argument 0 of Applic statement #33
;; Starting: BoxGet of VarParam(lst, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(lst, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=lst, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=lst, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(lst, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(lst, 0)

;; Finished: Argument 0 of Applic statement #33

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #33)
mov rax, qword [fvar_tbl+8*2]	; mov fvar car to rax
;; Finished: Evaluating proc to apply (in Applic #33)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic33
int 3
ContinueApplic33:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #33
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#33 of: (VarFree(car) BoxGet(VarParam(lst, 0)))

;; Finished: Argument 0 of Applic statement #32

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #32)
mov rax, qword [fvar_tbl+8*4]	; mov fvar cons to rax
;; Finished: Evaluating proc to apply (in Applic #32)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic32
int 3
ContinueApplic32:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #32
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#32 of: (VarFree(cons) (VarFree(car) BoxGet(VarParam(lst, 0)))  (VarFree(append) (VarFree(cdr) BoxGet(VarParam(lst, 0)))  BoxGet(VarParam(x, 1))))

LendIf30:
;; Finished: If statement (#30): (if (VarFree(null?) BoxGet(VarParam(lst, 0))) BoxGet(VarParam(x, 1)) (VarFree(cons) (VarFree(car) BoxGet(VarParam(lst, 0)))  (VarFree(append) (VarFree(cdr) BoxGet(VarParam(lst, 0)))  BoxGet(VarParam(x, 1)))))

;; Finished: Item 2 in Seq statement #29

;; Finished: Seq statement #29: (begin (set! VarParam(lst, 0) Box(VarParam(lst, 0)))  (set! VarParam(x, 1) Box(VarParam(x, 1)))  (if (VarFree(null?) BoxGet(VarParam(lst, 0))) BoxGet(VarParam(x, 1)) (VarFree(cons) (VarFree(car) BoxGet(VarParam(lst, 0)))  (VarFree(append) (VarFree(cdr) BoxGet(VarParam(lst, 0)))  BoxGet(VarParam(x, 1))))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont28:

;; Finished: Creating CLOSURE of LambdaSimple#28 -> (lambda (lst x) (begin (set! VarParam(lst, 0) Box(VarParam(lst, 0)))  (set! VarParam(x, 1) Box(VarParam(x, 1)))  (if (VarFree(null?) BoxGet(VarParam(lst, 0))) BoxGet(VarParam(x, 1)) (VarFree(cons) (VarFree(car) BoxGet(VarParam(lst, 0)))  (VarFree(append) (VarFree(cdr) BoxGet(VarParam(lst, 0)))  BoxGet(VarParam(x, 1)))))))

;; Finished: Argument 6 of Applic statement #27

push rax ; Push argument to stack;; Starting: Argument 5 of Applic statement #27
mov rax, qword [fvar_tbl+8*0]	; mov fvar map to rax
;; Finished: Argument 5 of Applic statement #27

push rax ; Push argument to stack;; Starting: Argument 4 of Applic statement #27
mov rax, qword [fvar_tbl+8*5]	; mov fvar apply to rax
;; Finished: Argument 4 of Applic statement #27

push rax ; Push argument to stack;; Starting: Argument 3 of Applic statement #27
mov rax, qword [fvar_tbl+8*3]	; mov fvar cdr to rax
;; Finished: Argument 3 of Applic statement #27

push rax ; Push argument to stack;; Starting: Argument 2 of Applic statement #27
mov rax, qword [fvar_tbl+8*2]	; mov fvar car to rax
;; Finished: Argument 2 of Applic statement #27

push rax ; Push argument to stack;; Starting: Argument 1 of Applic statement #27
mov rax, qword [fvar_tbl+8*4]	; mov fvar cons to rax
;; Finished: Argument 1 of Applic statement #27

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #27
mov rax, qword [fvar_tbl+8*1]	; mov fvar null? to rax
;; Finished: Argument 0 of Applic statement #27

push rax ; Push argument to stack
push qword 7 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #27)
;; Starting: Creating CLOSURE of LambdaSimple#36 -> (lambda (null? cons car cdr apply map append) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(cons, 1) Box(VarParam(cons, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  (set! VarParam(apply, 4) Box(VarParam(apply, 4)))  (set! VarParam(map, 5) Box(VarParam(map, 5)))  (set! VarParam(append, 6) Box(VarParam(append, 6)))  (lambda (f obj . lists) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(obj, 1) Box(VarParam(obj, 1)))  (set! VarParam(lists, 2) Box(VarParam(lists, 2)))  ((lambda (fold) (begin (set! VarParam(fold, 0) Box(VarParam(fold, 0)))  BoxSet(VarParam(fold, 0), (lambda (f obj lists) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(car, 2, 2)) VarParam(lists, 2))) VarParam(obj, 1) ((lambda (car-lists res) (BoxGet(VarBound(apply, 3, 4)) VarBound(f, 0, 0)  (BoxGet(VarBound(append, 3, 6)) VarParam(car-lists, 0)  (BoxGet(VarBound(cons, 3, 1)) VarParam(res, 1)  ())))) (BoxGet(VarBound(map, 2, 5)) BoxGet(VarBound(car, 2, 2))  VarParam(lists, 2))  (BoxGet(VarBound(fold, 0, 0)) VarParam(f, 0)  VarParam(obj, 1)  (BoxGet(VarBound(map, 2, 5)) BoxGet(VarBound(cdr, 2, 3))  VarParam(lists, 2)))))))  (BoxGet(VarParam(fold, 0)) BoxGet(VarBound(f, 0, 0))  BoxGet(VarBound(obj, 0, 1))  BoxGet(VarBound(lists, 0, 2))))) whatever)))))
push rbx
; Env Extend Code Section For Closure#36
mov rbx, 1 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend36
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End36

LClosureEnvExtend36:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 0
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 8
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop36:
  jz LClosureEnvExtend_LoopEnd36
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop36

LClosureEnvExtend_LoopEnd36:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd36
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop36:
  jz LClosureEnvExtend_ParamsLoopEnd36

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop36

LClosureEnvExtend_ParamsLoopEnd36:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End36:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode36)
pop rbx
jmp LClosureCont36
LClosureCode36:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #37: (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(cons, 1) Box(VarParam(cons, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  (set! VarParam(apply, 4) Box(VarParam(apply, 4)))  (set! VarParam(map, 5) Box(VarParam(map, 5)))  (set! VarParam(append, 6) Box(VarParam(append, 6)))  (lambda (f obj . lists) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(obj, 1) Box(VarParam(obj, 1)))  (set! VarParam(lists, 2) Box(VarParam(lists, 2)))  ((lambda (fold) (begin (set! VarParam(fold, 0) Box(VarParam(fold, 0)))  BoxSet(VarParam(fold, 0), (lambda (f obj lists) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(car, 2, 2)) VarParam(lists, 2))) VarParam(obj, 1) ((lambda (car-lists res) (BoxGet(VarBound(apply, 3, 4)) VarBound(f, 0, 0)  (BoxGet(VarBound(append, 3, 6)) VarParam(car-lists, 0)  (BoxGet(VarBound(cons, 3, 1)) VarParam(res, 1)  ())))) (BoxGet(VarBound(map, 2, 5)) BoxGet(VarBound(car, 2, 2))  VarParam(lists, 2))  (BoxGet(VarBound(fold, 0, 0)) VarParam(f, 0)  VarParam(obj, 1)  (BoxGet(VarBound(map, 2, 5)) BoxGet(VarBound(cdr, 2, 3))  VarParam(lists, 2)))))))  (BoxGet(VarParam(fold, 0)) BoxGet(VarBound(f, 0, 0))  BoxGet(VarBound(obj, 0, 1))  BoxGet(VarBound(lists, 0, 2))))) whatever))))
;; Starting: Item 0 in Seq statement #37
;; Starting: Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(null?, 0)
;; Starting: Get VarParam(name=null?, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=null?, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(null?, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0))

;; Finished: Item 0 in Seq statement #37


;; Starting: Item 1 in Seq statement #37
;; Starting: Set VarParam(name=cons, minor=1) with Box(VarParam(cons, 1))
;; Starting: Evaluating rhs for [ Set VarParam(name=cons, minor=1) with Box(VarParam(cons, 1)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(cons, 1)
;; Starting: Get VarParam(name=cons, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=cons, minor=1)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(cons, 1)

;; Finished: Evaluating rhs for [ Set VarParam(name=cons, minor=1) with Box(VarParam(cons, 1)) ], value is expected in rax

mov PVAR(1), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=cons, minor=1) with Box(VarParam(cons, 1))

;; Finished: Item 1 in Seq statement #37


;; Starting: Item 2 in Seq statement #37
;; Starting: Set VarParam(name=car, minor=2) with Box(VarParam(car, 2))
;; Starting: Evaluating rhs for [ Set VarParam(name=car, minor=2) with Box(VarParam(car, 2)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(car, 2)
;; Starting: Get VarParam(name=car, minor=2)
mov rax, PVAR(2)
;; Finished: Get VarParam(name=car, minor=2)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(car, 2)

;; Finished: Evaluating rhs for [ Set VarParam(name=car, minor=2) with Box(VarParam(car, 2)) ], value is expected in rax

mov PVAR(2), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=car, minor=2) with Box(VarParam(car, 2))

;; Finished: Item 2 in Seq statement #37


;; Starting: Item 3 in Seq statement #37
;; Starting: Set VarParam(name=cdr, minor=3) with Box(VarParam(cdr, 3))
;; Starting: Evaluating rhs for [ Set VarParam(name=cdr, minor=3) with Box(VarParam(cdr, 3)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(cdr, 3)
;; Starting: Get VarParam(name=cdr, minor=3)
mov rax, PVAR(3)
;; Finished: Get VarParam(name=cdr, minor=3)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(cdr, 3)

;; Finished: Evaluating rhs for [ Set VarParam(name=cdr, minor=3) with Box(VarParam(cdr, 3)) ], value is expected in rax

mov PVAR(3), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=cdr, minor=3) with Box(VarParam(cdr, 3))

;; Finished: Item 3 in Seq statement #37


;; Starting: Item 4 in Seq statement #37
;; Starting: Set VarParam(name=apply, minor=4) with Box(VarParam(apply, 4))
;; Starting: Evaluating rhs for [ Set VarParam(name=apply, minor=4) with Box(VarParam(apply, 4)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(apply, 4)
;; Starting: Get VarParam(name=apply, minor=4)
mov rax, PVAR(4)
;; Finished: Get VarParam(name=apply, minor=4)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(apply, 4)

;; Finished: Evaluating rhs for [ Set VarParam(name=apply, minor=4) with Box(VarParam(apply, 4)) ], value is expected in rax

mov PVAR(4), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=apply, minor=4) with Box(VarParam(apply, 4))

;; Finished: Item 4 in Seq statement #37


;; Starting: Item 5 in Seq statement #37
;; Starting: Set VarParam(name=map, minor=5) with Box(VarParam(map, 5))
;; Starting: Evaluating rhs for [ Set VarParam(name=map, minor=5) with Box(VarParam(map, 5)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(map, 5)
;; Starting: Get VarParam(name=map, minor=5)
mov rax, PVAR(5)
;; Finished: Get VarParam(name=map, minor=5)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(map, 5)

;; Finished: Evaluating rhs for [ Set VarParam(name=map, minor=5) with Box(VarParam(map, 5)) ], value is expected in rax

mov PVAR(5), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=map, minor=5) with Box(VarParam(map, 5))

;; Finished: Item 5 in Seq statement #37


;; Starting: Item 6 in Seq statement #37
;; Starting: Set VarParam(name=append, minor=6) with Box(VarParam(append, 6))
;; Starting: Evaluating rhs for [ Set VarParam(name=append, minor=6) with Box(VarParam(append, 6)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(append, 6)
;; Starting: Get VarParam(name=append, minor=6)
mov rax, PVAR(6)
;; Finished: Get VarParam(name=append, minor=6)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(append, 6)

;; Finished: Evaluating rhs for [ Set VarParam(name=append, minor=6) with Box(VarParam(append, 6)) ], value is expected in rax

mov PVAR(6), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=append, minor=6) with Box(VarParam(append, 6))

;; Finished: Item 6 in Seq statement #37


;; Starting: Item 7 in Seq statement #37

;; Finished: Item 7 in Seq statement #37

;; Finished: Seq statement #37: (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(cons, 1) Box(VarParam(cons, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  (set! VarParam(apply, 4) Box(VarParam(apply, 4)))  (set! VarParam(map, 5) Box(VarParam(map, 5)))  (set! VarParam(append, 6) Box(VarParam(append, 6)))  (lambda (f obj . lists) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(obj, 1) Box(VarParam(obj, 1)))  (set! VarParam(lists, 2) Box(VarParam(lists, 2)))  ((lambda (fold) (begin (set! VarParam(fold, 0) Box(VarParam(fold, 0)))  BoxSet(VarParam(fold, 0), (lambda (f obj lists) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(car, 2, 2)) VarParam(lists, 2))) VarParam(obj, 1) ((lambda (car-lists res) (BoxGet(VarBound(apply, 3, 4)) VarBound(f, 0, 0)  (BoxGet(VarBound(append, 3, 6)) VarParam(car-lists, 0)  (BoxGet(VarBound(cons, 3, 1)) VarParam(res, 1)  ())))) (BoxGet(VarBound(map, 2, 5)) BoxGet(VarBound(car, 2, 2))  VarParam(lists, 2))  (BoxGet(VarBound(fold, 0, 0)) VarParam(f, 0)  VarParam(obj, 1)  (BoxGet(VarBound(map, 2, 5)) BoxGet(VarBound(cdr, 2, 3))  VarParam(lists, 2)))))))  (BoxGet(VarParam(fold, 0)) BoxGet(VarBound(f, 0, 0))  BoxGet(VarBound(obj, 0, 1))  BoxGet(VarBound(lists, 0, 2))))) whatever))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont36:

;; Finished: Creating CLOSURE of LambdaSimple#36 -> (lambda (null? cons car cdr apply map append) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(cons, 1) Box(VarParam(cons, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  (set! VarParam(apply, 4) Box(VarParam(apply, 4)))  (set! VarParam(map, 5) Box(VarParam(map, 5)))  (set! VarParam(append, 6) Box(VarParam(append, 6)))  (lambda (f obj . lists) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(obj, 1) Box(VarParam(obj, 1)))  (set! VarParam(lists, 2) Box(VarParam(lists, 2)))  ((lambda (fold) (begin (set! VarParam(fold, 0) Box(VarParam(fold, 0)))  BoxSet(VarParam(fold, 0), (lambda (f obj lists) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(car, 2, 2)) VarParam(lists, 2))) VarParam(obj, 1) ((lambda (car-lists res) (BoxGet(VarBound(apply, 3, 4)) VarBound(f, 0, 0)  (BoxGet(VarBound(append, 3, 6)) VarParam(car-lists, 0)  (BoxGet(VarBound(cons, 3, 1)) VarParam(res, 1)  ())))) (BoxGet(VarBound(map, 2, 5)) BoxGet(VarBound(car, 2, 2))  VarParam(lists, 2))  (BoxGet(VarBound(fold, 0, 0)) VarParam(f, 0)  VarParam(obj, 1)  (BoxGet(VarBound(map, 2, 5)) BoxGet(VarBound(cdr, 2, 3))  VarParam(lists, 2)))))))  (BoxGet(VarParam(fold, 0)) BoxGet(VarBound(f, 0, 0))  BoxGet(VarBound(obj, 0, 1))  BoxGet(VarBound(lists, 0, 2))))) whatever)))))

;; Finished: Evaluating proc to apply (in Applic #27)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic27
int 3
ContinueApplic27:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #27
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#27 of: ((lambda (null? cons car cdr apply map append) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(cons, 1) Box(VarParam(cons, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  (set! VarParam(apply, 4) Box(VarParam(apply, 4)))  (set! VarParam(map, 5) Box(VarParam(map, 5)))  (set! VarParam(append, 6) Box(VarParam(append, 6)))  (lambda (f obj . lists) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(obj, 1) Box(VarParam(obj, 1)))  (set! VarParam(lists, 2) Box(VarParam(lists, 2)))  ((lambda (fold) (begin (set! VarParam(fold, 0) Box(VarParam(fold, 0)))  BoxSet(VarParam(fold, 0), (lambda (f obj lists) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(car, 2, 2)) VarParam(lists, 2))) VarParam(obj, 1) ((lambda (car-lists res) (BoxGet(VarBound(apply, 3, 4)) VarBound(f, 0, 0)  (BoxGet(VarBound(append, 3, 6)) VarParam(car-lists, 0)  (BoxGet(VarBound(cons, 3, 1)) VarParam(res, 1)  ())))) (BoxGet(VarBound(map, 2, 5)) BoxGet(VarBound(car, 2, 2))  VarParam(lists, 2))  (BoxGet(VarBound(fold, 0, 0)) VarParam(f, 0)  VarParam(obj, 1)  (BoxGet(VarBound(map, 2, 5)) BoxGet(VarBound(cdr, 2, 3))  VarParam(lists, 2)))))))  (BoxGet(VarParam(fold, 0)) BoxGet(VarBound(f, 0, 0))  BoxGet(VarBound(obj, 0, 1))  BoxGet(VarBound(lists, 0, 2))))) whatever))))) VarFree(null?)  VarFree(cons)  VarFree(car)  VarFree(cdr)  VarFree(apply)  VarFree(map)  (lambda (lst x) (begin (set! VarParam(lst, 0) Box(VarParam(lst, 0)))  (set! VarParam(x, 1) Box(VarParam(x, 1)))  (if (VarFree(null?) BoxGet(VarParam(lst, 0))) BoxGet(VarParam(x, 1)) (VarFree(cons) (VarFree(car) BoxGet(VarParam(lst, 0)))  (VarFree(append) (VarFree(cdr) BoxGet(VarParam(lst, 0)))  BoxGet(VarParam(x, 1))))))))

mov qword [fvar_tbl+8*7], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar fold-right to ((lambda (null? cons car cdr apply map append) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(cons, 1) Box(VarParam(cons, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  (set! VarParam(apply, 4) Box(VarParam(apply, 4)))  (set! VarParam(map, 5) Box(VarParam(map, 5)))  (set! VarParam(append, 6) Box(VarParam(append, 6)))  (lambda (f obj . lists) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(obj, 1) Box(VarParam(obj, 1)))  (set! VarParam(lists, 2) Box(VarParam(lists, 2)))  ((lambda (fold) (begin (set! VarParam(fold, 0) Box(VarParam(fold, 0)))  BoxSet(VarParam(fold, 0), (lambda (f obj lists) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(car, 2, 2)) VarParam(lists, 2))) VarParam(obj, 1) ((lambda (car-lists res) (BoxGet(VarBound(apply, 3, 4)) VarBound(f, 0, 0)  (BoxGet(VarBound(append, 3, 6)) VarParam(car-lists, 0)  (BoxGet(VarBound(cons, 3, 1)) VarParam(res, 1)  ())))) (BoxGet(VarBound(map, 2, 5)) BoxGet(VarBound(car, 2, 2))  VarParam(lists, 2))  (BoxGet(VarBound(fold, 0, 0)) VarParam(f, 0)  VarParam(obj, 1)  (BoxGet(VarBound(map, 2, 5)) BoxGet(VarBound(cdr, 2, 3))  VarParam(lists, 2)))))))  (BoxGet(VarParam(fold, 0)) BoxGet(VarBound(f, 0, 0))  BoxGet(VarBound(obj, 0, 1))  BoxGet(VarBound(lists, 0, 2))))) whatever))))) VarFree(null?)  VarFree(cons)  VarFree(car)  VarFree(cdr)  VarFree(apply)  VarFree(map)  (lambda (lst x) (begin (set! VarParam(lst, 0) Box(VarParam(lst, 0)))  (set! VarParam(x, 1) Box(VarParam(x, 1)))  (if (VarFree(null?) BoxGet(VarParam(lst, 0))) BoxGet(VarParam(x, 1)) (VarFree(cons) (VarFree(car) BoxGet(VarParam(lst, 0)))  (VarFree(append) (VarFree(cdr) BoxGet(VarParam(lst, 0)))  BoxGet(VarParam(x, 1))))))))

	call write_sob_if_not_void

;; Starting: Set fvar cons* to ((lambda (null? cons car cdr) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(cons, 1) Box(VarParam(cons, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  (lambda (p) (begin (set! VarParam(p, 0) Box(VarParam(p, 0)))  ((lambda (cons-list) (begin (set! VarParam(cons-list, 0) Box(VarParam(cons-list, 0)))  BoxSet(VarParam(cons-list, 0), (lambda (p) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0)) (BoxGet(VarBound(cons, 2, 1)) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))  (BoxGet(VarBound(cons-list, 0, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0)))))))  (BoxGet(VarParam(cons-list, 0)) BoxGet(VarBound(p, 0, 0))))) whatever))))) VarFree(null?)  VarFree(cons)  VarFree(car)  VarFree(cdr))
;; Starting: Perform Applic#38 of: ((lambda (null? cons car cdr) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(cons, 1) Box(VarParam(cons, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  (lambda (p) (begin (set! VarParam(p, 0) Box(VarParam(p, 0)))  ((lambda (cons-list) (begin (set! VarParam(cons-list, 0) Box(VarParam(cons-list, 0)))  BoxSet(VarParam(cons-list, 0), (lambda (p) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0)) (BoxGet(VarBound(cons, 2, 1)) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))  (BoxGet(VarBound(cons-list, 0, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0)))))))  (BoxGet(VarParam(cons-list, 0)) BoxGet(VarBound(p, 0, 0))))) whatever))))) VarFree(null?)  VarFree(cons)  VarFree(car)  VarFree(cdr))
;; Starting: Argument 3 of Applic statement #38
mov rax, qword [fvar_tbl+8*3]	; mov fvar cdr to rax
;; Finished: Argument 3 of Applic statement #38

push rax ; Push argument to stack;; Starting: Argument 2 of Applic statement #38
mov rax, qword [fvar_tbl+8*2]	; mov fvar car to rax
;; Finished: Argument 2 of Applic statement #38

push rax ; Push argument to stack;; Starting: Argument 1 of Applic statement #38
mov rax, qword [fvar_tbl+8*4]	; mov fvar cons to rax
;; Finished: Argument 1 of Applic statement #38

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #38
mov rax, qword [fvar_tbl+8*1]	; mov fvar null? to rax
;; Finished: Argument 0 of Applic statement #38

push rax ; Push argument to stack
push qword 4 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #38)
;; Starting: Creating CLOSURE of LambdaSimple#39 -> (lambda (null? cons car cdr) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(cons, 1) Box(VarParam(cons, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  (lambda (p) (begin (set! VarParam(p, 0) Box(VarParam(p, 0)))  ((lambda (cons-list) (begin (set! VarParam(cons-list, 0) Box(VarParam(cons-list, 0)))  BoxSet(VarParam(cons-list, 0), (lambda (p) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0)) (BoxGet(VarBound(cons, 2, 1)) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))  (BoxGet(VarBound(cons-list, 0, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0)))))))  (BoxGet(VarParam(cons-list, 0)) BoxGet(VarBound(p, 0, 0))))) whatever)))))
push rbx
; Env Extend Code Section For Closure#39
mov rbx, 0 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend39
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End39

LClosureEnvExtend39:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, -1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 0
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop39:
  jz LClosureEnvExtend_LoopEnd39
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop39

LClosureEnvExtend_LoopEnd39:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd39
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop39:
  jz LClosureEnvExtend_ParamsLoopEnd39

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop39

LClosureEnvExtend_ParamsLoopEnd39:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End39:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode39)
pop rbx
jmp LClosureCont39
LClosureCode39:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #40: (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(cons, 1) Box(VarParam(cons, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  (lambda (p) (begin (set! VarParam(p, 0) Box(VarParam(p, 0)))  ((lambda (cons-list) (begin (set! VarParam(cons-list, 0) Box(VarParam(cons-list, 0)))  BoxSet(VarParam(cons-list, 0), (lambda (p) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0)) (BoxGet(VarBound(cons, 2, 1)) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))  (BoxGet(VarBound(cons-list, 0, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0)))))))  (BoxGet(VarParam(cons-list, 0)) BoxGet(VarBound(p, 0, 0))))) whatever))))
;; Starting: Item 0 in Seq statement #40
;; Starting: Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(null?, 0)
;; Starting: Get VarParam(name=null?, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=null?, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(null?, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0))

;; Finished: Item 0 in Seq statement #40


;; Starting: Item 1 in Seq statement #40
;; Starting: Set VarParam(name=cons, minor=1) with Box(VarParam(cons, 1))
;; Starting: Evaluating rhs for [ Set VarParam(name=cons, minor=1) with Box(VarParam(cons, 1)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(cons, 1)
;; Starting: Get VarParam(name=cons, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=cons, minor=1)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(cons, 1)

;; Finished: Evaluating rhs for [ Set VarParam(name=cons, minor=1) with Box(VarParam(cons, 1)) ], value is expected in rax

mov PVAR(1), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=cons, minor=1) with Box(VarParam(cons, 1))

;; Finished: Item 1 in Seq statement #40


;; Starting: Item 2 in Seq statement #40
;; Starting: Set VarParam(name=car, minor=2) with Box(VarParam(car, 2))
;; Starting: Evaluating rhs for [ Set VarParam(name=car, minor=2) with Box(VarParam(car, 2)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(car, 2)
;; Starting: Get VarParam(name=car, minor=2)
mov rax, PVAR(2)
;; Finished: Get VarParam(name=car, minor=2)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(car, 2)

;; Finished: Evaluating rhs for [ Set VarParam(name=car, minor=2) with Box(VarParam(car, 2)) ], value is expected in rax

mov PVAR(2), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=car, minor=2) with Box(VarParam(car, 2))

;; Finished: Item 2 in Seq statement #40


;; Starting: Item 3 in Seq statement #40
;; Starting: Set VarParam(name=cdr, minor=3) with Box(VarParam(cdr, 3))
;; Starting: Evaluating rhs for [ Set VarParam(name=cdr, minor=3) with Box(VarParam(cdr, 3)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(cdr, 3)
;; Starting: Get VarParam(name=cdr, minor=3)
mov rax, PVAR(3)
;; Finished: Get VarParam(name=cdr, minor=3)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(cdr, 3)

;; Finished: Evaluating rhs for [ Set VarParam(name=cdr, minor=3) with Box(VarParam(cdr, 3)) ], value is expected in rax

mov PVAR(3), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=cdr, minor=3) with Box(VarParam(cdr, 3))

;; Finished: Item 3 in Seq statement #40


;; Starting: Item 4 in Seq statement #40
;; Starting: Creating CLOSURE of LambdaSimple#41 -> (lambda (p) (begin (set! VarParam(p, 0) Box(VarParam(p, 0)))  ((lambda (cons-list) (begin (set! VarParam(cons-list, 0) Box(VarParam(cons-list, 0)))  BoxSet(VarParam(cons-list, 0), (lambda (p) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0)) (BoxGet(VarBound(cons, 2, 1)) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))  (BoxGet(VarBound(cons-list, 0, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0)))))))  (BoxGet(VarParam(cons-list, 0)) BoxGet(VarBound(p, 0, 0))))) whatever)))
push rbx
; Env Extend Code Section For Closure#41
mov rbx, 1 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend41
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End41

LClosureEnvExtend41:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 0
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 8
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop41:
  jz LClosureEnvExtend_LoopEnd41
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop41

LClosureEnvExtend_LoopEnd41:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd41
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop41:
  jz LClosureEnvExtend_ParamsLoopEnd41

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop41

LClosureEnvExtend_ParamsLoopEnd41:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End41:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode41)
pop rbx
jmp LClosureCont41
LClosureCode41:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #42: (begin (set! VarParam(p, 0) Box(VarParam(p, 0)))  ((lambda (cons-list) (begin (set! VarParam(cons-list, 0) Box(VarParam(cons-list, 0)))  BoxSet(VarParam(cons-list, 0), (lambda (p) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0)) (BoxGet(VarBound(cons, 2, 1)) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))  (BoxGet(VarBound(cons-list, 0, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0)))))))  (BoxGet(VarParam(cons-list, 0)) BoxGet(VarBound(p, 0, 0))))) whatever))
;; Starting: Item 0 in Seq statement #42
;; Starting: Set VarParam(name=p, minor=0) with Box(VarParam(p, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=p, minor=0) with Box(VarParam(p, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(p, 0)
;; Starting: Get VarParam(name=p, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=p, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(p, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=p, minor=0) with Box(VarParam(p, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=p, minor=0) with Box(VarParam(p, 0))

;; Finished: Item 0 in Seq statement #42


;; Starting: Item 1 in Seq statement #42
;; Starting: Perform Applic#43 of: ((lambda (cons-list) (begin (set! VarParam(cons-list, 0) Box(VarParam(cons-list, 0)))  BoxSet(VarParam(cons-list, 0), (lambda (p) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0)) (BoxGet(VarBound(cons, 2, 1)) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))  (BoxGet(VarBound(cons-list, 0, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0)))))))  (BoxGet(VarParam(cons-list, 0)) BoxGet(VarBound(p, 0, 0))))) whatever)
;; Starting: Argument 0 of Applic statement #43
mov rax, const_tbl+23	; mov const whatever to rax
;; Finished: Argument 0 of Applic statement #43

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #43)
;; Starting: Creating CLOSURE of LambdaSimple#44 -> (lambda (cons-list) (begin (set! VarParam(cons-list, 0) Box(VarParam(cons-list, 0)))  BoxSet(VarParam(cons-list, 0), (lambda (p) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0)) (BoxGet(VarBound(cons, 2, 1)) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))  (BoxGet(VarBound(cons-list, 0, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0)))))))  (BoxGet(VarParam(cons-list, 0)) BoxGet(VarBound(p, 0, 0)))))
push rbx
; Env Extend Code Section For Closure#44
mov rbx, 2 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend44
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End44

LClosureEnvExtend44:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 16
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop44:
  jz LClosureEnvExtend_LoopEnd44
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop44

LClosureEnvExtend_LoopEnd44:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd44
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop44:
  jz LClosureEnvExtend_ParamsLoopEnd44

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop44

LClosureEnvExtend_ParamsLoopEnd44:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End44:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode44)
pop rbx
jmp LClosureCont44
LClosureCode44:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #45: (begin (set! VarParam(cons-list, 0) Box(VarParam(cons-list, 0)))  BoxSet(VarParam(cons-list, 0), (lambda (p) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0)) (BoxGet(VarBound(cons, 2, 1)) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))  (BoxGet(VarBound(cons-list, 0, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0)))))))  (BoxGet(VarParam(cons-list, 0)) BoxGet(VarBound(p, 0, 0))))
;; Starting: Item 0 in Seq statement #45
;; Starting: Set VarParam(name=cons-list, minor=0) with Box(VarParam(cons-list, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=cons-list, minor=0) with Box(VarParam(cons-list, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(cons-list, 0)
;; Starting: Get VarParam(name=cons-list, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=cons-list, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(cons-list, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=cons-list, minor=0) with Box(VarParam(cons-list, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=cons-list, minor=0) with Box(VarParam(cons-list, 0))

;; Finished: Item 0 in Seq statement #45


;; Starting: Item 1 in Seq statement #45
;; Starting: BoxSet of VarParam(cons-list, 0) with (lambda (p) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0)) (BoxGet(VarBound(cons, 2, 1)) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))  (BoxGet(VarBound(cons-list, 0, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))))))
;; Starting: Evaluating rhs for [ BoxSet of VarParam(cons-list, 0) with (lambda (p) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0)) (BoxGet(VarBound(cons, 2, 1)) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))  (BoxGet(VarBound(cons-list, 0, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0)))))) ], the VALUE is expected in rax
;; Starting: Creating CLOSURE of LambdaSimple#46 -> (lambda (p) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0)) (BoxGet(VarBound(cons, 2, 1)) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))  (BoxGet(VarBound(cons-list, 0, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))))))
push rbx
; Env Extend Code Section For Closure#46
mov rbx, 3 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend46
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End46

LClosureEnvExtend46:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 2
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 24
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop46:
  jz LClosureEnvExtend_LoopEnd46
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop46

LClosureEnvExtend_LoopEnd46:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd46
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop46:
  jz LClosureEnvExtend_ParamsLoopEnd46

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop46

LClosureEnvExtend_ParamsLoopEnd46:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End46:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode46)
pop rbx
jmp LClosureCont46
LClosureCode46:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: If statement (#47): (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0)) (BoxGet(VarBound(cons, 2, 1)) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))  (BoxGet(VarBound(cons-list, 0, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0)))))
Lif47:
;; Starting: Perform Applic#48 of: (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0)))
;; Starting: Argument 0 of Applic statement #48
;; Starting: Perform Applic#49 of: (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))
;; Starting: Argument 0 of Applic statement #49
;; Starting: Get VarParam(name=p, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=p, minor=0)

;; Finished: Argument 0 of Applic statement #49

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #49)
;; Starting: BoxGet of VarBound(cdr, 2, 3)
;; Starting: Evaluating val for [ BoxGet of VarBound(cdr, 2, 3) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=cdr, major=2, minor=3)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 3]
;; Finished: Get VarBound(name=cdr, major=2, minor=3)

;; Finished: Evaluating val for [ BoxGet of VarBound(cdr, 2, 3) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(cdr, 2, 3)

;; Finished: Evaluating proc to apply (in Applic #49)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic49
int 3
ContinueApplic49:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #49
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#49 of: (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))

;; Finished: Argument 0 of Applic statement #48

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #48)
;; Starting: BoxGet of VarBound(null?, 2, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(null?, 2, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=null?, major=2, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=null?, major=2, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(null?, 2, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(null?, 2, 0)

;; Finished: Evaluating proc to apply (in Applic #48)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic48
int 3
ContinueApplic48:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #48
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#48 of: (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0)))

cmp rax, SOB_FALSE_ADDRESS
je Lelse47
;; Starting: Perform Applic#50 of: (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))
;; Starting: Argument 0 of Applic statement #50
;; Starting: Get VarParam(name=p, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=p, minor=0)

;; Finished: Argument 0 of Applic statement #50

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #50)
;; Starting: BoxGet of VarBound(car, 2, 2)
;; Starting: Evaluating val for [ BoxGet of VarBound(car, 2, 2) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=car, major=2, minor=2)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 2]
;; Finished: Get VarBound(name=car, major=2, minor=2)

;; Finished: Evaluating val for [ BoxGet of VarBound(car, 2, 2) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(car, 2, 2)

;; Finished: Evaluating proc to apply (in Applic #50)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic50
int 3
ContinueApplic50:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #50
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#50 of: (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))

jmp LendIf47
Lelse47:
;; Starting: Perform Applic#51 of: (BoxGet(VarBound(cons, 2, 1)) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))  (BoxGet(VarBound(cons-list, 0, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))))
;; Starting: Argument 1 of Applic statement #51
;; Starting: Perform Applic#53 of: (BoxGet(VarBound(cons-list, 0, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0)))
;; Starting: Argument 0 of Applic statement #53
;; Starting: Perform Applic#54 of: (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))
;; Starting: Argument 0 of Applic statement #54
;; Starting: Get VarParam(name=p, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=p, minor=0)

;; Finished: Argument 0 of Applic statement #54

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #54)
;; Starting: BoxGet of VarBound(cdr, 2, 3)
;; Starting: Evaluating val for [ BoxGet of VarBound(cdr, 2, 3) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=cdr, major=2, minor=3)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 3]
;; Finished: Get VarBound(name=cdr, major=2, minor=3)

;; Finished: Evaluating val for [ BoxGet of VarBound(cdr, 2, 3) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(cdr, 2, 3)

;; Finished: Evaluating proc to apply (in Applic #54)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic54
int 3
ContinueApplic54:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #54
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#54 of: (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))

;; Finished: Argument 0 of Applic statement #53

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #53)
;; Starting: BoxGet of VarBound(cons-list, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(cons-list, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=cons-list, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=cons-list, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(cons-list, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(cons-list, 0, 0)

;; Finished: Evaluating proc to apply (in Applic #53)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic53
int 3
ContinueApplic53:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #53
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#53 of: (BoxGet(VarBound(cons-list, 0, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0)))

;; Finished: Argument 1 of Applic statement #51

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #51
;; Starting: Perform Applic#52 of: (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))
;; Starting: Argument 0 of Applic statement #52
;; Starting: Get VarParam(name=p, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=p, minor=0)

;; Finished: Argument 0 of Applic statement #52

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #52)
;; Starting: BoxGet of VarBound(car, 2, 2)
;; Starting: Evaluating val for [ BoxGet of VarBound(car, 2, 2) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=car, major=2, minor=2)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 2]
;; Finished: Get VarBound(name=car, major=2, minor=2)

;; Finished: Evaluating val for [ BoxGet of VarBound(car, 2, 2) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(car, 2, 2)

;; Finished: Evaluating proc to apply (in Applic #52)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic52
int 3
ContinueApplic52:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #52
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#52 of: (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))

;; Finished: Argument 0 of Applic statement #51

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #51)
;; Starting: BoxGet of VarBound(cons, 2, 1)
;; Starting: Evaluating val for [ BoxGet of VarBound(cons, 2, 1) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=cons, major=2, minor=1)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 1]
;; Finished: Get VarBound(name=cons, major=2, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarBound(cons, 2, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(cons, 2, 1)

;; Finished: Evaluating proc to apply (in Applic #51)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic51
int 3
ContinueApplic51:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #51
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#51 of: (BoxGet(VarBound(cons, 2, 1)) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))  (BoxGet(VarBound(cons-list, 0, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))))

LendIf47:
;; Finished: If statement (#47): (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0)) (BoxGet(VarBound(cons, 2, 1)) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))  (BoxGet(VarBound(cons-list, 0, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0)))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont46:

;; Finished: Creating CLOSURE of LambdaSimple#46 -> (lambda (p) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0)) (BoxGet(VarBound(cons, 2, 1)) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))  (BoxGet(VarBound(cons-list, 0, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))))))

;; Finished: Evaluating rhs for [ BoxSet of VarParam(cons-list, 0) with (lambda (p) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0)) (BoxGet(VarBound(cons, 2, 1)) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))  (BoxGet(VarBound(cons-list, 0, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0)))))) ], the VALUE is expected in rax

; Save the value of rhs
push rax
;; Starting: Evaluating var for [ BoxSet of VarParam(cons-list, 0) with (lambda (p) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0)) (BoxGet(VarBound(cons, 2, 1)) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))  (BoxGet(VarBound(cons-list, 0, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0)))))) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=cons-list, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=cons-list, minor=0)

;; Finished: Evaluating var for [ BoxSet of VarParam(cons-list, 0) with (lambda (p) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0)) (BoxGet(VarBound(cons, 2, 1)) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))  (BoxGet(VarBound(cons-list, 0, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0)))))) ], the VALUE is expected in rax

; in RAX there is a address of a box, put the value we saved on stack earlier (from rhs) inside it
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;; Finished: BoxSet of VarParam(cons-list, 0) with (lambda (p) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0)) (BoxGet(VarBound(cons, 2, 1)) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))  (BoxGet(VarBound(cons-list, 0, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))))))

;; Finished: Item 1 in Seq statement #45


;; Starting: Item 2 in Seq statement #45
;; Starting: Perform Applic#55 of: (BoxGet(VarParam(cons-list, 0)) BoxGet(VarBound(p, 0, 0)))
;; Starting: Argument 0 of Applic statement #55
;; Starting: BoxGet of VarBound(p, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(p, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=p, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=p, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(p, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(p, 0, 0)

;; Finished: Argument 0 of Applic statement #55

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #55)
;; Starting: BoxGet of VarParam(cons-list, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(cons-list, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=cons-list, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=cons-list, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(cons-list, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(cons-list, 0)

;; Finished: Evaluating proc to apply (in Applic #55)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic55
int 3
ContinueApplic55:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #55
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#55 of: (BoxGet(VarParam(cons-list, 0)) BoxGet(VarBound(p, 0, 0)))

;; Finished: Item 2 in Seq statement #45

;; Finished: Seq statement #45: (begin (set! VarParam(cons-list, 0) Box(VarParam(cons-list, 0)))  BoxSet(VarParam(cons-list, 0), (lambda (p) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0)) (BoxGet(VarBound(cons, 2, 1)) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))  (BoxGet(VarBound(cons-list, 0, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0)))))))  (BoxGet(VarParam(cons-list, 0)) BoxGet(VarBound(p, 0, 0))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont44:

;; Finished: Creating CLOSURE of LambdaSimple#44 -> (lambda (cons-list) (begin (set! VarParam(cons-list, 0) Box(VarParam(cons-list, 0)))  BoxSet(VarParam(cons-list, 0), (lambda (p) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0)) (BoxGet(VarBound(cons, 2, 1)) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))  (BoxGet(VarBound(cons-list, 0, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0)))))))  (BoxGet(VarParam(cons-list, 0)) BoxGet(VarBound(p, 0, 0)))))

;; Finished: Evaluating proc to apply (in Applic #43)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic43
int 3
ContinueApplic43:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #43
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#43 of: ((lambda (cons-list) (begin (set! VarParam(cons-list, 0) Box(VarParam(cons-list, 0)))  BoxSet(VarParam(cons-list, 0), (lambda (p) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0)) (BoxGet(VarBound(cons, 2, 1)) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))  (BoxGet(VarBound(cons-list, 0, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0)))))))  (BoxGet(VarParam(cons-list, 0)) BoxGet(VarBound(p, 0, 0))))) whatever)

;; Finished: Item 1 in Seq statement #42

;; Finished: Seq statement #42: (begin (set! VarParam(p, 0) Box(VarParam(p, 0)))  ((lambda (cons-list) (begin (set! VarParam(cons-list, 0) Box(VarParam(cons-list, 0)))  BoxSet(VarParam(cons-list, 0), (lambda (p) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0)) (BoxGet(VarBound(cons, 2, 1)) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))  (BoxGet(VarBound(cons-list, 0, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0)))))))  (BoxGet(VarParam(cons-list, 0)) BoxGet(VarBound(p, 0, 0))))) whatever))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont41:

;; Finished: Creating CLOSURE of LambdaSimple#41 -> (lambda (p) (begin (set! VarParam(p, 0) Box(VarParam(p, 0)))  ((lambda (cons-list) (begin (set! VarParam(cons-list, 0) Box(VarParam(cons-list, 0)))  BoxSet(VarParam(cons-list, 0), (lambda (p) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0)) (BoxGet(VarBound(cons, 2, 1)) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))  (BoxGet(VarBound(cons-list, 0, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0)))))))  (BoxGet(VarParam(cons-list, 0)) BoxGet(VarBound(p, 0, 0))))) whatever)))

;; Finished: Item 4 in Seq statement #40

;; Finished: Seq statement #40: (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(cons, 1) Box(VarParam(cons, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  (lambda (p) (begin (set! VarParam(p, 0) Box(VarParam(p, 0)))  ((lambda (cons-list) (begin (set! VarParam(cons-list, 0) Box(VarParam(cons-list, 0)))  BoxSet(VarParam(cons-list, 0), (lambda (p) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0)) (BoxGet(VarBound(cons, 2, 1)) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))  (BoxGet(VarBound(cons-list, 0, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0)))))))  (BoxGet(VarParam(cons-list, 0)) BoxGet(VarBound(p, 0, 0))))) whatever))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont39:

;; Finished: Creating CLOSURE of LambdaSimple#39 -> (lambda (null? cons car cdr) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(cons, 1) Box(VarParam(cons, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  (lambda (p) (begin (set! VarParam(p, 0) Box(VarParam(p, 0)))  ((lambda (cons-list) (begin (set! VarParam(cons-list, 0) Box(VarParam(cons-list, 0)))  BoxSet(VarParam(cons-list, 0), (lambda (p) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0)) (BoxGet(VarBound(cons, 2, 1)) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))  (BoxGet(VarBound(cons-list, 0, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0)))))))  (BoxGet(VarParam(cons-list, 0)) BoxGet(VarBound(p, 0, 0))))) whatever)))))

;; Finished: Evaluating proc to apply (in Applic #38)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic38
int 3
ContinueApplic38:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #38
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#38 of: ((lambda (null? cons car cdr) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(cons, 1) Box(VarParam(cons, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  (lambda (p) (begin (set! VarParam(p, 0) Box(VarParam(p, 0)))  ((lambda (cons-list) (begin (set! VarParam(cons-list, 0) Box(VarParam(cons-list, 0)))  BoxSet(VarParam(cons-list, 0), (lambda (p) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0)) (BoxGet(VarBound(cons, 2, 1)) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))  (BoxGet(VarBound(cons-list, 0, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0)))))))  (BoxGet(VarParam(cons-list, 0)) BoxGet(VarBound(p, 0, 0))))) whatever))))) VarFree(null?)  VarFree(cons)  VarFree(car)  VarFree(cdr))

mov qword [fvar_tbl+8*9], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar cons* to ((lambda (null? cons car cdr) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(cons, 1) Box(VarParam(cons, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  (lambda (p) (begin (set! VarParam(p, 0) Box(VarParam(p, 0)))  ((lambda (cons-list) (begin (set! VarParam(cons-list, 0) Box(VarParam(cons-list, 0)))  BoxSet(VarParam(cons-list, 0), (lambda (p) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0)) (BoxGet(VarBound(cons, 2, 1)) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))  (BoxGet(VarBound(cons-list, 0, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0)))))))  (BoxGet(VarParam(cons-list, 0)) BoxGet(VarBound(p, 0, 0))))) whatever))))) VarFree(null?)  VarFree(cons)  VarFree(car)  VarFree(cdr))

	call write_sob_if_not_void

;; Starting: Set fvar append to ((lambda (null? fold-right cons) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(fold-right, 1) Box(VarParam(fold-right, 1)))  (set! VarParam(cons, 2) Box(VarParam(cons, 2)))  (lambda (args) (begin (set! VarParam(args, 0) Box(VarParam(args, 0)))  (BoxGet(VarBound(fold-right, 0, 1)) (lambda (e a) (begin (set! VarParam(e, 0) Box(VarParam(e, 0)))  (set! VarParam(a, 1) Box(VarParam(a, 1)))  (if (BoxGet(VarBound(null?, 1, 0)) BoxGet(VarParam(a, 1))) BoxGet(VarParam(e, 0)) (BoxGet(VarBound(fold-right, 1, 1)) BoxGet(VarBound(cons, 1, 2))  BoxGet(VarParam(a, 1))  BoxGet(VarParam(e, 0))))))  ()  BoxGet(VarParam(args, 0))))))) VarFree(null?)  VarFree(fold-right)  VarFree(cons))
;; Starting: Perform Applic#56 of: ((lambda (null? fold-right cons) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(fold-right, 1) Box(VarParam(fold-right, 1)))  (set! VarParam(cons, 2) Box(VarParam(cons, 2)))  (lambda (args) (begin (set! VarParam(args, 0) Box(VarParam(args, 0)))  (BoxGet(VarBound(fold-right, 0, 1)) (lambda (e a) (begin (set! VarParam(e, 0) Box(VarParam(e, 0)))  (set! VarParam(a, 1) Box(VarParam(a, 1)))  (if (BoxGet(VarBound(null?, 1, 0)) BoxGet(VarParam(a, 1))) BoxGet(VarParam(e, 0)) (BoxGet(VarBound(fold-right, 1, 1)) BoxGet(VarBound(cons, 1, 2))  BoxGet(VarParam(a, 1))  BoxGet(VarParam(e, 0))))))  ()  BoxGet(VarParam(args, 0))))))) VarFree(null?)  VarFree(fold-right)  VarFree(cons))
;; Starting: Argument 2 of Applic statement #56
mov rax, qword [fvar_tbl+8*4]	; mov fvar cons to rax
;; Finished: Argument 2 of Applic statement #56

push rax ; Push argument to stack;; Starting: Argument 1 of Applic statement #56
mov rax, qword [fvar_tbl+8*7]	; mov fvar fold-right to rax
;; Finished: Argument 1 of Applic statement #56

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #56
mov rax, qword [fvar_tbl+8*1]	; mov fvar null? to rax
;; Finished: Argument 0 of Applic statement #56

push rax ; Push argument to stack
push qword 3 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #56)
;; Starting: Creating CLOSURE of LambdaSimple#57 -> (lambda (null? fold-right cons) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(fold-right, 1) Box(VarParam(fold-right, 1)))  (set! VarParam(cons, 2) Box(VarParam(cons, 2)))  (lambda (args) (begin (set! VarParam(args, 0) Box(VarParam(args, 0)))  (BoxGet(VarBound(fold-right, 0, 1)) (lambda (e a) (begin (set! VarParam(e, 0) Box(VarParam(e, 0)))  (set! VarParam(a, 1) Box(VarParam(a, 1)))  (if (BoxGet(VarBound(null?, 1, 0)) BoxGet(VarParam(a, 1))) BoxGet(VarParam(e, 0)) (BoxGet(VarBound(fold-right, 1, 1)) BoxGet(VarBound(cons, 1, 2))  BoxGet(VarParam(a, 1))  BoxGet(VarParam(e, 0))))))  ()  BoxGet(VarParam(args, 0)))))))
push rbx
; Env Extend Code Section For Closure#57
mov rbx, 0 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend57
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End57

LClosureEnvExtend57:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, -1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 0
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop57:
  jz LClosureEnvExtend_LoopEnd57
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop57

LClosureEnvExtend_LoopEnd57:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd57
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop57:
  jz LClosureEnvExtend_ParamsLoopEnd57

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop57

LClosureEnvExtend_ParamsLoopEnd57:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End57:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode57)
pop rbx
jmp LClosureCont57
LClosureCode57:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #58: (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(fold-right, 1) Box(VarParam(fold-right, 1)))  (set! VarParam(cons, 2) Box(VarParam(cons, 2)))  (lambda (args) (begin (set! VarParam(args, 0) Box(VarParam(args, 0)))  (BoxGet(VarBound(fold-right, 0, 1)) (lambda (e a) (begin (set! VarParam(e, 0) Box(VarParam(e, 0)))  (set! VarParam(a, 1) Box(VarParam(a, 1)))  (if (BoxGet(VarBound(null?, 1, 0)) BoxGet(VarParam(a, 1))) BoxGet(VarParam(e, 0)) (BoxGet(VarBound(fold-right, 1, 1)) BoxGet(VarBound(cons, 1, 2))  BoxGet(VarParam(a, 1))  BoxGet(VarParam(e, 0))))))  ()  BoxGet(VarParam(args, 0))))))
;; Starting: Item 0 in Seq statement #58
;; Starting: Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(null?, 0)
;; Starting: Get VarParam(name=null?, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=null?, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(null?, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0))

;; Finished: Item 0 in Seq statement #58


;; Starting: Item 1 in Seq statement #58
;; Starting: Set VarParam(name=fold-right, minor=1) with Box(VarParam(fold-right, 1))
;; Starting: Evaluating rhs for [ Set VarParam(name=fold-right, minor=1) with Box(VarParam(fold-right, 1)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(fold-right, 1)
;; Starting: Get VarParam(name=fold-right, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=fold-right, minor=1)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(fold-right, 1)

;; Finished: Evaluating rhs for [ Set VarParam(name=fold-right, minor=1) with Box(VarParam(fold-right, 1)) ], value is expected in rax

mov PVAR(1), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=fold-right, minor=1) with Box(VarParam(fold-right, 1))

;; Finished: Item 1 in Seq statement #58


;; Starting: Item 2 in Seq statement #58
;; Starting: Set VarParam(name=cons, minor=2) with Box(VarParam(cons, 2))
;; Starting: Evaluating rhs for [ Set VarParam(name=cons, minor=2) with Box(VarParam(cons, 2)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(cons, 2)
;; Starting: Get VarParam(name=cons, minor=2)
mov rax, PVAR(2)
;; Finished: Get VarParam(name=cons, minor=2)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(cons, 2)

;; Finished: Evaluating rhs for [ Set VarParam(name=cons, minor=2) with Box(VarParam(cons, 2)) ], value is expected in rax

mov PVAR(2), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=cons, minor=2) with Box(VarParam(cons, 2))

;; Finished: Item 2 in Seq statement #58


;; Starting: Item 3 in Seq statement #58
;; Starting: Creating CLOSURE of LambdaSimple#59 -> (lambda (args) (begin (set! VarParam(args, 0) Box(VarParam(args, 0)))  (BoxGet(VarBound(fold-right, 0, 1)) (lambda (e a) (begin (set! VarParam(e, 0) Box(VarParam(e, 0)))  (set! VarParam(a, 1) Box(VarParam(a, 1)))  (if (BoxGet(VarBound(null?, 1, 0)) BoxGet(VarParam(a, 1))) BoxGet(VarParam(e, 0)) (BoxGet(VarBound(fold-right, 1, 1)) BoxGet(VarBound(cons, 1, 2))  BoxGet(VarParam(a, 1))  BoxGet(VarParam(e, 0))))))  ()  BoxGet(VarParam(args, 0)))))
push rbx
; Env Extend Code Section For Closure#59
mov rbx, 1 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend59
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End59

LClosureEnvExtend59:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 0
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 8
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop59:
  jz LClosureEnvExtend_LoopEnd59
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop59

LClosureEnvExtend_LoopEnd59:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd59
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop59:
  jz LClosureEnvExtend_ParamsLoopEnd59

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop59

LClosureEnvExtend_ParamsLoopEnd59:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End59:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode59)
pop rbx
jmp LClosureCont59
LClosureCode59:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #60: (begin (set! VarParam(args, 0) Box(VarParam(args, 0)))  (BoxGet(VarBound(fold-right, 0, 1)) (lambda (e a) (begin (set! VarParam(e, 0) Box(VarParam(e, 0)))  (set! VarParam(a, 1) Box(VarParam(a, 1)))  (if (BoxGet(VarBound(null?, 1, 0)) BoxGet(VarParam(a, 1))) BoxGet(VarParam(e, 0)) (BoxGet(VarBound(fold-right, 1, 1)) BoxGet(VarBound(cons, 1, 2))  BoxGet(VarParam(a, 1))  BoxGet(VarParam(e, 0))))))  ()  BoxGet(VarParam(args, 0))))
;; Starting: Item 0 in Seq statement #60
;; Starting: Set VarParam(name=args, minor=0) with Box(VarParam(args, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=args, minor=0) with Box(VarParam(args, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(args, 0)
;; Starting: Get VarParam(name=args, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=args, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(args, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=args, minor=0) with Box(VarParam(args, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=args, minor=0) with Box(VarParam(args, 0))

;; Finished: Item 0 in Seq statement #60


;; Starting: Item 1 in Seq statement #60
;; Starting: Perform Applic#61 of: (BoxGet(VarBound(fold-right, 0, 1)) (lambda (e a) (begin (set! VarParam(e, 0) Box(VarParam(e, 0)))  (set! VarParam(a, 1) Box(VarParam(a, 1)))  (if (BoxGet(VarBound(null?, 1, 0)) BoxGet(VarParam(a, 1))) BoxGet(VarParam(e, 0)) (BoxGet(VarBound(fold-right, 1, 1)) BoxGet(VarBound(cons, 1, 2))  BoxGet(VarParam(a, 1))  BoxGet(VarParam(e, 0))))))  ()  BoxGet(VarParam(args, 0)))
;; Starting: Argument 2 of Applic statement #61
;; Starting: BoxGet of VarParam(args, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(args, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=args, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=args, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(args, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(args, 0)

;; Finished: Argument 2 of Applic statement #61

push rax ; Push argument to stack;; Starting: Argument 1 of Applic statement #61
mov rax, const_tbl+1	; mov const () to rax
;; Finished: Argument 1 of Applic statement #61

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #61
;; Starting: Creating CLOSURE of LambdaSimple#62 -> (lambda (e a) (begin (set! VarParam(e, 0) Box(VarParam(e, 0)))  (set! VarParam(a, 1) Box(VarParam(a, 1)))  (if (BoxGet(VarBound(null?, 1, 0)) BoxGet(VarParam(a, 1))) BoxGet(VarParam(e, 0)) (BoxGet(VarBound(fold-right, 1, 1)) BoxGet(VarBound(cons, 1, 2))  BoxGet(VarParam(a, 1))  BoxGet(VarParam(e, 0))))))
push rbx
; Env Extend Code Section For Closure#62
mov rbx, 2 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend62
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End62

LClosureEnvExtend62:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 16
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop62:
  jz LClosureEnvExtend_LoopEnd62
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop62

LClosureEnvExtend_LoopEnd62:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd62
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop62:
  jz LClosureEnvExtend_ParamsLoopEnd62

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop62

LClosureEnvExtend_ParamsLoopEnd62:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End62:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode62)
pop rbx
jmp LClosureCont62
LClosureCode62:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #63: (begin (set! VarParam(e, 0) Box(VarParam(e, 0)))  (set! VarParam(a, 1) Box(VarParam(a, 1)))  (if (BoxGet(VarBound(null?, 1, 0)) BoxGet(VarParam(a, 1))) BoxGet(VarParam(e, 0)) (BoxGet(VarBound(fold-right, 1, 1)) BoxGet(VarBound(cons, 1, 2))  BoxGet(VarParam(a, 1))  BoxGet(VarParam(e, 0)))))
;; Starting: Item 0 in Seq statement #63
;; Starting: Set VarParam(name=e, minor=0) with Box(VarParam(e, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=e, minor=0) with Box(VarParam(e, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(e, 0)
;; Starting: Get VarParam(name=e, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=e, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(e, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=e, minor=0) with Box(VarParam(e, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=e, minor=0) with Box(VarParam(e, 0))

;; Finished: Item 0 in Seq statement #63


;; Starting: Item 1 in Seq statement #63
;; Starting: Set VarParam(name=a, minor=1) with Box(VarParam(a, 1))
;; Starting: Evaluating rhs for [ Set VarParam(name=a, minor=1) with Box(VarParam(a, 1)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(a, 1)
;; Starting: Get VarParam(name=a, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=a, minor=1)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(a, 1)

;; Finished: Evaluating rhs for [ Set VarParam(name=a, minor=1) with Box(VarParam(a, 1)) ], value is expected in rax

mov PVAR(1), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=a, minor=1) with Box(VarParam(a, 1))

;; Finished: Item 1 in Seq statement #63


;; Starting: Item 2 in Seq statement #63
;; Starting: If statement (#64): (if (BoxGet(VarBound(null?, 1, 0)) BoxGet(VarParam(a, 1))) BoxGet(VarParam(e, 0)) (BoxGet(VarBound(fold-right, 1, 1)) BoxGet(VarBound(cons, 1, 2))  BoxGet(VarParam(a, 1))  BoxGet(VarParam(e, 0))))
Lif64:
;; Starting: Perform Applic#65 of: (BoxGet(VarBound(null?, 1, 0)) BoxGet(VarParam(a, 1)))
;; Starting: Argument 0 of Applic statement #65
;; Starting: BoxGet of VarParam(a, 1)
;; Starting: Evaluating val for [ BoxGet of VarParam(a, 1) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=a, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=a, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarParam(a, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(a, 1)

;; Finished: Argument 0 of Applic statement #65

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #65)
;; Starting: BoxGet of VarBound(null?, 1, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(null?, 1, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=null?, major=1, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=null?, major=1, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(null?, 1, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(null?, 1, 0)

;; Finished: Evaluating proc to apply (in Applic #65)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic65
int 3
ContinueApplic65:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #65
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#65 of: (BoxGet(VarBound(null?, 1, 0)) BoxGet(VarParam(a, 1)))

cmp rax, SOB_FALSE_ADDRESS
je Lelse64
;; Starting: BoxGet of VarParam(e, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(e, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=e, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=e, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(e, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(e, 0)

jmp LendIf64
Lelse64:
;; Starting: Perform Applic#66 of: (BoxGet(VarBound(fold-right, 1, 1)) BoxGet(VarBound(cons, 1, 2))  BoxGet(VarParam(a, 1))  BoxGet(VarParam(e, 0)))
;; Starting: Argument 2 of Applic statement #66
;; Starting: BoxGet of VarParam(e, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(e, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=e, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=e, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(e, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(e, 0)

;; Finished: Argument 2 of Applic statement #66

push rax ; Push argument to stack;; Starting: Argument 1 of Applic statement #66
;; Starting: BoxGet of VarParam(a, 1)
;; Starting: Evaluating val for [ BoxGet of VarParam(a, 1) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=a, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=a, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarParam(a, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(a, 1)

;; Finished: Argument 1 of Applic statement #66

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #66
;; Starting: BoxGet of VarBound(cons, 1, 2)
;; Starting: Evaluating val for [ BoxGet of VarBound(cons, 1, 2) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=cons, major=1, minor=2)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]
;; Finished: Get VarBound(name=cons, major=1, minor=2)

;; Finished: Evaluating val for [ BoxGet of VarBound(cons, 1, 2) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(cons, 1, 2)

;; Finished: Argument 0 of Applic statement #66

push rax ; Push argument to stack
push qword 3 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #66)
;; Starting: BoxGet of VarBound(fold-right, 1, 1)
;; Starting: Evaluating val for [ BoxGet of VarBound(fold-right, 1, 1) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=fold-right, major=1, minor=1)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
;; Finished: Get VarBound(name=fold-right, major=1, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarBound(fold-right, 1, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(fold-right, 1, 1)

;; Finished: Evaluating proc to apply (in Applic #66)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic66
int 3
ContinueApplic66:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #66
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#66 of: (BoxGet(VarBound(fold-right, 1, 1)) BoxGet(VarBound(cons, 1, 2))  BoxGet(VarParam(a, 1))  BoxGet(VarParam(e, 0)))

LendIf64:
;; Finished: If statement (#64): (if (BoxGet(VarBound(null?, 1, 0)) BoxGet(VarParam(a, 1))) BoxGet(VarParam(e, 0)) (BoxGet(VarBound(fold-right, 1, 1)) BoxGet(VarBound(cons, 1, 2))  BoxGet(VarParam(a, 1))  BoxGet(VarParam(e, 0))))

;; Finished: Item 2 in Seq statement #63

;; Finished: Seq statement #63: (begin (set! VarParam(e, 0) Box(VarParam(e, 0)))  (set! VarParam(a, 1) Box(VarParam(a, 1)))  (if (BoxGet(VarBound(null?, 1, 0)) BoxGet(VarParam(a, 1))) BoxGet(VarParam(e, 0)) (BoxGet(VarBound(fold-right, 1, 1)) BoxGet(VarBound(cons, 1, 2))  BoxGet(VarParam(a, 1))  BoxGet(VarParam(e, 0)))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont62:

;; Finished: Creating CLOSURE of LambdaSimple#62 -> (lambda (e a) (begin (set! VarParam(e, 0) Box(VarParam(e, 0)))  (set! VarParam(a, 1) Box(VarParam(a, 1)))  (if (BoxGet(VarBound(null?, 1, 0)) BoxGet(VarParam(a, 1))) BoxGet(VarParam(e, 0)) (BoxGet(VarBound(fold-right, 1, 1)) BoxGet(VarBound(cons, 1, 2))  BoxGet(VarParam(a, 1))  BoxGet(VarParam(e, 0))))))

;; Finished: Argument 0 of Applic statement #61

push rax ; Push argument to stack
push qword 3 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #61)
;; Starting: BoxGet of VarBound(fold-right, 0, 1)
;; Starting: Evaluating val for [ BoxGet of VarBound(fold-right, 0, 1) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=fold-right, major=0, minor=1)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]
;; Finished: Get VarBound(name=fold-right, major=0, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarBound(fold-right, 0, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(fold-right, 0, 1)

;; Finished: Evaluating proc to apply (in Applic #61)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic61
int 3
ContinueApplic61:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #61
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#61 of: (BoxGet(VarBound(fold-right, 0, 1)) (lambda (e a) (begin (set! VarParam(e, 0) Box(VarParam(e, 0)))  (set! VarParam(a, 1) Box(VarParam(a, 1)))  (if (BoxGet(VarBound(null?, 1, 0)) BoxGet(VarParam(a, 1))) BoxGet(VarParam(e, 0)) (BoxGet(VarBound(fold-right, 1, 1)) BoxGet(VarBound(cons, 1, 2))  BoxGet(VarParam(a, 1))  BoxGet(VarParam(e, 0))))))  ()  BoxGet(VarParam(args, 0)))

;; Finished: Item 1 in Seq statement #60

;; Finished: Seq statement #60: (begin (set! VarParam(args, 0) Box(VarParam(args, 0)))  (BoxGet(VarBound(fold-right, 0, 1)) (lambda (e a) (begin (set! VarParam(e, 0) Box(VarParam(e, 0)))  (set! VarParam(a, 1) Box(VarParam(a, 1)))  (if (BoxGet(VarBound(null?, 1, 0)) BoxGet(VarParam(a, 1))) BoxGet(VarParam(e, 0)) (BoxGet(VarBound(fold-right, 1, 1)) BoxGet(VarBound(cons, 1, 2))  BoxGet(VarParam(a, 1))  BoxGet(VarParam(e, 0))))))  ()  BoxGet(VarParam(args, 0))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont59:

;; Finished: Creating CLOSURE of LambdaSimple#59 -> (lambda (args) (begin (set! VarParam(args, 0) Box(VarParam(args, 0)))  (BoxGet(VarBound(fold-right, 0, 1)) (lambda (e a) (begin (set! VarParam(e, 0) Box(VarParam(e, 0)))  (set! VarParam(a, 1) Box(VarParam(a, 1)))  (if (BoxGet(VarBound(null?, 1, 0)) BoxGet(VarParam(a, 1))) BoxGet(VarParam(e, 0)) (BoxGet(VarBound(fold-right, 1, 1)) BoxGet(VarBound(cons, 1, 2))  BoxGet(VarParam(a, 1))  BoxGet(VarParam(e, 0))))))  ()  BoxGet(VarParam(args, 0)))))

;; Finished: Item 3 in Seq statement #58

;; Finished: Seq statement #58: (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(fold-right, 1) Box(VarParam(fold-right, 1)))  (set! VarParam(cons, 2) Box(VarParam(cons, 2)))  (lambda (args) (begin (set! VarParam(args, 0) Box(VarParam(args, 0)))  (BoxGet(VarBound(fold-right, 0, 1)) (lambda (e a) (begin (set! VarParam(e, 0) Box(VarParam(e, 0)))  (set! VarParam(a, 1) Box(VarParam(a, 1)))  (if (BoxGet(VarBound(null?, 1, 0)) BoxGet(VarParam(a, 1))) BoxGet(VarParam(e, 0)) (BoxGet(VarBound(fold-right, 1, 1)) BoxGet(VarBound(cons, 1, 2))  BoxGet(VarParam(a, 1))  BoxGet(VarParam(e, 0))))))  ()  BoxGet(VarParam(args, 0))))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont57:

;; Finished: Creating CLOSURE of LambdaSimple#57 -> (lambda (null? fold-right cons) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(fold-right, 1) Box(VarParam(fold-right, 1)))  (set! VarParam(cons, 2) Box(VarParam(cons, 2)))  (lambda (args) (begin (set! VarParam(args, 0) Box(VarParam(args, 0)))  (BoxGet(VarBound(fold-right, 0, 1)) (lambda (e a) (begin (set! VarParam(e, 0) Box(VarParam(e, 0)))  (set! VarParam(a, 1) Box(VarParam(a, 1)))  (if (BoxGet(VarBound(null?, 1, 0)) BoxGet(VarParam(a, 1))) BoxGet(VarParam(e, 0)) (BoxGet(VarBound(fold-right, 1, 1)) BoxGet(VarBound(cons, 1, 2))  BoxGet(VarParam(a, 1))  BoxGet(VarParam(e, 0))))))  ()  BoxGet(VarParam(args, 0)))))))

;; Finished: Evaluating proc to apply (in Applic #56)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic56
int 3
ContinueApplic56:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #56
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#56 of: ((lambda (null? fold-right cons) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(fold-right, 1) Box(VarParam(fold-right, 1)))  (set! VarParam(cons, 2) Box(VarParam(cons, 2)))  (lambda (args) (begin (set! VarParam(args, 0) Box(VarParam(args, 0)))  (BoxGet(VarBound(fold-right, 0, 1)) (lambda (e a) (begin (set! VarParam(e, 0) Box(VarParam(e, 0)))  (set! VarParam(a, 1) Box(VarParam(a, 1)))  (if (BoxGet(VarBound(null?, 1, 0)) BoxGet(VarParam(a, 1))) BoxGet(VarParam(e, 0)) (BoxGet(VarBound(fold-right, 1, 1)) BoxGet(VarBound(cons, 1, 2))  BoxGet(VarParam(a, 1))  BoxGet(VarParam(e, 0))))))  ()  BoxGet(VarParam(args, 0))))))) VarFree(null?)  VarFree(fold-right)  VarFree(cons))

mov qword [fvar_tbl+8*8], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar append to ((lambda (null? fold-right cons) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(fold-right, 1) Box(VarParam(fold-right, 1)))  (set! VarParam(cons, 2) Box(VarParam(cons, 2)))  (lambda (args) (begin (set! VarParam(args, 0) Box(VarParam(args, 0)))  (BoxGet(VarBound(fold-right, 0, 1)) (lambda (e a) (begin (set! VarParam(e, 0) Box(VarParam(e, 0)))  (set! VarParam(a, 1) Box(VarParam(a, 1)))  (if (BoxGet(VarBound(null?, 1, 0)) BoxGet(VarParam(a, 1))) BoxGet(VarParam(e, 0)) (BoxGet(VarBound(fold-right, 1, 1)) BoxGet(VarBound(cons, 1, 2))  BoxGet(VarParam(a, 1))  BoxGet(VarParam(e, 0))))))  ()  BoxGet(VarParam(args, 0))))))) VarFree(null?)  VarFree(fold-right)  VarFree(cons))

	call write_sob_if_not_void

;; Starting: Set fvar list to (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  BoxGet(VarParam(x, 0))))
;; Starting: Creating CLOSURE of LambdaSimple#67 -> (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  BoxGet(VarParam(x, 0))))
push rbx
; Env Extend Code Section For Closure#67
mov rbx, 0 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend67
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End67

LClosureEnvExtend67:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, -1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 0
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop67:
  jz LClosureEnvExtend_LoopEnd67
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop67

LClosureEnvExtend_LoopEnd67:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd67
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop67:
  jz LClosureEnvExtend_ParamsLoopEnd67

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop67

LClosureEnvExtend_ParamsLoopEnd67:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End67:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode67)
pop rbx
jmp LClosureCont67
LClosureCode67:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #68: (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  BoxGet(VarParam(x, 0)))
;; Starting: Item 0 in Seq statement #68
;; Starting: Set VarParam(name=x, minor=0) with Box(VarParam(x, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=x, minor=0) with Box(VarParam(x, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(x, 0)
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(x, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=x, minor=0) with Box(VarParam(x, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=x, minor=0) with Box(VarParam(x, 0))

;; Finished: Item 0 in Seq statement #68


;; Starting: Item 1 in Seq statement #68
;; Starting: BoxGet of VarParam(x, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(x, 0)

;; Finished: Item 1 in Seq statement #68

;; Finished: Seq statement #68: (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  BoxGet(VarParam(x, 0)))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont67:

;; Finished: Creating CLOSURE of LambdaSimple#67 -> (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  BoxGet(VarParam(x, 0))))

mov qword [fvar_tbl+8*10], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar list to (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  BoxGet(VarParam(x, 0))))

	call write_sob_if_not_void

;; Starting: Set fvar list? to ((lambda (null? pair? cdr) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(pair?, 1) Box(VarParam(pair?, 1)))  (set! VarParam(cdr, 2) Box(VarParam(cdr, 2)))  ((lambda (list?-loop) (begin (set! VarParam(list?-loop, 0) Box(VarParam(list?-loop, 0)))  BoxSet(VarParam(list?-loop, 0), (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f))))  BoxGet(VarParam(list?-loop, 0)))) whatever))) VarFree(null?)  VarFree(pair?)  VarFree(cdr))
;; Starting: Perform Applic#69 of: ((lambda (null? pair? cdr) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(pair?, 1) Box(VarParam(pair?, 1)))  (set! VarParam(cdr, 2) Box(VarParam(cdr, 2)))  ((lambda (list?-loop) (begin (set! VarParam(list?-loop, 0) Box(VarParam(list?-loop, 0)))  BoxSet(VarParam(list?-loop, 0), (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f))))  BoxGet(VarParam(list?-loop, 0)))) whatever))) VarFree(null?)  VarFree(pair?)  VarFree(cdr))
;; Starting: Argument 2 of Applic statement #69
mov rax, qword [fvar_tbl+8*3]	; mov fvar cdr to rax
;; Finished: Argument 2 of Applic statement #69

push rax ; Push argument to stack;; Starting: Argument 1 of Applic statement #69
mov rax, qword [fvar_tbl+8*12]	; mov fvar pair? to rax
;; Finished: Argument 1 of Applic statement #69

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #69
mov rax, qword [fvar_tbl+8*1]	; mov fvar null? to rax
;; Finished: Argument 0 of Applic statement #69

push rax ; Push argument to stack
push qword 3 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #69)
;; Starting: Creating CLOSURE of LambdaSimple#70 -> (lambda (null? pair? cdr) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(pair?, 1) Box(VarParam(pair?, 1)))  (set! VarParam(cdr, 2) Box(VarParam(cdr, 2)))  ((lambda (list?-loop) (begin (set! VarParam(list?-loop, 0) Box(VarParam(list?-loop, 0)))  BoxSet(VarParam(list?-loop, 0), (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f))))  BoxGet(VarParam(list?-loop, 0)))) whatever)))
push rbx
; Env Extend Code Section For Closure#70
mov rbx, 0 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend70
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End70

LClosureEnvExtend70:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, -1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 0
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop70:
  jz LClosureEnvExtend_LoopEnd70
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop70

LClosureEnvExtend_LoopEnd70:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd70
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop70:
  jz LClosureEnvExtend_ParamsLoopEnd70

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop70

LClosureEnvExtend_ParamsLoopEnd70:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End70:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode70)
pop rbx
jmp LClosureCont70
LClosureCode70:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #71: (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(pair?, 1) Box(VarParam(pair?, 1)))  (set! VarParam(cdr, 2) Box(VarParam(cdr, 2)))  ((lambda (list?-loop) (begin (set! VarParam(list?-loop, 0) Box(VarParam(list?-loop, 0)))  BoxSet(VarParam(list?-loop, 0), (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f))))  BoxGet(VarParam(list?-loop, 0)))) whatever))
;; Starting: Item 0 in Seq statement #71
;; Starting: Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(null?, 0)
;; Starting: Get VarParam(name=null?, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=null?, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(null?, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0))

;; Finished: Item 0 in Seq statement #71


;; Starting: Item 1 in Seq statement #71
;; Starting: Set VarParam(name=pair?, minor=1) with Box(VarParam(pair?, 1))
;; Starting: Evaluating rhs for [ Set VarParam(name=pair?, minor=1) with Box(VarParam(pair?, 1)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(pair?, 1)
;; Starting: Get VarParam(name=pair?, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=pair?, minor=1)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(pair?, 1)

;; Finished: Evaluating rhs for [ Set VarParam(name=pair?, minor=1) with Box(VarParam(pair?, 1)) ], value is expected in rax

mov PVAR(1), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=pair?, minor=1) with Box(VarParam(pair?, 1))

;; Finished: Item 1 in Seq statement #71


;; Starting: Item 2 in Seq statement #71
;; Starting: Set VarParam(name=cdr, minor=2) with Box(VarParam(cdr, 2))
;; Starting: Evaluating rhs for [ Set VarParam(name=cdr, minor=2) with Box(VarParam(cdr, 2)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(cdr, 2)
;; Starting: Get VarParam(name=cdr, minor=2)
mov rax, PVAR(2)
;; Finished: Get VarParam(name=cdr, minor=2)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(cdr, 2)

;; Finished: Evaluating rhs for [ Set VarParam(name=cdr, minor=2) with Box(VarParam(cdr, 2)) ], value is expected in rax

mov PVAR(2), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=cdr, minor=2) with Box(VarParam(cdr, 2))

;; Finished: Item 2 in Seq statement #71


;; Starting: Item 3 in Seq statement #71
;; Starting: Perform Applic#72 of: ((lambda (list?-loop) (begin (set! VarParam(list?-loop, 0) Box(VarParam(list?-loop, 0)))  BoxSet(VarParam(list?-loop, 0), (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f))))  BoxGet(VarParam(list?-loop, 0)))) whatever)
;; Starting: Argument 0 of Applic statement #72
mov rax, const_tbl+23	; mov const whatever to rax
;; Finished: Argument 0 of Applic statement #72

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #72)
;; Starting: Creating CLOSURE of LambdaSimple#73 -> (lambda (list?-loop) (begin (set! VarParam(list?-loop, 0) Box(VarParam(list?-loop, 0)))  BoxSet(VarParam(list?-loop, 0), (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f))))  BoxGet(VarParam(list?-loop, 0))))
push rbx
; Env Extend Code Section For Closure#73
mov rbx, 1 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend73
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End73

LClosureEnvExtend73:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 0
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 8
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop73:
  jz LClosureEnvExtend_LoopEnd73
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop73

LClosureEnvExtend_LoopEnd73:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd73
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop73:
  jz LClosureEnvExtend_ParamsLoopEnd73

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop73

LClosureEnvExtend_ParamsLoopEnd73:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End73:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode73)
pop rbx
jmp LClosureCont73
LClosureCode73:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #74: (begin (set! VarParam(list?-loop, 0) Box(VarParam(list?-loop, 0)))  BoxSet(VarParam(list?-loop, 0), (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f))))  BoxGet(VarParam(list?-loop, 0)))
;; Starting: Item 0 in Seq statement #74
;; Starting: Set VarParam(name=list?-loop, minor=0) with Box(VarParam(list?-loop, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=list?-loop, minor=0) with Box(VarParam(list?-loop, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(list?-loop, 0)
;; Starting: Get VarParam(name=list?-loop, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=list?-loop, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(list?-loop, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=list?-loop, minor=0) with Box(VarParam(list?-loop, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=list?-loop, minor=0) with Box(VarParam(list?-loop, 0))

;; Finished: Item 0 in Seq statement #74


;; Starting: Item 1 in Seq statement #74
;; Starting: BoxSet of VarParam(list?-loop, 0) with (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f)))
;; Starting: Evaluating rhs for [ BoxSet of VarParam(list?-loop, 0) with (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f))) ], the VALUE is expected in rax
;; Starting: Creating CLOSURE of LambdaSimple#75 -> (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f)))
push rbx
; Env Extend Code Section For Closure#75
mov rbx, 2 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend75
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End75

LClosureEnvExtend75:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 16
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop75:
  jz LClosureEnvExtend_LoopEnd75
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop75

LClosureEnvExtend_LoopEnd75:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd75
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop75:
  jz LClosureEnvExtend_ParamsLoopEnd75

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop75

LClosureEnvExtend_ParamsLoopEnd75:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End75:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode75)
pop rbx
jmp LClosureCont75
LClosureCode75:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Or statement (#76): (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f))
Lor76: 
;; Starting: Item 0 in Or statement #76
;; Starting: Perform Applic#77 of: (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))
;; Starting: Argument 0 of Applic statement #77
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Argument 0 of Applic statement #77

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #77)
;; Starting: BoxGet of VarBound(null?, 1, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(null?, 1, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=null?, major=1, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=null?, major=1, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(null?, 1, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(null?, 1, 0)

;; Finished: Evaluating proc to apply (in Applic #77)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic77
int 3
ContinueApplic77:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #77
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#77 of: (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))

;; Finished: Item 0 in Or statement #76
cmp rax, SOB_FALSE_ADDRESS 
jne LendOr76;; Starting: Item 1 in Or statement #76
;; Starting: If statement (#78): (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f)
Lif78:
;; Starting: Perform Applic#79 of: (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0))
;; Starting: Argument 0 of Applic statement #79
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Argument 0 of Applic statement #79

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #79)
;; Starting: BoxGet of VarBound(pair?, 1, 1)
;; Starting: Evaluating val for [ BoxGet of VarBound(pair?, 1, 1) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=pair?, major=1, minor=1)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
;; Finished: Get VarBound(name=pair?, major=1, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarBound(pair?, 1, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(pair?, 1, 1)

;; Finished: Evaluating proc to apply (in Applic #79)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic79
int 3
ContinueApplic79:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #79
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#79 of: (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0))

cmp rax, SOB_FALSE_ADDRESS
je Lelse78
;; Starting: Perform Applic#80 of: (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0)))
;; Starting: Argument 0 of Applic statement #80
;; Starting: Perform Applic#81 of: (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))
;; Starting: Argument 0 of Applic statement #81
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Argument 0 of Applic statement #81

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #81)
;; Starting: BoxGet of VarBound(cdr, 1, 2)
;; Starting: Evaluating val for [ BoxGet of VarBound(cdr, 1, 2) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=cdr, major=1, minor=2)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]
;; Finished: Get VarBound(name=cdr, major=1, minor=2)

;; Finished: Evaluating val for [ BoxGet of VarBound(cdr, 1, 2) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(cdr, 1, 2)

;; Finished: Evaluating proc to apply (in Applic #81)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic81
int 3
ContinueApplic81:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #81
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#81 of: (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))

;; Finished: Argument 0 of Applic statement #80

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #80)
mov rax, qword [fvar_tbl+8*11]	; mov fvar list? to rax
;; Finished: Evaluating proc to apply (in Applic #80)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic80
int 3
ContinueApplic80:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #80
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#80 of: (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0)))

jmp LendIf78
Lelse78:
mov rax, const_tbl+2	; mov const #f to rax
LendIf78:
;; Finished: If statement (#78): (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f)

;; Finished: Item 1 in Or statement #76
 
LendOr76:
;; Finished: Or statement (#76): (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont75:

;; Finished: Creating CLOSURE of LambdaSimple#75 -> (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f)))

;; Finished: Evaluating rhs for [ BoxSet of VarParam(list?-loop, 0) with (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f))) ], the VALUE is expected in rax

; Save the value of rhs
push rax
;; Starting: Evaluating var for [ BoxSet of VarParam(list?-loop, 0) with (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f))) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=list?-loop, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=list?-loop, minor=0)

;; Finished: Evaluating var for [ BoxSet of VarParam(list?-loop, 0) with (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f))) ], the VALUE is expected in rax

; in RAX there is a address of a box, put the value we saved on stack earlier (from rhs) inside it
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;; Finished: BoxSet of VarParam(list?-loop, 0) with (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f)))

;; Finished: Item 1 in Seq statement #74


;; Starting: Item 2 in Seq statement #74
;; Starting: BoxGet of VarParam(list?-loop, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(list?-loop, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=list?-loop, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=list?-loop, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(list?-loop, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(list?-loop, 0)

;; Finished: Item 2 in Seq statement #74

;; Finished: Seq statement #74: (begin (set! VarParam(list?-loop, 0) Box(VarParam(list?-loop, 0)))  BoxSet(VarParam(list?-loop, 0), (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f))))  BoxGet(VarParam(list?-loop, 0)))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont73:

;; Finished: Creating CLOSURE of LambdaSimple#73 -> (lambda (list?-loop) (begin (set! VarParam(list?-loop, 0) Box(VarParam(list?-loop, 0)))  BoxSet(VarParam(list?-loop, 0), (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f))))  BoxGet(VarParam(list?-loop, 0))))

;; Finished: Evaluating proc to apply (in Applic #72)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic72
int 3
ContinueApplic72:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #72
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#72 of: ((lambda (list?-loop) (begin (set! VarParam(list?-loop, 0) Box(VarParam(list?-loop, 0)))  BoxSet(VarParam(list?-loop, 0), (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f))))  BoxGet(VarParam(list?-loop, 0)))) whatever)

;; Finished: Item 3 in Seq statement #71

;; Finished: Seq statement #71: (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(pair?, 1) Box(VarParam(pair?, 1)))  (set! VarParam(cdr, 2) Box(VarParam(cdr, 2)))  ((lambda (list?-loop) (begin (set! VarParam(list?-loop, 0) Box(VarParam(list?-loop, 0)))  BoxSet(VarParam(list?-loop, 0), (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f))))  BoxGet(VarParam(list?-loop, 0)))) whatever))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont70:

;; Finished: Creating CLOSURE of LambdaSimple#70 -> (lambda (null? pair? cdr) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(pair?, 1) Box(VarParam(pair?, 1)))  (set! VarParam(cdr, 2) Box(VarParam(cdr, 2)))  ((lambda (list?-loop) (begin (set! VarParam(list?-loop, 0) Box(VarParam(list?-loop, 0)))  BoxSet(VarParam(list?-loop, 0), (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f))))  BoxGet(VarParam(list?-loop, 0)))) whatever)))

;; Finished: Evaluating proc to apply (in Applic #69)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic69
int 3
ContinueApplic69:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #69
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#69 of: ((lambda (null? pair? cdr) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(pair?, 1) Box(VarParam(pair?, 1)))  (set! VarParam(cdr, 2) Box(VarParam(cdr, 2)))  ((lambda (list?-loop) (begin (set! VarParam(list?-loop, 0) Box(VarParam(list?-loop, 0)))  BoxSet(VarParam(list?-loop, 0), (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f))))  BoxGet(VarParam(list?-loop, 0)))) whatever))) VarFree(null?)  VarFree(pair?)  VarFree(cdr))

mov qword [fvar_tbl+8*11], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar list? to ((lambda (null? pair? cdr) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(pair?, 1) Box(VarParam(pair?, 1)))  (set! VarParam(cdr, 2) Box(VarParam(cdr, 2)))  ((lambda (list?-loop) (begin (set! VarParam(list?-loop, 0) Box(VarParam(list?-loop, 0)))  BoxSet(VarParam(list?-loop, 0), (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f))))  BoxGet(VarParam(list?-loop, 0)))) whatever))) VarFree(null?)  VarFree(pair?)  VarFree(cdr))

	call write_sob_if_not_void

;; Starting: Set fvar make-string to ((lambda (null? car make-string) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(car, 1) Box(VarParam(car, 1)))  (set! VarParam(make-string, 2) Box(VarParam(make-string, 2)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 0, 0)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(make-string, 0, 2)) BoxGet(VarParam(x, 0))  #\nul) (BoxGet(VarBound(make-string, 0, 2)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(car, 0, 1)) BoxGet(VarParam(y, 1))))))))) VarFree(null?)  VarFree(car)  VarFree(make-string))
;; Starting: Perform Applic#82 of: ((lambda (null? car make-string) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(car, 1) Box(VarParam(car, 1)))  (set! VarParam(make-string, 2) Box(VarParam(make-string, 2)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 0, 0)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(make-string, 0, 2)) BoxGet(VarParam(x, 0))  #\nul) (BoxGet(VarBound(make-string, 0, 2)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(car, 0, 1)) BoxGet(VarParam(y, 1))))))))) VarFree(null?)  VarFree(car)  VarFree(make-string))
;; Starting: Argument 2 of Applic statement #82
mov rax, qword [fvar_tbl+8*13]	; mov fvar make-string to rax
;; Finished: Argument 2 of Applic statement #82

push rax ; Push argument to stack;; Starting: Argument 1 of Applic statement #82
mov rax, qword [fvar_tbl+8*2]	; mov fvar car to rax
;; Finished: Argument 1 of Applic statement #82

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #82
mov rax, qword [fvar_tbl+8*1]	; mov fvar null? to rax
;; Finished: Argument 0 of Applic statement #82

push rax ; Push argument to stack
push qword 3 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #82)
;; Starting: Creating CLOSURE of LambdaSimple#83 -> (lambda (null? car make-string) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(car, 1) Box(VarParam(car, 1)))  (set! VarParam(make-string, 2) Box(VarParam(make-string, 2)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 0, 0)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(make-string, 0, 2)) BoxGet(VarParam(x, 0))  #\nul) (BoxGet(VarBound(make-string, 0, 2)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(car, 0, 1)) BoxGet(VarParam(y, 1)))))))))
push rbx
; Env Extend Code Section For Closure#83
mov rbx, 0 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend83
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End83

LClosureEnvExtend83:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, -1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 0
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop83:
  jz LClosureEnvExtend_LoopEnd83
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop83

LClosureEnvExtend_LoopEnd83:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd83
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop83:
  jz LClosureEnvExtend_ParamsLoopEnd83

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop83

LClosureEnvExtend_ParamsLoopEnd83:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End83:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode83)
pop rbx
jmp LClosureCont83
LClosureCode83:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #84: (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(car, 1) Box(VarParam(car, 1)))  (set! VarParam(make-string, 2) Box(VarParam(make-string, 2)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 0, 0)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(make-string, 0, 2)) BoxGet(VarParam(x, 0))  #\nul) (BoxGet(VarBound(make-string, 0, 2)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(car, 0, 1)) BoxGet(VarParam(y, 1))))))))
;; Starting: Item 0 in Seq statement #84
;; Starting: Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(null?, 0)
;; Starting: Get VarParam(name=null?, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=null?, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(null?, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0))

;; Finished: Item 0 in Seq statement #84


;; Starting: Item 1 in Seq statement #84
;; Starting: Set VarParam(name=car, minor=1) with Box(VarParam(car, 1))
;; Starting: Evaluating rhs for [ Set VarParam(name=car, minor=1) with Box(VarParam(car, 1)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(car, 1)
;; Starting: Get VarParam(name=car, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=car, minor=1)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(car, 1)

;; Finished: Evaluating rhs for [ Set VarParam(name=car, minor=1) with Box(VarParam(car, 1)) ], value is expected in rax

mov PVAR(1), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=car, minor=1) with Box(VarParam(car, 1))

;; Finished: Item 1 in Seq statement #84


;; Starting: Item 2 in Seq statement #84
;; Starting: Set VarParam(name=make-string, minor=2) with Box(VarParam(make-string, 2))
;; Starting: Evaluating rhs for [ Set VarParam(name=make-string, minor=2) with Box(VarParam(make-string, 2)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(make-string, 2)
;; Starting: Get VarParam(name=make-string, minor=2)
mov rax, PVAR(2)
;; Finished: Get VarParam(name=make-string, minor=2)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(make-string, 2)

;; Finished: Evaluating rhs for [ Set VarParam(name=make-string, minor=2) with Box(VarParam(make-string, 2)) ], value is expected in rax

mov PVAR(2), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=make-string, minor=2) with Box(VarParam(make-string, 2))

;; Finished: Item 2 in Seq statement #84


;; Starting: Item 3 in Seq statement #84

;; Finished: Item 3 in Seq statement #84

;; Finished: Seq statement #84: (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(car, 1) Box(VarParam(car, 1)))  (set! VarParam(make-string, 2) Box(VarParam(make-string, 2)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 0, 0)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(make-string, 0, 2)) BoxGet(VarParam(x, 0))  #\nul) (BoxGet(VarBound(make-string, 0, 2)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(car, 0, 1)) BoxGet(VarParam(y, 1))))))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont83:

;; Finished: Creating CLOSURE of LambdaSimple#83 -> (lambda (null? car make-string) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(car, 1) Box(VarParam(car, 1)))  (set! VarParam(make-string, 2) Box(VarParam(make-string, 2)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 0, 0)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(make-string, 0, 2)) BoxGet(VarParam(x, 0))  #\nul) (BoxGet(VarBound(make-string, 0, 2)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(car, 0, 1)) BoxGet(VarParam(y, 1)))))))))

;; Finished: Evaluating proc to apply (in Applic #82)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic82
int 3
ContinueApplic82:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #82
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#82 of: ((lambda (null? car make-string) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(car, 1) Box(VarParam(car, 1)))  (set! VarParam(make-string, 2) Box(VarParam(make-string, 2)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 0, 0)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(make-string, 0, 2)) BoxGet(VarParam(x, 0))  #\nul) (BoxGet(VarBound(make-string, 0, 2)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(car, 0, 1)) BoxGet(VarParam(y, 1))))))))) VarFree(null?)  VarFree(car)  VarFree(make-string))

mov qword [fvar_tbl+8*13], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar make-string to ((lambda (null? car make-string) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(car, 1) Box(VarParam(car, 1)))  (set! VarParam(make-string, 2) Box(VarParam(make-string, 2)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 0, 0)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(make-string, 0, 2)) BoxGet(VarParam(x, 0))  #\nul) (BoxGet(VarBound(make-string, 0, 2)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(car, 0, 1)) BoxGet(VarParam(y, 1))))))))) VarFree(null?)  VarFree(car)  VarFree(make-string))

	call write_sob_if_not_void

;; Starting: Set fvar not to (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if BoxGet(VarParam(x, 0)) #f #t)))
;; Starting: Creating CLOSURE of LambdaSimple#85 -> (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if BoxGet(VarParam(x, 0)) #f #t)))
push rbx
; Env Extend Code Section For Closure#85
mov rbx, 0 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend85
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End85

LClosureEnvExtend85:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, -1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 0
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop85:
  jz LClosureEnvExtend_LoopEnd85
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop85

LClosureEnvExtend_LoopEnd85:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd85
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop85:
  jz LClosureEnvExtend_ParamsLoopEnd85

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop85

LClosureEnvExtend_ParamsLoopEnd85:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End85:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode85)
pop rbx
jmp LClosureCont85
LClosureCode85:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #86: (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if BoxGet(VarParam(x, 0)) #f #t))
;; Starting: Item 0 in Seq statement #86
;; Starting: Set VarParam(name=x, minor=0) with Box(VarParam(x, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=x, minor=0) with Box(VarParam(x, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(x, 0)
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(x, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=x, minor=0) with Box(VarParam(x, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=x, minor=0) with Box(VarParam(x, 0))

;; Finished: Item 0 in Seq statement #86


;; Starting: Item 1 in Seq statement #86
;; Starting: If statement (#87): (if BoxGet(VarParam(x, 0)) #f #t)
Lif87:
;; Starting: BoxGet of VarParam(x, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(x, 0)

cmp rax, SOB_FALSE_ADDRESS
je Lelse87
mov rax, const_tbl+2	; mov const #f to rax
jmp LendIf87
Lelse87:
mov rax, const_tbl+4	; mov const #t to rax
LendIf87:
;; Finished: If statement (#87): (if BoxGet(VarParam(x, 0)) #f #t)

;; Finished: Item 1 in Seq statement #86

;; Finished: Seq statement #86: (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if BoxGet(VarParam(x, 0)) #f #t))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont85:

;; Finished: Creating CLOSURE of LambdaSimple#85 -> (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if BoxGet(VarParam(x, 0)) #f #t)))

mov qword [fvar_tbl+8*14], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar not to (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if BoxGet(VarParam(x, 0)) #f #t)))

	call write_sob_if_not_void

;; Starting: Perform Applic#88 of: ((lambda (flonum? rational? exact->inexact fold-left map _+ _* _/ _= _< car cdr null?) (begin (set! VarParam(flonum?, 0) Box(VarParam(flonum?, 0)))  (set! VarParam(rational?, 1) Box(VarParam(rational?, 1)))  (set! VarParam(exact->inexact, 2) Box(VarParam(exact->inexact, 2)))  (set! VarParam(fold-left, 3) Box(VarParam(fold-left, 3)))  (set! VarParam(map, 4) Box(VarParam(map, 4)))  (set! VarParam(_+, 5) Box(VarParam(_+, 5)))  (set! VarParam(_*, 6) Box(VarParam(_*, 6)))  (set! VarParam(_/, 7) Box(VarParam(_/, 7)))  (set! VarParam(_=, 8) Box(VarParam(_=, 8)))  (set! VarParam(_<, 9) Box(VarParam(_<, 9)))  (set! VarParam(car, 10) Box(VarParam(car, 10)))  (set! VarParam(cdr, 11) Box(VarParam(cdr, 11)))  (set! VarParam(null?, 12) Box(VarParam(null?, 12)))  ((lambda (^numeric-op-dispatcher) (begin (set! VarParam(^numeric-op-dispatcher, 0) Box(VarParam(^numeric-op-dispatcher, 0)))  ((lambda (normalize) (begin (set! VarParam(normalize, 0) Box(VarParam(normalize, 0)))  (set! VarFree(+) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(*) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(/) ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7))))))) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) BoxGet(VarParam(x, 0)) ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0)))))))))  ((lambda (^comparator) (begin (set! VarParam(^comparator, 0) Box(VarParam(^comparator, 0)))  (set! VarFree(=) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8)))))  (set! VarFree(<) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 2, 3)) (lambda (a b) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(b, 1) Box(VarParam(b, 1)))  (if BoxGet(VarParam(a, 0)) BoxGet(VarParam(b, 1)) #f)))  #t  (BoxGet(VarBound(map, 2, 4)) (lambda (y) (begin (set! VarParam(y, 0) Box(VarParam(y, 0)))  (BoxGet(VarBound(op, 1, 0)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 0)))))  BoxGet(VarParam(ys, 1))))))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1)))) (if (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1))) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1)))))))))))) VarFree(flonum?)  VarFree(rational?)  VarFree(exact->inexact)  VarFree(fold-left)  VarFree(map)  VarFree(+)  VarFree(*)  VarFree(/)  VarFree(=)  VarFree(<)  VarFree(car)  VarFree(cdr)  VarFree(null?))
;; Starting: Argument 12 of Applic statement #88
mov rax, qword [fvar_tbl+8*1]	; mov fvar null? to rax
;; Finished: Argument 12 of Applic statement #88

push rax ; Push argument to stack;; Starting: Argument 11 of Applic statement #88
mov rax, qword [fvar_tbl+8*3]	; mov fvar cdr to rax
;; Finished: Argument 11 of Applic statement #88

push rax ; Push argument to stack;; Starting: Argument 10 of Applic statement #88
mov rax, qword [fvar_tbl+8*2]	; mov fvar car to rax
;; Finished: Argument 10 of Applic statement #88

push rax ; Push argument to stack;; Starting: Argument 9 of Applic statement #88
mov rax, qword [fvar_tbl+8*22]	; mov fvar < to rax
;; Finished: Argument 9 of Applic statement #88

push rax ; Push argument to stack;; Starting: Argument 8 of Applic statement #88
mov rax, qword [fvar_tbl+8*21]	; mov fvar = to rax
;; Finished: Argument 8 of Applic statement #88

push rax ; Push argument to stack;; Starting: Argument 7 of Applic statement #88
mov rax, qword [fvar_tbl+8*17]	; mov fvar / to rax
;; Finished: Argument 7 of Applic statement #88

push rax ; Push argument to stack;; Starting: Argument 6 of Applic statement #88
mov rax, qword [fvar_tbl+8*16]	; mov fvar * to rax
;; Finished: Argument 6 of Applic statement #88

push rax ; Push argument to stack;; Starting: Argument 5 of Applic statement #88
mov rax, qword [fvar_tbl+8*15]	; mov fvar + to rax
;; Finished: Argument 5 of Applic statement #88

push rax ; Push argument to stack;; Starting: Argument 4 of Applic statement #88
mov rax, qword [fvar_tbl+8*0]	; mov fvar map to rax
;; Finished: Argument 4 of Applic statement #88

push rax ; Push argument to stack;; Starting: Argument 3 of Applic statement #88
mov rax, qword [fvar_tbl+8*6]	; mov fvar fold-left to rax
;; Finished: Argument 3 of Applic statement #88

push rax ; Push argument to stack;; Starting: Argument 2 of Applic statement #88
mov rax, qword [fvar_tbl+8*25]	; mov fvar exact->inexact to rax
;; Finished: Argument 2 of Applic statement #88

push rax ; Push argument to stack;; Starting: Argument 1 of Applic statement #88
mov rax, qword [fvar_tbl+8*24]	; mov fvar rational? to rax
;; Finished: Argument 1 of Applic statement #88

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #88
mov rax, qword [fvar_tbl+8*23]	; mov fvar flonum? to rax
;; Finished: Argument 0 of Applic statement #88

push rax ; Push argument to stack
push qword 13 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #88)
;; Starting: Creating CLOSURE of LambdaSimple#89 -> (lambda (flonum? rational? exact->inexact fold-left map _+ _* _/ _= _< car cdr null?) (begin (set! VarParam(flonum?, 0) Box(VarParam(flonum?, 0)))  (set! VarParam(rational?, 1) Box(VarParam(rational?, 1)))  (set! VarParam(exact->inexact, 2) Box(VarParam(exact->inexact, 2)))  (set! VarParam(fold-left, 3) Box(VarParam(fold-left, 3)))  (set! VarParam(map, 4) Box(VarParam(map, 4)))  (set! VarParam(_+, 5) Box(VarParam(_+, 5)))  (set! VarParam(_*, 6) Box(VarParam(_*, 6)))  (set! VarParam(_/, 7) Box(VarParam(_/, 7)))  (set! VarParam(_=, 8) Box(VarParam(_=, 8)))  (set! VarParam(_<, 9) Box(VarParam(_<, 9)))  (set! VarParam(car, 10) Box(VarParam(car, 10)))  (set! VarParam(cdr, 11) Box(VarParam(cdr, 11)))  (set! VarParam(null?, 12) Box(VarParam(null?, 12)))  ((lambda (^numeric-op-dispatcher) (begin (set! VarParam(^numeric-op-dispatcher, 0) Box(VarParam(^numeric-op-dispatcher, 0)))  ((lambda (normalize) (begin (set! VarParam(normalize, 0) Box(VarParam(normalize, 0)))  (set! VarFree(+) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(*) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(/) ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7))))))) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) BoxGet(VarParam(x, 0)) ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0)))))))))  ((lambda (^comparator) (begin (set! VarParam(^comparator, 0) Box(VarParam(^comparator, 0)))  (set! VarFree(=) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8)))))  (set! VarFree(<) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 2, 3)) (lambda (a b) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(b, 1) Box(VarParam(b, 1)))  (if BoxGet(VarParam(a, 0)) BoxGet(VarParam(b, 1)) #f)))  #t  (BoxGet(VarBound(map, 2, 4)) (lambda (y) (begin (set! VarParam(y, 0) Box(VarParam(y, 0)))  (BoxGet(VarBound(op, 1, 0)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 0)))))  BoxGet(VarParam(ys, 1))))))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1)))) (if (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1))) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))))))
push rbx
; Env Extend Code Section For Closure#89
mov rbx, 0 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend89
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End89

LClosureEnvExtend89:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, -1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 0
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop89:
  jz LClosureEnvExtend_LoopEnd89
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop89

LClosureEnvExtend_LoopEnd89:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd89
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop89:
  jz LClosureEnvExtend_ParamsLoopEnd89

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop89

LClosureEnvExtend_ParamsLoopEnd89:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End89:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode89)
pop rbx
jmp LClosureCont89
LClosureCode89:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #90: (begin (set! VarParam(flonum?, 0) Box(VarParam(flonum?, 0)))  (set! VarParam(rational?, 1) Box(VarParam(rational?, 1)))  (set! VarParam(exact->inexact, 2) Box(VarParam(exact->inexact, 2)))  (set! VarParam(fold-left, 3) Box(VarParam(fold-left, 3)))  (set! VarParam(map, 4) Box(VarParam(map, 4)))  (set! VarParam(_+, 5) Box(VarParam(_+, 5)))  (set! VarParam(_*, 6) Box(VarParam(_*, 6)))  (set! VarParam(_/, 7) Box(VarParam(_/, 7)))  (set! VarParam(_=, 8) Box(VarParam(_=, 8)))  (set! VarParam(_<, 9) Box(VarParam(_<, 9)))  (set! VarParam(car, 10) Box(VarParam(car, 10)))  (set! VarParam(cdr, 11) Box(VarParam(cdr, 11)))  (set! VarParam(null?, 12) Box(VarParam(null?, 12)))  ((lambda (^numeric-op-dispatcher) (begin (set! VarParam(^numeric-op-dispatcher, 0) Box(VarParam(^numeric-op-dispatcher, 0)))  ((lambda (normalize) (begin (set! VarParam(normalize, 0) Box(VarParam(normalize, 0)))  (set! VarFree(+) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(*) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(/) ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7))))))) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) BoxGet(VarParam(x, 0)) ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0)))))))))  ((lambda (^comparator) (begin (set! VarParam(^comparator, 0) Box(VarParam(^comparator, 0)))  (set! VarFree(=) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8)))))  (set! VarFree(<) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 2, 3)) (lambda (a b) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(b, 1) Box(VarParam(b, 1)))  (if BoxGet(VarParam(a, 0)) BoxGet(VarParam(b, 1)) #f)))  #t  (BoxGet(VarBound(map, 2, 4)) (lambda (y) (begin (set! VarParam(y, 0) Box(VarParam(y, 0)))  (BoxGet(VarBound(op, 1, 0)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 0)))))  BoxGet(VarParam(ys, 1))))))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1)))) (if (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1))) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1)))))))))))
;; Starting: Item 0 in Seq statement #90
;; Starting: Set VarParam(name=flonum?, minor=0) with Box(VarParam(flonum?, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=flonum?, minor=0) with Box(VarParam(flonum?, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(flonum?, 0)
;; Starting: Get VarParam(name=flonum?, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=flonum?, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(flonum?, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=flonum?, minor=0) with Box(VarParam(flonum?, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=flonum?, minor=0) with Box(VarParam(flonum?, 0))

;; Finished: Item 0 in Seq statement #90


;; Starting: Item 1 in Seq statement #90
;; Starting: Set VarParam(name=rational?, minor=1) with Box(VarParam(rational?, 1))
;; Starting: Evaluating rhs for [ Set VarParam(name=rational?, minor=1) with Box(VarParam(rational?, 1)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(rational?, 1)
;; Starting: Get VarParam(name=rational?, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=rational?, minor=1)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(rational?, 1)

;; Finished: Evaluating rhs for [ Set VarParam(name=rational?, minor=1) with Box(VarParam(rational?, 1)) ], value is expected in rax

mov PVAR(1), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=rational?, minor=1) with Box(VarParam(rational?, 1))

;; Finished: Item 1 in Seq statement #90


;; Starting: Item 2 in Seq statement #90
;; Starting: Set VarParam(name=exact->inexact, minor=2) with Box(VarParam(exact->inexact, 2))
;; Starting: Evaluating rhs for [ Set VarParam(name=exact->inexact, minor=2) with Box(VarParam(exact->inexact, 2)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(exact->inexact, 2)
;; Starting: Get VarParam(name=exact->inexact, minor=2)
mov rax, PVAR(2)
;; Finished: Get VarParam(name=exact->inexact, minor=2)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(exact->inexact, 2)

;; Finished: Evaluating rhs for [ Set VarParam(name=exact->inexact, minor=2) with Box(VarParam(exact->inexact, 2)) ], value is expected in rax

mov PVAR(2), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=exact->inexact, minor=2) with Box(VarParam(exact->inexact, 2))

;; Finished: Item 2 in Seq statement #90


;; Starting: Item 3 in Seq statement #90
;; Starting: Set VarParam(name=fold-left, minor=3) with Box(VarParam(fold-left, 3))
;; Starting: Evaluating rhs for [ Set VarParam(name=fold-left, minor=3) with Box(VarParam(fold-left, 3)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(fold-left, 3)
;; Starting: Get VarParam(name=fold-left, minor=3)
mov rax, PVAR(3)
;; Finished: Get VarParam(name=fold-left, minor=3)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(fold-left, 3)

;; Finished: Evaluating rhs for [ Set VarParam(name=fold-left, minor=3) with Box(VarParam(fold-left, 3)) ], value is expected in rax

mov PVAR(3), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=fold-left, minor=3) with Box(VarParam(fold-left, 3))

;; Finished: Item 3 in Seq statement #90


;; Starting: Item 4 in Seq statement #90
;; Starting: Set VarParam(name=map, minor=4) with Box(VarParam(map, 4))
;; Starting: Evaluating rhs for [ Set VarParam(name=map, minor=4) with Box(VarParam(map, 4)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(map, 4)
;; Starting: Get VarParam(name=map, minor=4)
mov rax, PVAR(4)
;; Finished: Get VarParam(name=map, minor=4)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(map, 4)

;; Finished: Evaluating rhs for [ Set VarParam(name=map, minor=4) with Box(VarParam(map, 4)) ], value is expected in rax

mov PVAR(4), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=map, minor=4) with Box(VarParam(map, 4))

;; Finished: Item 4 in Seq statement #90


;; Starting: Item 5 in Seq statement #90
;; Starting: Set VarParam(name=_+, minor=5) with Box(VarParam(_+, 5))
;; Starting: Evaluating rhs for [ Set VarParam(name=_+, minor=5) with Box(VarParam(_+, 5)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(_+, 5)
;; Starting: Get VarParam(name=_+, minor=5)
mov rax, PVAR(5)
;; Finished: Get VarParam(name=_+, minor=5)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(_+, 5)

;; Finished: Evaluating rhs for [ Set VarParam(name=_+, minor=5) with Box(VarParam(_+, 5)) ], value is expected in rax

mov PVAR(5), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=_+, minor=5) with Box(VarParam(_+, 5))

;; Finished: Item 5 in Seq statement #90


;; Starting: Item 6 in Seq statement #90
;; Starting: Set VarParam(name=_*, minor=6) with Box(VarParam(_*, 6))
;; Starting: Evaluating rhs for [ Set VarParam(name=_*, minor=6) with Box(VarParam(_*, 6)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(_*, 6)
;; Starting: Get VarParam(name=_*, minor=6)
mov rax, PVAR(6)
;; Finished: Get VarParam(name=_*, minor=6)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(_*, 6)

;; Finished: Evaluating rhs for [ Set VarParam(name=_*, minor=6) with Box(VarParam(_*, 6)) ], value is expected in rax

mov PVAR(6), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=_*, minor=6) with Box(VarParam(_*, 6))

;; Finished: Item 6 in Seq statement #90


;; Starting: Item 7 in Seq statement #90
;; Starting: Set VarParam(name=_/, minor=7) with Box(VarParam(_/, 7))
;; Starting: Evaluating rhs for [ Set VarParam(name=_/, minor=7) with Box(VarParam(_/, 7)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(_/, 7)
;; Starting: Get VarParam(name=_/, minor=7)
mov rax, PVAR(7)
;; Finished: Get VarParam(name=_/, minor=7)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(_/, 7)

;; Finished: Evaluating rhs for [ Set VarParam(name=_/, minor=7) with Box(VarParam(_/, 7)) ], value is expected in rax

mov PVAR(7), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=_/, minor=7) with Box(VarParam(_/, 7))

;; Finished: Item 7 in Seq statement #90


;; Starting: Item 8 in Seq statement #90
;; Starting: Set VarParam(name=_=, minor=8) with Box(VarParam(_=, 8))
;; Starting: Evaluating rhs for [ Set VarParam(name=_=, minor=8) with Box(VarParam(_=, 8)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(_=, 8)
;; Starting: Get VarParam(name=_=, minor=8)
mov rax, PVAR(8)
;; Finished: Get VarParam(name=_=, minor=8)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(_=, 8)

;; Finished: Evaluating rhs for [ Set VarParam(name=_=, minor=8) with Box(VarParam(_=, 8)) ], value is expected in rax

mov PVAR(8), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=_=, minor=8) with Box(VarParam(_=, 8))

;; Finished: Item 8 in Seq statement #90


;; Starting: Item 9 in Seq statement #90
;; Starting: Set VarParam(name=_<, minor=9) with Box(VarParam(_<, 9))
;; Starting: Evaluating rhs for [ Set VarParam(name=_<, minor=9) with Box(VarParam(_<, 9)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(_<, 9)
;; Starting: Get VarParam(name=_<, minor=9)
mov rax, PVAR(9)
;; Finished: Get VarParam(name=_<, minor=9)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(_<, 9)

;; Finished: Evaluating rhs for [ Set VarParam(name=_<, minor=9) with Box(VarParam(_<, 9)) ], value is expected in rax

mov PVAR(9), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=_<, minor=9) with Box(VarParam(_<, 9))

;; Finished: Item 9 in Seq statement #90


;; Starting: Item 10 in Seq statement #90
;; Starting: Set VarParam(name=car, minor=10) with Box(VarParam(car, 10))
;; Starting: Evaluating rhs for [ Set VarParam(name=car, minor=10) with Box(VarParam(car, 10)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(car, 10)
;; Starting: Get VarParam(name=car, minor=10)
mov rax, PVAR(10)
;; Finished: Get VarParam(name=car, minor=10)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(car, 10)

;; Finished: Evaluating rhs for [ Set VarParam(name=car, minor=10) with Box(VarParam(car, 10)) ], value is expected in rax

mov PVAR(10), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=car, minor=10) with Box(VarParam(car, 10))

;; Finished: Item 10 in Seq statement #90


;; Starting: Item 11 in Seq statement #90
;; Starting: Set VarParam(name=cdr, minor=11) with Box(VarParam(cdr, 11))
;; Starting: Evaluating rhs for [ Set VarParam(name=cdr, minor=11) with Box(VarParam(cdr, 11)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(cdr, 11)
;; Starting: Get VarParam(name=cdr, minor=11)
mov rax, PVAR(11)
;; Finished: Get VarParam(name=cdr, minor=11)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(cdr, 11)

;; Finished: Evaluating rhs for [ Set VarParam(name=cdr, minor=11) with Box(VarParam(cdr, 11)) ], value is expected in rax

mov PVAR(11), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=cdr, minor=11) with Box(VarParam(cdr, 11))

;; Finished: Item 11 in Seq statement #90


;; Starting: Item 12 in Seq statement #90
;; Starting: Set VarParam(name=null?, minor=12) with Box(VarParam(null?, 12))
;; Starting: Evaluating rhs for [ Set VarParam(name=null?, minor=12) with Box(VarParam(null?, 12)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(null?, 12)
;; Starting: Get VarParam(name=null?, minor=12)
mov rax, PVAR(12)
;; Finished: Get VarParam(name=null?, minor=12)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(null?, 12)

;; Finished: Evaluating rhs for [ Set VarParam(name=null?, minor=12) with Box(VarParam(null?, 12)) ], value is expected in rax

mov PVAR(12), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=null?, minor=12) with Box(VarParam(null?, 12))

;; Finished: Item 12 in Seq statement #90


;; Starting: Item 13 in Seq statement #90
;; Starting: Perform Applic#91 of: ((lambda (^numeric-op-dispatcher) (begin (set! VarParam(^numeric-op-dispatcher, 0) Box(VarParam(^numeric-op-dispatcher, 0)))  ((lambda (normalize) (begin (set! VarParam(normalize, 0) Box(VarParam(normalize, 0)))  (set! VarFree(+) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(*) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(/) ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7))))))) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) BoxGet(VarParam(x, 0)) ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0)))))))))  ((lambda (^comparator) (begin (set! VarParam(^comparator, 0) Box(VarParam(^comparator, 0)))  (set! VarFree(=) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8)))))  (set! VarFree(<) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 2, 3)) (lambda (a b) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(b, 1) Box(VarParam(b, 1)))  (if BoxGet(VarParam(a, 0)) BoxGet(VarParam(b, 1)) #f)))  #t  (BoxGet(VarBound(map, 2, 4)) (lambda (y) (begin (set! VarParam(y, 0) Box(VarParam(y, 0)))  (BoxGet(VarBound(op, 1, 0)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 0)))))  BoxGet(VarParam(ys, 1))))))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1)))) (if (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1))) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))))
;; Starting: Argument 0 of Applic statement #91
;; Starting: Creating CLOSURE of LambdaSimple#92 -> (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1)))) (if (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1))) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1)))))))))
push rbx
; Env Extend Code Section For Closure#92
mov rbx, 1 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend92
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End92

LClosureEnvExtend92:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 0
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 8
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop92:
  jz LClosureEnvExtend_LoopEnd92
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop92

LClosureEnvExtend_LoopEnd92:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd92
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop92:
  jz LClosureEnvExtend_ParamsLoopEnd92

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop92

LClosureEnvExtend_ParamsLoopEnd92:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End92:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode92)
pop rbx
jmp LClosureCont92
LClosureCode92:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #93: (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1)))) (if (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1))) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))
;; Starting: Item 0 in Seq statement #93
;; Starting: Set VarParam(name=op, minor=0) with Box(VarParam(op, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=op, minor=0) with Box(VarParam(op, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(op, 0)
;; Starting: Get VarParam(name=op, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=op, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(op, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=op, minor=0) with Box(VarParam(op, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=op, minor=0) with Box(VarParam(op, 0))

;; Finished: Item 0 in Seq statement #93


;; Starting: Item 1 in Seq statement #93
;; Starting: Creating CLOSURE of LambdaSimple#94 -> (lambda (x y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1)))) (if (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1))) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1)))))))
push rbx
; Env Extend Code Section For Closure#94
mov rbx, 2 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend94
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End94

LClosureEnvExtend94:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 16
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop94:
  jz LClosureEnvExtend_LoopEnd94
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop94

LClosureEnvExtend_LoopEnd94:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd94
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop94:
  jz LClosureEnvExtend_ParamsLoopEnd94

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop94

LClosureEnvExtend_ParamsLoopEnd94:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End94:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode94)
pop rbx
jmp LClosureCont94
LClosureCode94:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #95: (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1)))) (if (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1))) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))
;; Starting: Item 0 in Seq statement #95
;; Starting: Set VarParam(name=x, minor=0) with Box(VarParam(x, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=x, minor=0) with Box(VarParam(x, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(x, 0)
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(x, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=x, minor=0) with Box(VarParam(x, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=x, minor=0) with Box(VarParam(x, 0))

;; Finished: Item 0 in Seq statement #95


;; Starting: Item 1 in Seq statement #95
;; Starting: Set VarParam(name=y, minor=1) with Box(VarParam(y, 1))
;; Starting: Evaluating rhs for [ Set VarParam(name=y, minor=1) with Box(VarParam(y, 1)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(y, 1)
;; Starting: Get VarParam(name=y, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=y, minor=1)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(y, 1)

;; Finished: Evaluating rhs for [ Set VarParam(name=y, minor=1) with Box(VarParam(y, 1)) ], value is expected in rax

mov PVAR(1), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=y, minor=1) with Box(VarParam(y, 1))

;; Finished: Item 1 in Seq statement #95


;; Starting: Item 2 in Seq statement #95
;; Starting: If statement (#96): (if (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1)))) (if (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1))) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1)))))
Lif96:
;; Starting: If statement (#97): (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1))) #f)
Lif97:
;; Starting: Perform Applic#98 of: (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0)))
;; Starting: Argument 0 of Applic statement #98
;; Starting: BoxGet of VarParam(x, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(x, 0)

;; Finished: Argument 0 of Applic statement #98

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #98)
;; Starting: BoxGet of VarBound(flonum?, 1, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(flonum?, 1, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=flonum?, major=1, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=flonum?, major=1, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(flonum?, 1, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(flonum?, 1, 0)

;; Finished: Evaluating proc to apply (in Applic #98)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic98
int 3
ContinueApplic98:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #98
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#98 of: (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0)))

cmp rax, SOB_FALSE_ADDRESS
je Lelse97
;; Starting: Perform Applic#99 of: (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1)))
;; Starting: Argument 0 of Applic statement #99
;; Starting: BoxGet of VarParam(y, 1)
;; Starting: Evaluating val for [ BoxGet of VarParam(y, 1) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=y, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=y, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarParam(y, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(y, 1)

;; Finished: Argument 0 of Applic statement #99

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #99)
;; Starting: BoxGet of VarBound(rational?, 1, 1)
;; Starting: Evaluating val for [ BoxGet of VarBound(rational?, 1, 1) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=rational?, major=1, minor=1)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
;; Finished: Get VarBound(name=rational?, major=1, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarBound(rational?, 1, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(rational?, 1, 1)

;; Finished: Evaluating proc to apply (in Applic #99)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic99
int 3
ContinueApplic99:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #99
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#99 of: (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1)))

jmp LendIf97
Lelse97:
mov rax, const_tbl+2	; mov const #f to rax
LendIf97:
;; Finished: If statement (#97): (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1))) #f)

cmp rax, SOB_FALSE_ADDRESS
je Lelse96
;; Starting: Perform Applic#100 of: (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1))))
;; Starting: Argument 1 of Applic statement #100
;; Starting: Perform Applic#101 of: (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1)))
;; Starting: Argument 0 of Applic statement #101
;; Starting: BoxGet of VarParam(y, 1)
;; Starting: Evaluating val for [ BoxGet of VarParam(y, 1) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=y, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=y, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarParam(y, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(y, 1)

;; Finished: Argument 0 of Applic statement #101

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #101)
;; Starting: BoxGet of VarBound(exact->inexact, 1, 2)
;; Starting: Evaluating val for [ BoxGet of VarBound(exact->inexact, 1, 2) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=exact->inexact, major=1, minor=2)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]
;; Finished: Get VarBound(name=exact->inexact, major=1, minor=2)

;; Finished: Evaluating val for [ BoxGet of VarBound(exact->inexact, 1, 2) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(exact->inexact, 1, 2)

;; Finished: Evaluating proc to apply (in Applic #101)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic101
int 3
ContinueApplic101:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #101
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#101 of: (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1)))

;; Finished: Argument 1 of Applic statement #100

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #100
;; Starting: BoxGet of VarParam(x, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(x, 0)

;; Finished: Argument 0 of Applic statement #100

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #100)
;; Starting: BoxGet of VarBound(op, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(op, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=op, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=op, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(op, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(op, 0, 0)

;; Finished: Evaluating proc to apply (in Applic #100)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic100
int 3
ContinueApplic100:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #100
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#100 of: (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1))))

jmp LendIf96
Lelse96:
;; Starting: If statement (#102): (if (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1))) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))
Lif102:
;; Starting: If statement (#103): (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f)
Lif103:
;; Starting: Perform Applic#104 of: (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0)))
;; Starting: Argument 0 of Applic statement #104
;; Starting: BoxGet of VarParam(x, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(x, 0)

;; Finished: Argument 0 of Applic statement #104

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #104)
;; Starting: BoxGet of VarBound(rational?, 1, 1)
;; Starting: Evaluating val for [ BoxGet of VarBound(rational?, 1, 1) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=rational?, major=1, minor=1)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
;; Finished: Get VarBound(name=rational?, major=1, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarBound(rational?, 1, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(rational?, 1, 1)

;; Finished: Evaluating proc to apply (in Applic #104)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic104
int 3
ContinueApplic104:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #104
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#104 of: (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0)))

cmp rax, SOB_FALSE_ADDRESS
je Lelse103
;; Starting: Perform Applic#105 of: (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1)))
;; Starting: Argument 0 of Applic statement #105
;; Starting: BoxGet of VarParam(y, 1)
;; Starting: Evaluating val for [ BoxGet of VarParam(y, 1) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=y, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=y, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarParam(y, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(y, 1)

;; Finished: Argument 0 of Applic statement #105

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #105)
;; Starting: BoxGet of VarBound(flonum?, 1, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(flonum?, 1, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=flonum?, major=1, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=flonum?, major=1, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(flonum?, 1, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(flonum?, 1, 0)

;; Finished: Evaluating proc to apply (in Applic #105)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic105
int 3
ContinueApplic105:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #105
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#105 of: (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1)))

jmp LendIf103
Lelse103:
mov rax, const_tbl+2	; mov const #f to rax
LendIf103:
;; Finished: If statement (#103): (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f)

cmp rax, SOB_FALSE_ADDRESS
je Lelse102
;; Starting: Perform Applic#106 of: (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1)))
;; Starting: Argument 1 of Applic statement #106
;; Starting: BoxGet of VarParam(y, 1)
;; Starting: Evaluating val for [ BoxGet of VarParam(y, 1) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=y, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=y, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarParam(y, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(y, 1)

;; Finished: Argument 1 of Applic statement #106

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #106
;; Starting: Perform Applic#107 of: (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))
;; Starting: Argument 0 of Applic statement #107
;; Starting: BoxGet of VarParam(x, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(x, 0)

;; Finished: Argument 0 of Applic statement #107

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #107)
;; Starting: BoxGet of VarBound(exact->inexact, 1, 2)
;; Starting: Evaluating val for [ BoxGet of VarBound(exact->inexact, 1, 2) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=exact->inexact, major=1, minor=2)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]
;; Finished: Get VarBound(name=exact->inexact, major=1, minor=2)

;; Finished: Evaluating val for [ BoxGet of VarBound(exact->inexact, 1, 2) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(exact->inexact, 1, 2)

;; Finished: Evaluating proc to apply (in Applic #107)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic107
int 3
ContinueApplic107:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #107
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#107 of: (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))

;; Finished: Argument 0 of Applic statement #106

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #106)
;; Starting: BoxGet of VarBound(op, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(op, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=op, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=op, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(op, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(op, 0, 0)

;; Finished: Evaluating proc to apply (in Applic #106)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic106
int 3
ContinueApplic106:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #106
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#106 of: (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1)))

jmp LendIf102
Lelse102:
;; Starting: Perform Applic#108 of: (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1)))
;; Starting: Argument 1 of Applic statement #108
;; Starting: BoxGet of VarParam(y, 1)
;; Starting: Evaluating val for [ BoxGet of VarParam(y, 1) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=y, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=y, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarParam(y, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(y, 1)

;; Finished: Argument 1 of Applic statement #108

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #108
;; Starting: BoxGet of VarParam(x, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(x, 0)

;; Finished: Argument 0 of Applic statement #108

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #108)
;; Starting: BoxGet of VarBound(op, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(op, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=op, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=op, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(op, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(op, 0, 0)

;; Finished: Evaluating proc to apply (in Applic #108)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic108
int 3
ContinueApplic108:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #108
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#108 of: (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1)))

LendIf102:
;; Finished: If statement (#102): (if (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1))) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))

LendIf96:
;; Finished: If statement (#96): (if (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1)))) (if (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1))) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1)))))

;; Finished: Item 2 in Seq statement #95

;; Finished: Seq statement #95: (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1)))) (if (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1))) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont94:

;; Finished: Creating CLOSURE of LambdaSimple#94 -> (lambda (x y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1)))) (if (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1))) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1)))))))

;; Finished: Item 1 in Seq statement #93

;; Finished: Seq statement #93: (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1)))) (if (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1))) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont92:

;; Finished: Creating CLOSURE of LambdaSimple#92 -> (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1)))) (if (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1))) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1)))))))))

;; Finished: Argument 0 of Applic statement #91

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #91)
;; Starting: Creating CLOSURE of LambdaSimple#109 -> (lambda (^numeric-op-dispatcher) (begin (set! VarParam(^numeric-op-dispatcher, 0) Box(VarParam(^numeric-op-dispatcher, 0)))  ((lambda (normalize) (begin (set! VarParam(normalize, 0) Box(VarParam(normalize, 0)))  (set! VarFree(+) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(*) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(/) ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7))))))) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) BoxGet(VarParam(x, 0)) ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0)))))))))  ((lambda (^comparator) (begin (set! VarParam(^comparator, 0) Box(VarParam(^comparator, 0)))  (set! VarFree(=) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8)))))  (set! VarFree(<) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 2, 3)) (lambda (a b) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(b, 1) Box(VarParam(b, 1)))  (if BoxGet(VarParam(a, 0)) BoxGet(VarParam(b, 1)) #f)))  #t  (BoxGet(VarBound(map, 2, 4)) (lambda (y) (begin (set! VarParam(y, 0) Box(VarParam(y, 0)))  (BoxGet(VarBound(op, 1, 0)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 0)))))  BoxGet(VarParam(ys, 1)))))))))))
push rbx
; Env Extend Code Section For Closure#109
mov rbx, 3 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend109
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End109

LClosureEnvExtend109:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 2
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 24
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop109:
  jz LClosureEnvExtend_LoopEnd109
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop109

LClosureEnvExtend_LoopEnd109:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd109
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop109:
  jz LClosureEnvExtend_ParamsLoopEnd109

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop109

LClosureEnvExtend_ParamsLoopEnd109:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End109:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode109)
pop rbx
jmp LClosureCont109
LClosureCode109:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #110: (begin (set! VarParam(^numeric-op-dispatcher, 0) Box(VarParam(^numeric-op-dispatcher, 0)))  ((lambda (normalize) (begin (set! VarParam(normalize, 0) Box(VarParam(normalize, 0)))  (set! VarFree(+) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(*) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(/) ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7))))))) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) BoxGet(VarParam(x, 0)) ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0)))))))))  ((lambda (^comparator) (begin (set! VarParam(^comparator, 0) Box(VarParam(^comparator, 0)))  (set! VarFree(=) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8)))))  (set! VarFree(<) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 2, 3)) (lambda (a b) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(b, 1) Box(VarParam(b, 1)))  (if BoxGet(VarParam(a, 0)) BoxGet(VarParam(b, 1)) #f)))  #t  (BoxGet(VarBound(map, 2, 4)) (lambda (y) (begin (set! VarParam(y, 0) Box(VarParam(y, 0)))  (BoxGet(VarBound(op, 1, 0)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 0)))))  BoxGet(VarParam(ys, 1))))))))))
;; Starting: Item 0 in Seq statement #110
;; Starting: Set VarParam(name=^numeric-op-dispatcher, minor=0) with Box(VarParam(^numeric-op-dispatcher, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=^numeric-op-dispatcher, minor=0) with Box(VarParam(^numeric-op-dispatcher, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(^numeric-op-dispatcher, 0)
;; Starting: Get VarParam(name=^numeric-op-dispatcher, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=^numeric-op-dispatcher, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(^numeric-op-dispatcher, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=^numeric-op-dispatcher, minor=0) with Box(VarParam(^numeric-op-dispatcher, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=^numeric-op-dispatcher, minor=0) with Box(VarParam(^numeric-op-dispatcher, 0))

;; Finished: Item 0 in Seq statement #110


;; Starting: Item 1 in Seq statement #110
;; Starting: Perform Applic#111 of: ((lambda (normalize) (begin (set! VarParam(normalize, 0) Box(VarParam(normalize, 0)))  (set! VarFree(+) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(*) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(/) ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7))))))) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) BoxGet(VarParam(x, 0)) ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0)))))))))
;; Starting: Argument 0 of Applic statement #111
;; Starting: Creating CLOSURE of LambdaSimple#112 -> (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) BoxGet(VarParam(x, 0)) ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0))))))))
push rbx
; Env Extend Code Section For Closure#112
mov rbx, 4 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend112
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End112

LClosureEnvExtend112:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 3
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 32
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop112:
  jz LClosureEnvExtend_LoopEnd112
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop112

LClosureEnvExtend_LoopEnd112:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd112
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop112:
  jz LClosureEnvExtend_ParamsLoopEnd112

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop112

LClosureEnvExtend_ParamsLoopEnd112:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End112:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode112)
pop rbx
jmp LClosureCont112
LClosureCode112:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #113: (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) BoxGet(VarParam(x, 0)) ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0)))))))
;; Starting: Item 0 in Seq statement #113
;; Starting: Set VarParam(name=x, minor=0) with Box(VarParam(x, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=x, minor=0) with Box(VarParam(x, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(x, 0)
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(x, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=x, minor=0) with Box(VarParam(x, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=x, minor=0) with Box(VarParam(x, 0))

;; Finished: Item 0 in Seq statement #113


;; Starting: Item 1 in Seq statement #113
;; Starting: If statement (#114): (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) BoxGet(VarParam(x, 0)) ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0))))))
Lif114:
;; Starting: Perform Applic#115 of: (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0)))
;; Starting: Argument 0 of Applic statement #115
;; Starting: BoxGet of VarParam(x, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(x, 0)

;; Finished: Argument 0 of Applic statement #115

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #115)
;; Starting: BoxGet of VarBound(flonum?, 1, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(flonum?, 1, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=flonum?, major=1, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=flonum?, major=1, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(flonum?, 1, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(flonum?, 1, 0)

;; Finished: Evaluating proc to apply (in Applic #115)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic115
int 3
ContinueApplic115:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #115
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#115 of: (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0)))

cmp rax, SOB_FALSE_ADDRESS
je Lelse114
;; Starting: BoxGet of VarParam(x, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(x, 0)

jmp LendIf114
Lelse114:
;; Starting: Perform Applic#116 of: ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0)))))
;; Starting: Argument 0 of Applic statement #116
;; Starting: Perform Applic#117 of: (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0))))
;; Starting: Argument 1 of Applic statement #117
;; Starting: Perform Applic#119 of: (VarFree(denominator) BoxGet(VarParam(x, 0)))
;; Starting: Argument 0 of Applic statement #119
;; Starting: BoxGet of VarParam(x, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(x, 0)

;; Finished: Argument 0 of Applic statement #119

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #119)
mov rax, qword [fvar_tbl+8*19]	; mov fvar denominator to rax
;; Finished: Evaluating proc to apply (in Applic #119)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic119
int 3
ContinueApplic119:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #119
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#119 of: (VarFree(denominator) BoxGet(VarParam(x, 0)))

;; Finished: Argument 1 of Applic statement #117

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #117
;; Starting: Perform Applic#118 of: (VarFree(numerator) BoxGet(VarParam(x, 0)))
;; Starting: Argument 0 of Applic statement #118
;; Starting: BoxGet of VarParam(x, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(x, 0)

;; Finished: Argument 0 of Applic statement #118

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #118)
mov rax, qword [fvar_tbl+8*18]	; mov fvar numerator to rax
;; Finished: Evaluating proc to apply (in Applic #118)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic118
int 3
ContinueApplic118:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #118
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#118 of: (VarFree(numerator) BoxGet(VarParam(x, 0)))

;; Finished: Argument 0 of Applic statement #117

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #117)
mov rax, qword [fvar_tbl+8*20]	; mov fvar gcd to rax
;; Finished: Evaluating proc to apply (in Applic #117)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic117
int 3
ContinueApplic117:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #117
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#117 of: (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0))))

;; Finished: Argument 0 of Applic statement #116

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #116)
;; Starting: Creating CLOSURE of LambdaSimple#120 -> (lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0))))))
push rbx
; Env Extend Code Section For Closure#120
mov rbx, 5 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend120
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End120

LClosureEnvExtend120:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 4
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 40
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop120:
  jz LClosureEnvExtend_LoopEnd120
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop120

LClosureEnvExtend_LoopEnd120:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd120
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop120:
  jz LClosureEnvExtend_ParamsLoopEnd120

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop120

LClosureEnvExtend_ParamsLoopEnd120:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End120:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode120)
pop rbx
jmp LClosureCont120
LClosureCode120:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #121: (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))
;; Starting: Item 0 in Seq statement #121
;; Starting: Set VarParam(name=n, minor=0) with Box(VarParam(n, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=n, minor=0) with Box(VarParam(n, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(n, 0)
;; Starting: Get VarParam(name=n, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=n, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(n, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=n, minor=0) with Box(VarParam(n, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=n, minor=0) with Box(VarParam(n, 0))

;; Finished: Item 0 in Seq statement #121


;; Starting: Item 1 in Seq statement #121
;; Starting: Perform Applic#122 of: (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0))))
;; Starting: Argument 1 of Applic statement #122
;; Starting: Perform Applic#125 of: (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))
;; Starting: Argument 1 of Applic statement #125
;; Starting: BoxGet of VarParam(n, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(n, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=n, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=n, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(n, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(n, 0)

;; Finished: Argument 1 of Applic statement #125

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #125
;; Starting: Perform Applic#126 of: (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))
;; Starting: Argument 0 of Applic statement #126
;; Starting: BoxGet of VarBound(x, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(x, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=x, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=x, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(x, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(x, 0, 0)

;; Finished: Argument 0 of Applic statement #126

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #126)
mov rax, qword [fvar_tbl+8*19]	; mov fvar denominator to rax
;; Finished: Evaluating proc to apply (in Applic #126)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic126
int 3
ContinueApplic126:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #126
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#126 of: (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))

;; Finished: Argument 0 of Applic statement #125

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #125)
;; Starting: BoxGet of VarBound(_/, 2, 7)
;; Starting: Evaluating val for [ BoxGet of VarBound(_/, 2, 7) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=_/, major=2, minor=7)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 7]
;; Finished: Get VarBound(name=_/, major=2, minor=7)

;; Finished: Evaluating val for [ BoxGet of VarBound(_/, 2, 7) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(_/, 2, 7)

;; Finished: Evaluating proc to apply (in Applic #125)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic125
int 3
ContinueApplic125:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #125
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#125 of: (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))

;; Finished: Argument 1 of Applic statement #122

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #122
;; Starting: Perform Applic#123 of: (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))
;; Starting: Argument 1 of Applic statement #123
;; Starting: BoxGet of VarParam(n, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(n, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=n, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=n, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(n, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(n, 0)

;; Finished: Argument 1 of Applic statement #123

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #123
;; Starting: Perform Applic#124 of: (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))
;; Starting: Argument 0 of Applic statement #124
;; Starting: BoxGet of VarBound(x, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(x, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=x, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=x, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(x, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(x, 0, 0)

;; Finished: Argument 0 of Applic statement #124

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #124)
mov rax, qword [fvar_tbl+8*18]	; mov fvar numerator to rax
;; Finished: Evaluating proc to apply (in Applic #124)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic124
int 3
ContinueApplic124:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #124
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#124 of: (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))

;; Finished: Argument 0 of Applic statement #123

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #123)
;; Starting: BoxGet of VarBound(_/, 2, 7)
;; Starting: Evaluating val for [ BoxGet of VarBound(_/, 2, 7) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=_/, major=2, minor=7)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 7]
;; Finished: Get VarBound(name=_/, major=2, minor=7)

;; Finished: Evaluating val for [ BoxGet of VarBound(_/, 2, 7) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(_/, 2, 7)

;; Finished: Evaluating proc to apply (in Applic #123)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic123
int 3
ContinueApplic123:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #123
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#123 of: (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))

;; Finished: Argument 0 of Applic statement #122

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #122)
;; Starting: BoxGet of VarBound(_/, 2, 7)
;; Starting: Evaluating val for [ BoxGet of VarBound(_/, 2, 7) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=_/, major=2, minor=7)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 7]
;; Finished: Get VarBound(name=_/, major=2, minor=7)

;; Finished: Evaluating val for [ BoxGet of VarBound(_/, 2, 7) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(_/, 2, 7)

;; Finished: Evaluating proc to apply (in Applic #122)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic122
int 3
ContinueApplic122:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #122
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#122 of: (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0))))

;; Finished: Item 1 in Seq statement #121

;; Finished: Seq statement #121: (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont120:

;; Finished: Creating CLOSURE of LambdaSimple#120 -> (lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0))))))

;; Finished: Evaluating proc to apply (in Applic #116)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic116
int 3
ContinueApplic116:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #116
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#116 of: ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0)))))

LendIf114:
;; Finished: If statement (#114): (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) BoxGet(VarParam(x, 0)) ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0))))))

;; Finished: Item 1 in Seq statement #113

;; Finished: Seq statement #113: (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) BoxGet(VarParam(x, 0)) ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0)))))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont112:

;; Finished: Creating CLOSURE of LambdaSimple#112 -> (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) BoxGet(VarParam(x, 0)) ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0))))))))

;; Finished: Argument 0 of Applic statement #111

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #111)
;; Starting: Creating CLOSURE of LambdaSimple#127 -> (lambda (normalize) (begin (set! VarParam(normalize, 0) Box(VarParam(normalize, 0)))  (set! VarFree(+) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(*) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(/) ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7)))))))
push rbx
; Env Extend Code Section For Closure#127
mov rbx, 6 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend127
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End127

LClosureEnvExtend127:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 5
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 48
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop127:
  jz LClosureEnvExtend_LoopEnd127
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop127

LClosureEnvExtend_LoopEnd127:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd127
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop127:
  jz LClosureEnvExtend_ParamsLoopEnd127

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop127

LClosureEnvExtend_ParamsLoopEnd127:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End127:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode127)
pop rbx
jmp LClosureCont127
LClosureCode127:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #128: (begin (set! VarParam(normalize, 0) Box(VarParam(normalize, 0)))  (set! VarFree(+) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(*) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(/) ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7))))))
;; Starting: Item 0 in Seq statement #128
;; Starting: Set VarParam(name=normalize, minor=0) with Box(VarParam(normalize, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=normalize, minor=0) with Box(VarParam(normalize, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(normalize, 0)
;; Starting: Get VarParam(name=normalize, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=normalize, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(normalize, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=normalize, minor=0) with Box(VarParam(normalize, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=normalize, minor=0) with Box(VarParam(normalize, 0))

;; Finished: Item 0 in Seq statement #128


;; Starting: Item 1 in Seq statement #128
;; Starting: Set fvar + to (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0))))))
;; Starting: Creating CLOSURE of LambdaSimple#129 -> (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0))))))
push rbx
; Env Extend Code Section For Closure#129
mov rbx, 7 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend129
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End129

LClosureEnvExtend129:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 6
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 56
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop129:
  jz LClosureEnvExtend_LoopEnd129
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop129

LClosureEnvExtend_LoopEnd129:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd129
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop129:
  jz LClosureEnvExtend_ParamsLoopEnd129

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop129

LClosureEnvExtend_ParamsLoopEnd129:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End129:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode129)
pop rbx
jmp LClosureCont129
LClosureCode129:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #130: (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0)))))
;; Starting: Item 0 in Seq statement #130
;; Starting: Set VarParam(name=x, minor=0) with Box(VarParam(x, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=x, minor=0) with Box(VarParam(x, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(x, 0)
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(x, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=x, minor=0) with Box(VarParam(x, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=x, minor=0) with Box(VarParam(x, 0))

;; Finished: Item 0 in Seq statement #130


;; Starting: Item 1 in Seq statement #130
;; Starting: Perform Applic#131 of: (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0))))
;; Starting: Argument 0 of Applic statement #131
;; Starting: Perform Applic#132 of: (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0)))
;; Starting: Argument 2 of Applic statement #132
;; Starting: BoxGet of VarParam(x, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(x, 0)

;; Finished: Argument 2 of Applic statement #132

push rax ; Push argument to stack;; Starting: Argument 1 of Applic statement #132
mov rax, const_tbl+34	; mov const 0/1 to rax
;; Finished: Argument 1 of Applic statement #132

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #132
;; Starting: Perform Applic#133 of: (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))
;; Starting: Argument 0 of Applic statement #133
;; Starting: BoxGet of VarBound(_+, 2, 5)
;; Starting: Evaluating val for [ BoxGet of VarBound(_+, 2, 5) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=_+, major=2, minor=5)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 5]
;; Finished: Get VarBound(name=_+, major=2, minor=5)

;; Finished: Evaluating val for [ BoxGet of VarBound(_+, 2, 5) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(_+, 2, 5)

;; Finished: Argument 0 of Applic statement #133

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #133)
;; Starting: BoxGet of VarBound(^numeric-op-dispatcher, 1, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(^numeric-op-dispatcher, 1, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=^numeric-op-dispatcher, major=1, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=^numeric-op-dispatcher, major=1, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(^numeric-op-dispatcher, 1, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(^numeric-op-dispatcher, 1, 0)

;; Finished: Evaluating proc to apply (in Applic #133)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic133
int 3
ContinueApplic133:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #133
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#133 of: (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))

;; Finished: Argument 0 of Applic statement #132

push rax ; Push argument to stack
push qword 3 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #132)
;; Starting: BoxGet of VarBound(fold-left, 2, 3)
;; Starting: Evaluating val for [ BoxGet of VarBound(fold-left, 2, 3) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=fold-left, major=2, minor=3)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 3]
;; Finished: Get VarBound(name=fold-left, major=2, minor=3)

;; Finished: Evaluating val for [ BoxGet of VarBound(fold-left, 2, 3) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(fold-left, 2, 3)

;; Finished: Evaluating proc to apply (in Applic #132)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic132
int 3
ContinueApplic132:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #132
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#132 of: (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0)))

;; Finished: Argument 0 of Applic statement #131

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #131)
;; Starting: BoxGet of VarBound(normalize, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(normalize, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=normalize, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=normalize, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(normalize, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(normalize, 0, 0)

;; Finished: Evaluating proc to apply (in Applic #131)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic131
int 3
ContinueApplic131:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #131
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#131 of: (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0))))

;; Finished: Item 1 in Seq statement #130

;; Finished: Seq statement #130: (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0)))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont129:

;; Finished: Creating CLOSURE of LambdaSimple#129 -> (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0))))))

mov qword [fvar_tbl+8*15], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar + to (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0))))))

;; Finished: Item 1 in Seq statement #128


;; Starting: Item 2 in Seq statement #128
;; Starting: Set fvar * to (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0))))))
;; Starting: Creating CLOSURE of LambdaSimple#134 -> (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0))))))
push rbx
; Env Extend Code Section For Closure#134
mov rbx, 8 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend134
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End134

LClosureEnvExtend134:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 7
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 64
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop134:
  jz LClosureEnvExtend_LoopEnd134
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop134

LClosureEnvExtend_LoopEnd134:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd134
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop134:
  jz LClosureEnvExtend_ParamsLoopEnd134

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop134

LClosureEnvExtend_ParamsLoopEnd134:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End134:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode134)
pop rbx
jmp LClosureCont134
LClosureCode134:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #135: (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0)))))
;; Starting: Item 0 in Seq statement #135
;; Starting: Set VarParam(name=x, minor=0) with Box(VarParam(x, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=x, minor=0) with Box(VarParam(x, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(x, 0)
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(x, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=x, minor=0) with Box(VarParam(x, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=x, minor=0) with Box(VarParam(x, 0))

;; Finished: Item 0 in Seq statement #135


;; Starting: Item 1 in Seq statement #135
;; Starting: Perform Applic#136 of: (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0))))
;; Starting: Argument 0 of Applic statement #136
;; Starting: Perform Applic#137 of: (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0)))
;; Starting: Argument 2 of Applic statement #137
;; Starting: BoxGet of VarParam(x, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(x, 0)

;; Finished: Argument 2 of Applic statement #137

push rax ; Push argument to stack;; Starting: Argument 1 of Applic statement #137
mov rax, const_tbl+51	; mov const 1/1 to rax
;; Finished: Argument 1 of Applic statement #137

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #137
;; Starting: Perform Applic#138 of: (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))
;; Starting: Argument 0 of Applic statement #138
;; Starting: BoxGet of VarBound(_*, 2, 6)
;; Starting: Evaluating val for [ BoxGet of VarBound(_*, 2, 6) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=_*, major=2, minor=6)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 6]
;; Finished: Get VarBound(name=_*, major=2, minor=6)

;; Finished: Evaluating val for [ BoxGet of VarBound(_*, 2, 6) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(_*, 2, 6)

;; Finished: Argument 0 of Applic statement #138

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #138)
;; Starting: BoxGet of VarBound(^numeric-op-dispatcher, 1, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(^numeric-op-dispatcher, 1, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=^numeric-op-dispatcher, major=1, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=^numeric-op-dispatcher, major=1, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(^numeric-op-dispatcher, 1, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(^numeric-op-dispatcher, 1, 0)

;; Finished: Evaluating proc to apply (in Applic #138)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic138
int 3
ContinueApplic138:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #138
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#138 of: (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))

;; Finished: Argument 0 of Applic statement #137

push rax ; Push argument to stack
push qword 3 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #137)
;; Starting: BoxGet of VarBound(fold-left, 2, 3)
;; Starting: Evaluating val for [ BoxGet of VarBound(fold-left, 2, 3) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=fold-left, major=2, minor=3)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 3]
;; Finished: Get VarBound(name=fold-left, major=2, minor=3)

;; Finished: Evaluating val for [ BoxGet of VarBound(fold-left, 2, 3) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(fold-left, 2, 3)

;; Finished: Evaluating proc to apply (in Applic #137)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic137
int 3
ContinueApplic137:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #137
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#137 of: (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0)))

;; Finished: Argument 0 of Applic statement #136

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #136)
;; Starting: BoxGet of VarBound(normalize, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(normalize, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=normalize, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=normalize, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(normalize, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(normalize, 0, 0)

;; Finished: Evaluating proc to apply (in Applic #136)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic136
int 3
ContinueApplic136:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #136
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#136 of: (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0))))

;; Finished: Item 1 in Seq statement #135

;; Finished: Seq statement #135: (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0)))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont134:

;; Finished: Creating CLOSURE of LambdaSimple#134 -> (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0))))))

mov qword [fvar_tbl+8*16], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar * to (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0))))))

;; Finished: Item 2 in Seq statement #128


;; Starting: Item 3 in Seq statement #128
;; Starting: Set fvar / to ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7))))
;; Starting: Perform Applic#139 of: ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7))))
;; Starting: Argument 0 of Applic statement #139
;; Starting: Perform Applic#140 of: (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7)))
;; Starting: Argument 0 of Applic statement #140
;; Starting: BoxGet of VarBound(_/, 1, 7)
;; Starting: Evaluating val for [ BoxGet of VarBound(_/, 1, 7) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=_/, major=1, minor=7)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 7]
;; Finished: Get VarBound(name=_/, major=1, minor=7)

;; Finished: Evaluating val for [ BoxGet of VarBound(_/, 1, 7) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(_/, 1, 7)

;; Finished: Argument 0 of Applic statement #140

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #140)
;; Starting: BoxGet of VarBound(^numeric-op-dispatcher, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(^numeric-op-dispatcher, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=^numeric-op-dispatcher, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=^numeric-op-dispatcher, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(^numeric-op-dispatcher, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(^numeric-op-dispatcher, 0, 0)

;; Finished: Evaluating proc to apply (in Applic #140)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic140
int 3
ContinueApplic140:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #140
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#140 of: (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7)))

;; Finished: Argument 0 of Applic statement #139

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #139)
;; Starting: Creating CLOSURE of LambdaSimple#141 -> (lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1)))))))))
push rbx
; Env Extend Code Section For Closure#141
mov rbx, 9 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend141
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End141

LClosureEnvExtend141:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 8
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 72
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop141:
  jz LClosureEnvExtend_LoopEnd141
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop141

LClosureEnvExtend_LoopEnd141:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd141
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop141:
  jz LClosureEnvExtend_ParamsLoopEnd141

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop141

LClosureEnvExtend_ParamsLoopEnd141:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End141:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode141)
pop rbx
jmp LClosureCont141
LClosureCode141:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #142: (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))
;; Starting: Item 0 in Seq statement #142
;; Starting: Set VarParam(name=/, minor=0) with Box(VarParam(/, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=/, minor=0) with Box(VarParam(/, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(/, 0)
;; Starting: Get VarParam(name=/, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=/, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(/, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=/, minor=0) with Box(VarParam(/, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=/, minor=0) with Box(VarParam(/, 0))

;; Finished: Item 0 in Seq statement #142


;; Starting: Item 1 in Seq statement #142

;; Finished: Item 1 in Seq statement #142

;; Finished: Seq statement #142: (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont141:

;; Finished: Creating CLOSURE of LambdaSimple#141 -> (lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1)))))))))

;; Finished: Evaluating proc to apply (in Applic #139)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic139
int 3
ContinueApplic139:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #139
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#139 of: ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7))))

mov qword [fvar_tbl+8*17], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar / to ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7))))

;; Finished: Item 3 in Seq statement #128

;; Finished: Seq statement #128: (begin (set! VarParam(normalize, 0) Box(VarParam(normalize, 0)))  (set! VarFree(+) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(*) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(/) ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7))))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont127:

;; Finished: Creating CLOSURE of LambdaSimple#127 -> (lambda (normalize) (begin (set! VarParam(normalize, 0) Box(VarParam(normalize, 0)))  (set! VarFree(+) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(*) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(/) ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7)))))))

;; Finished: Evaluating proc to apply (in Applic #111)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic111
int 3
ContinueApplic111:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #111
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#111 of: ((lambda (normalize) (begin (set! VarParam(normalize, 0) Box(VarParam(normalize, 0)))  (set! VarFree(+) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(*) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(/) ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7))))))) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) BoxGet(VarParam(x, 0)) ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0)))))))))

;; Finished: Item 1 in Seq statement #110


;; Starting: Item 2 in Seq statement #110
;; Starting: Perform Applic#143 of: ((lambda (^comparator) (begin (set! VarParam(^comparator, 0) Box(VarParam(^comparator, 0)))  (set! VarFree(=) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8)))))  (set! VarFree(<) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 2, 3)) (lambda (a b) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(b, 1) Box(VarParam(b, 1)))  (if BoxGet(VarParam(a, 0)) BoxGet(VarParam(b, 1)) #f)))  #t  (BoxGet(VarBound(map, 2, 4)) (lambda (y) (begin (set! VarParam(y, 0) Box(VarParam(y, 0)))  (BoxGet(VarBound(op, 1, 0)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 0)))))  BoxGet(VarParam(ys, 1)))))))))
;; Starting: Argument 0 of Applic statement #143
;; Starting: Creating CLOSURE of LambdaSimple#144 -> (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 2, 3)) (lambda (a b) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(b, 1) Box(VarParam(b, 1)))  (if BoxGet(VarParam(a, 0)) BoxGet(VarParam(b, 1)) #f)))  #t  (BoxGet(VarBound(map, 2, 4)) (lambda (y) (begin (set! VarParam(y, 0) Box(VarParam(y, 0)))  (BoxGet(VarBound(op, 1, 0)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 0)))))  BoxGet(VarParam(ys, 1))))))))
push rbx
; Env Extend Code Section For Closure#144
mov rbx, 10 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend144
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End144

LClosureEnvExtend144:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 9
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 80
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop144:
  jz LClosureEnvExtend_LoopEnd144
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop144

LClosureEnvExtend_LoopEnd144:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd144
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop144:
  jz LClosureEnvExtend_ParamsLoopEnd144

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop144

LClosureEnvExtend_ParamsLoopEnd144:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End144:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode144)
pop rbx
jmp LClosureCont144
LClosureCode144:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #145: (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 2, 3)) (lambda (a b) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(b, 1) Box(VarParam(b, 1)))  (if BoxGet(VarParam(a, 0)) BoxGet(VarParam(b, 1)) #f)))  #t  (BoxGet(VarBound(map, 2, 4)) (lambda (y) (begin (set! VarParam(y, 0) Box(VarParam(y, 0)))  (BoxGet(VarBound(op, 1, 0)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 0)))))  BoxGet(VarParam(ys, 1)))))))
;; Starting: Item 0 in Seq statement #145
;; Starting: Set VarParam(name=op, minor=0) with Box(VarParam(op, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=op, minor=0) with Box(VarParam(op, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(op, 0)
;; Starting: Get VarParam(name=op, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=op, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(op, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=op, minor=0) with Box(VarParam(op, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=op, minor=0) with Box(VarParam(op, 0))

;; Finished: Item 0 in Seq statement #145


;; Starting: Item 1 in Seq statement #145

;; Finished: Item 1 in Seq statement #145

;; Finished: Seq statement #145: (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 2, 3)) (lambda (a b) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(b, 1) Box(VarParam(b, 1)))  (if BoxGet(VarParam(a, 0)) BoxGet(VarParam(b, 1)) #f)))  #t  (BoxGet(VarBound(map, 2, 4)) (lambda (y) (begin (set! VarParam(y, 0) Box(VarParam(y, 0)))  (BoxGet(VarBound(op, 1, 0)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 0)))))  BoxGet(VarParam(ys, 1)))))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont144:

;; Finished: Creating CLOSURE of LambdaSimple#144 -> (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 2, 3)) (lambda (a b) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(b, 1) Box(VarParam(b, 1)))  (if BoxGet(VarParam(a, 0)) BoxGet(VarParam(b, 1)) #f)))  #t  (BoxGet(VarBound(map, 2, 4)) (lambda (y) (begin (set! VarParam(y, 0) Box(VarParam(y, 0)))  (BoxGet(VarBound(op, 1, 0)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 0)))))  BoxGet(VarParam(ys, 1))))))))

;; Finished: Argument 0 of Applic statement #143

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #143)
;; Starting: Creating CLOSURE of LambdaSimple#146 -> (lambda (^comparator) (begin (set! VarParam(^comparator, 0) Box(VarParam(^comparator, 0)))  (set! VarFree(=) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8)))))  (set! VarFree(<) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9)))))))
push rbx
; Env Extend Code Section For Closure#146
mov rbx, 11 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend146
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End146

LClosureEnvExtend146:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 10
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 88
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop146:
  jz LClosureEnvExtend_LoopEnd146
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop146

LClosureEnvExtend_LoopEnd146:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd146
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop146:
  jz LClosureEnvExtend_ParamsLoopEnd146

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop146

LClosureEnvExtend_ParamsLoopEnd146:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End146:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode146)
pop rbx
jmp LClosureCont146
LClosureCode146:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #147: (begin (set! VarParam(^comparator, 0) Box(VarParam(^comparator, 0)))  (set! VarFree(=) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8)))))  (set! VarFree(<) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9))))))
;; Starting: Item 0 in Seq statement #147
;; Starting: Set VarParam(name=^comparator, minor=0) with Box(VarParam(^comparator, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=^comparator, minor=0) with Box(VarParam(^comparator, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(^comparator, 0)
;; Starting: Get VarParam(name=^comparator, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=^comparator, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(^comparator, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=^comparator, minor=0) with Box(VarParam(^comparator, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=^comparator, minor=0) with Box(VarParam(^comparator, 0))

;; Finished: Item 0 in Seq statement #147


;; Starting: Item 1 in Seq statement #147
;; Starting: Set fvar = to (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8))))
;; Starting: Perform Applic#148 of: (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8))))
;; Starting: Argument 0 of Applic statement #148
;; Starting: Perform Applic#149 of: (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8)))
;; Starting: Argument 0 of Applic statement #149
;; Starting: BoxGet of VarBound(_=, 1, 8)
;; Starting: Evaluating val for [ BoxGet of VarBound(_=, 1, 8) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=_=, major=1, minor=8)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 8]
;; Finished: Get VarBound(name=_=, major=1, minor=8)

;; Finished: Evaluating val for [ BoxGet of VarBound(_=, 1, 8) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(_=, 1, 8)

;; Finished: Argument 0 of Applic statement #149

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #149)
;; Starting: BoxGet of VarBound(^numeric-op-dispatcher, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(^numeric-op-dispatcher, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=^numeric-op-dispatcher, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=^numeric-op-dispatcher, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(^numeric-op-dispatcher, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(^numeric-op-dispatcher, 0, 0)

;; Finished: Evaluating proc to apply (in Applic #149)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic149
int 3
ContinueApplic149:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #149
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#149 of: (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8)))

;; Finished: Argument 0 of Applic statement #148

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #148)
;; Starting: BoxGet of VarParam(^comparator, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(^comparator, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=^comparator, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=^comparator, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(^comparator, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(^comparator, 0)

;; Finished: Evaluating proc to apply (in Applic #148)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic148
int 3
ContinueApplic148:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #148
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#148 of: (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8))))

mov qword [fvar_tbl+8*21], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar = to (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8))))

;; Finished: Item 1 in Seq statement #147


;; Starting: Item 2 in Seq statement #147
;; Starting: Set fvar < to (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9))))
;; Starting: Perform Applic#150 of: (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9))))
;; Starting: Argument 0 of Applic statement #150
;; Starting: Perform Applic#151 of: (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9)))
;; Starting: Argument 0 of Applic statement #151
;; Starting: BoxGet of VarBound(_<, 1, 9)
;; Starting: Evaluating val for [ BoxGet of VarBound(_<, 1, 9) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=_<, major=1, minor=9)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 9]
;; Finished: Get VarBound(name=_<, major=1, minor=9)

;; Finished: Evaluating val for [ BoxGet of VarBound(_<, 1, 9) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(_<, 1, 9)

;; Finished: Argument 0 of Applic statement #151

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #151)
;; Starting: BoxGet of VarBound(^numeric-op-dispatcher, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(^numeric-op-dispatcher, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=^numeric-op-dispatcher, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=^numeric-op-dispatcher, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(^numeric-op-dispatcher, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(^numeric-op-dispatcher, 0, 0)

;; Finished: Evaluating proc to apply (in Applic #151)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic151
int 3
ContinueApplic151:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #151
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#151 of: (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9)))

;; Finished: Argument 0 of Applic statement #150

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #150)
;; Starting: BoxGet of VarParam(^comparator, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(^comparator, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=^comparator, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=^comparator, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(^comparator, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(^comparator, 0)

;; Finished: Evaluating proc to apply (in Applic #150)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic150
int 3
ContinueApplic150:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #150
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#150 of: (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9))))

mov qword [fvar_tbl+8*22], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar < to (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9))))

;; Finished: Item 2 in Seq statement #147

;; Finished: Seq statement #147: (begin (set! VarParam(^comparator, 0) Box(VarParam(^comparator, 0)))  (set! VarFree(=) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8)))))  (set! VarFree(<) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9))))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont146:

;; Finished: Creating CLOSURE of LambdaSimple#146 -> (lambda (^comparator) (begin (set! VarParam(^comparator, 0) Box(VarParam(^comparator, 0)))  (set! VarFree(=) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8)))))  (set! VarFree(<) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9)))))))

;; Finished: Evaluating proc to apply (in Applic #143)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic143
int 3
ContinueApplic143:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #143
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#143 of: ((lambda (^comparator) (begin (set! VarParam(^comparator, 0) Box(VarParam(^comparator, 0)))  (set! VarFree(=) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8)))))  (set! VarFree(<) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 2, 3)) (lambda (a b) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(b, 1) Box(VarParam(b, 1)))  (if BoxGet(VarParam(a, 0)) BoxGet(VarParam(b, 1)) #f)))  #t  (BoxGet(VarBound(map, 2, 4)) (lambda (y) (begin (set! VarParam(y, 0) Box(VarParam(y, 0)))  (BoxGet(VarBound(op, 1, 0)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 0)))))  BoxGet(VarParam(ys, 1)))))))))

;; Finished: Item 2 in Seq statement #110

;; Finished: Seq statement #110: (begin (set! VarParam(^numeric-op-dispatcher, 0) Box(VarParam(^numeric-op-dispatcher, 0)))  ((lambda (normalize) (begin (set! VarParam(normalize, 0) Box(VarParam(normalize, 0)))  (set! VarFree(+) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(*) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(/) ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7))))))) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) BoxGet(VarParam(x, 0)) ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0)))))))))  ((lambda (^comparator) (begin (set! VarParam(^comparator, 0) Box(VarParam(^comparator, 0)))  (set! VarFree(=) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8)))))  (set! VarFree(<) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 2, 3)) (lambda (a b) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(b, 1) Box(VarParam(b, 1)))  (if BoxGet(VarParam(a, 0)) BoxGet(VarParam(b, 1)) #f)))  #t  (BoxGet(VarBound(map, 2, 4)) (lambda (y) (begin (set! VarParam(y, 0) Box(VarParam(y, 0)))  (BoxGet(VarBound(op, 1, 0)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 0)))))  BoxGet(VarParam(ys, 1))))))))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont109:

;; Finished: Creating CLOSURE of LambdaSimple#109 -> (lambda (^numeric-op-dispatcher) (begin (set! VarParam(^numeric-op-dispatcher, 0) Box(VarParam(^numeric-op-dispatcher, 0)))  ((lambda (normalize) (begin (set! VarParam(normalize, 0) Box(VarParam(normalize, 0)))  (set! VarFree(+) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(*) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(/) ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7))))))) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) BoxGet(VarParam(x, 0)) ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0)))))))))  ((lambda (^comparator) (begin (set! VarParam(^comparator, 0) Box(VarParam(^comparator, 0)))  (set! VarFree(=) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8)))))  (set! VarFree(<) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 2, 3)) (lambda (a b) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(b, 1) Box(VarParam(b, 1)))  (if BoxGet(VarParam(a, 0)) BoxGet(VarParam(b, 1)) #f)))  #t  (BoxGet(VarBound(map, 2, 4)) (lambda (y) (begin (set! VarParam(y, 0) Box(VarParam(y, 0)))  (BoxGet(VarBound(op, 1, 0)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 0)))))  BoxGet(VarParam(ys, 1)))))))))))

;; Finished: Evaluating proc to apply (in Applic #91)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic91
int 3
ContinueApplic91:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #91
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#91 of: ((lambda (^numeric-op-dispatcher) (begin (set! VarParam(^numeric-op-dispatcher, 0) Box(VarParam(^numeric-op-dispatcher, 0)))  ((lambda (normalize) (begin (set! VarParam(normalize, 0) Box(VarParam(normalize, 0)))  (set! VarFree(+) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(*) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(/) ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7))))))) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) BoxGet(VarParam(x, 0)) ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0)))))))))  ((lambda (^comparator) (begin (set! VarParam(^comparator, 0) Box(VarParam(^comparator, 0)))  (set! VarFree(=) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8)))))  (set! VarFree(<) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 2, 3)) (lambda (a b) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(b, 1) Box(VarParam(b, 1)))  (if BoxGet(VarParam(a, 0)) BoxGet(VarParam(b, 1)) #f)))  #t  (BoxGet(VarBound(map, 2, 4)) (lambda (y) (begin (set! VarParam(y, 0) Box(VarParam(y, 0)))  (BoxGet(VarBound(op, 1, 0)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 0)))))  BoxGet(VarParam(ys, 1))))))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1)))) (if (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1))) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))))

;; Finished: Item 13 in Seq statement #90

;; Finished: Seq statement #90: (begin (set! VarParam(flonum?, 0) Box(VarParam(flonum?, 0)))  (set! VarParam(rational?, 1) Box(VarParam(rational?, 1)))  (set! VarParam(exact->inexact, 2) Box(VarParam(exact->inexact, 2)))  (set! VarParam(fold-left, 3) Box(VarParam(fold-left, 3)))  (set! VarParam(map, 4) Box(VarParam(map, 4)))  (set! VarParam(_+, 5) Box(VarParam(_+, 5)))  (set! VarParam(_*, 6) Box(VarParam(_*, 6)))  (set! VarParam(_/, 7) Box(VarParam(_/, 7)))  (set! VarParam(_=, 8) Box(VarParam(_=, 8)))  (set! VarParam(_<, 9) Box(VarParam(_<, 9)))  (set! VarParam(car, 10) Box(VarParam(car, 10)))  (set! VarParam(cdr, 11) Box(VarParam(cdr, 11)))  (set! VarParam(null?, 12) Box(VarParam(null?, 12)))  ((lambda (^numeric-op-dispatcher) (begin (set! VarParam(^numeric-op-dispatcher, 0) Box(VarParam(^numeric-op-dispatcher, 0)))  ((lambda (normalize) (begin (set! VarParam(normalize, 0) Box(VarParam(normalize, 0)))  (set! VarFree(+) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(*) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(/) ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7))))))) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) BoxGet(VarParam(x, 0)) ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0)))))))))  ((lambda (^comparator) (begin (set! VarParam(^comparator, 0) Box(VarParam(^comparator, 0)))  (set! VarFree(=) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8)))))  (set! VarFree(<) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 2, 3)) (lambda (a b) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(b, 1) Box(VarParam(b, 1)))  (if BoxGet(VarParam(a, 0)) BoxGet(VarParam(b, 1)) #f)))  #t  (BoxGet(VarBound(map, 2, 4)) (lambda (y) (begin (set! VarParam(y, 0) Box(VarParam(y, 0)))  (BoxGet(VarBound(op, 1, 0)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 0)))))  BoxGet(VarParam(ys, 1))))))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1)))) (if (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1))) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1)))))))))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont89:

;; Finished: Creating CLOSURE of LambdaSimple#89 -> (lambda (flonum? rational? exact->inexact fold-left map _+ _* _/ _= _< car cdr null?) (begin (set! VarParam(flonum?, 0) Box(VarParam(flonum?, 0)))  (set! VarParam(rational?, 1) Box(VarParam(rational?, 1)))  (set! VarParam(exact->inexact, 2) Box(VarParam(exact->inexact, 2)))  (set! VarParam(fold-left, 3) Box(VarParam(fold-left, 3)))  (set! VarParam(map, 4) Box(VarParam(map, 4)))  (set! VarParam(_+, 5) Box(VarParam(_+, 5)))  (set! VarParam(_*, 6) Box(VarParam(_*, 6)))  (set! VarParam(_/, 7) Box(VarParam(_/, 7)))  (set! VarParam(_=, 8) Box(VarParam(_=, 8)))  (set! VarParam(_<, 9) Box(VarParam(_<, 9)))  (set! VarParam(car, 10) Box(VarParam(car, 10)))  (set! VarParam(cdr, 11) Box(VarParam(cdr, 11)))  (set! VarParam(null?, 12) Box(VarParam(null?, 12)))  ((lambda (^numeric-op-dispatcher) (begin (set! VarParam(^numeric-op-dispatcher, 0) Box(VarParam(^numeric-op-dispatcher, 0)))  ((lambda (normalize) (begin (set! VarParam(normalize, 0) Box(VarParam(normalize, 0)))  (set! VarFree(+) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(*) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(/) ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7))))))) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) BoxGet(VarParam(x, 0)) ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0)))))))))  ((lambda (^comparator) (begin (set! VarParam(^comparator, 0) Box(VarParam(^comparator, 0)))  (set! VarFree(=) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8)))))  (set! VarFree(<) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 2, 3)) (lambda (a b) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(b, 1) Box(VarParam(b, 1)))  (if BoxGet(VarParam(a, 0)) BoxGet(VarParam(b, 1)) #f)))  #t  (BoxGet(VarBound(map, 2, 4)) (lambda (y) (begin (set! VarParam(y, 0) Box(VarParam(y, 0)))  (BoxGet(VarBound(op, 1, 0)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 0)))))  BoxGet(VarParam(ys, 1))))))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1)))) (if (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1))) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))))))

;; Finished: Evaluating proc to apply (in Applic #88)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic88
int 3
ContinueApplic88:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #88
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#88 of: ((lambda (flonum? rational? exact->inexact fold-left map _+ _* _/ _= _< car cdr null?) (begin (set! VarParam(flonum?, 0) Box(VarParam(flonum?, 0)))  (set! VarParam(rational?, 1) Box(VarParam(rational?, 1)))  (set! VarParam(exact->inexact, 2) Box(VarParam(exact->inexact, 2)))  (set! VarParam(fold-left, 3) Box(VarParam(fold-left, 3)))  (set! VarParam(map, 4) Box(VarParam(map, 4)))  (set! VarParam(_+, 5) Box(VarParam(_+, 5)))  (set! VarParam(_*, 6) Box(VarParam(_*, 6)))  (set! VarParam(_/, 7) Box(VarParam(_/, 7)))  (set! VarParam(_=, 8) Box(VarParam(_=, 8)))  (set! VarParam(_<, 9) Box(VarParam(_<, 9)))  (set! VarParam(car, 10) Box(VarParam(car, 10)))  (set! VarParam(cdr, 11) Box(VarParam(cdr, 11)))  (set! VarParam(null?, 12) Box(VarParam(null?, 12)))  ((lambda (^numeric-op-dispatcher) (begin (set! VarParam(^numeric-op-dispatcher, 0) Box(VarParam(^numeric-op-dispatcher, 0)))  ((lambda (normalize) (begin (set! VarParam(normalize, 0) Box(VarParam(normalize, 0)))  (set! VarFree(+) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(*) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(/) ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7))))))) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) BoxGet(VarParam(x, 0)) ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0)))))))))  ((lambda (^comparator) (begin (set! VarParam(^comparator, 0) Box(VarParam(^comparator, 0)))  (set! VarFree(=) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8)))))  (set! VarFree(<) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 2, 3)) (lambda (a b) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(b, 1) Box(VarParam(b, 1)))  (if BoxGet(VarParam(a, 0)) BoxGet(VarParam(b, 1)) #f)))  #t  (BoxGet(VarBound(map, 2, 4)) (lambda (y) (begin (set! VarParam(y, 0) Box(VarParam(y, 0)))  (BoxGet(VarBound(op, 1, 0)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 0)))))  BoxGet(VarParam(ys, 1))))))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1)))) (if (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1))) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1)))))))))))) VarFree(flonum?)  VarFree(rational?)  VarFree(exact->inexact)  VarFree(fold-left)  VarFree(map)  VarFree(+)  VarFree(*)  VarFree(/)  VarFree(=)  VarFree(<)  VarFree(car)  VarFree(cdr)  VarFree(null?))

	call write_sob_if_not_void

;; Starting: Set fvar - to ((lambda (apply + null?) (begin (set! VarParam(apply, 0) Box(VarParam(apply, 0)))  (set! VarParam(+, 1) Box(VarParam(+, 1)))  (set! VarParam(null?, 2) Box(VarParam(null?, 2)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 0, 2)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(+, 0, 1)) 0/1  (VarFree(*) -1/1  BoxGet(VarParam(x, 0)))) (BoxGet(VarBound(+, 0, 1)) BoxGet(VarParam(x, 0))  (VarFree(*) -1/1  (BoxGet(VarBound(apply, 0, 0)) BoxGet(VarBound(+, 0, 1))  BoxGet(VarParam(y, 1)))))))))) VarFree(apply)  VarFree(+)  VarFree(null?))
;; Starting: Perform Applic#152 of: ((lambda (apply + null?) (begin (set! VarParam(apply, 0) Box(VarParam(apply, 0)))  (set! VarParam(+, 1) Box(VarParam(+, 1)))  (set! VarParam(null?, 2) Box(VarParam(null?, 2)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 0, 2)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(+, 0, 1)) 0/1  (VarFree(*) -1/1  BoxGet(VarParam(x, 0)))) (BoxGet(VarBound(+, 0, 1)) BoxGet(VarParam(x, 0))  (VarFree(*) -1/1  (BoxGet(VarBound(apply, 0, 0)) BoxGet(VarBound(+, 0, 1))  BoxGet(VarParam(y, 1)))))))))) VarFree(apply)  VarFree(+)  VarFree(null?))
;; Starting: Argument 2 of Applic statement #152
mov rax, qword [fvar_tbl+8*1]	; mov fvar null? to rax
;; Finished: Argument 2 of Applic statement #152

push rax ; Push argument to stack;; Starting: Argument 1 of Applic statement #152
mov rax, qword [fvar_tbl+8*15]	; mov fvar + to rax
;; Finished: Argument 1 of Applic statement #152

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #152
mov rax, qword [fvar_tbl+8*5]	; mov fvar apply to rax
;; Finished: Argument 0 of Applic statement #152

push rax ; Push argument to stack
push qword 3 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #152)
;; Starting: Creating CLOSURE of LambdaSimple#153 -> (lambda (apply + null?) (begin (set! VarParam(apply, 0) Box(VarParam(apply, 0)))  (set! VarParam(+, 1) Box(VarParam(+, 1)))  (set! VarParam(null?, 2) Box(VarParam(null?, 2)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 0, 2)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(+, 0, 1)) 0/1  (VarFree(*) -1/1  BoxGet(VarParam(x, 0)))) (BoxGet(VarBound(+, 0, 1)) BoxGet(VarParam(x, 0))  (VarFree(*) -1/1  (BoxGet(VarBound(apply, 0, 0)) BoxGet(VarBound(+, 0, 1))  BoxGet(VarParam(y, 1))))))))))
push rbx
; Env Extend Code Section For Closure#153
mov rbx, 0 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend153
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End153

LClosureEnvExtend153:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, -1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 0
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop153:
  jz LClosureEnvExtend_LoopEnd153
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop153

LClosureEnvExtend_LoopEnd153:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd153
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop153:
  jz LClosureEnvExtend_ParamsLoopEnd153

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop153

LClosureEnvExtend_ParamsLoopEnd153:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End153:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode153)
pop rbx
jmp LClosureCont153
LClosureCode153:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #154: (begin (set! VarParam(apply, 0) Box(VarParam(apply, 0)))  (set! VarParam(+, 1) Box(VarParam(+, 1)))  (set! VarParam(null?, 2) Box(VarParam(null?, 2)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 0, 2)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(+, 0, 1)) 0/1  (VarFree(*) -1/1  BoxGet(VarParam(x, 0)))) (BoxGet(VarBound(+, 0, 1)) BoxGet(VarParam(x, 0))  (VarFree(*) -1/1  (BoxGet(VarBound(apply, 0, 0)) BoxGet(VarBound(+, 0, 1))  BoxGet(VarParam(y, 1)))))))))
;; Starting: Item 0 in Seq statement #154
;; Starting: Set VarParam(name=apply, minor=0) with Box(VarParam(apply, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=apply, minor=0) with Box(VarParam(apply, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(apply, 0)
;; Starting: Get VarParam(name=apply, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=apply, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(apply, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=apply, minor=0) with Box(VarParam(apply, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=apply, minor=0) with Box(VarParam(apply, 0))

;; Finished: Item 0 in Seq statement #154


;; Starting: Item 1 in Seq statement #154
;; Starting: Set VarParam(name=+, minor=1) with Box(VarParam(+, 1))
;; Starting: Evaluating rhs for [ Set VarParam(name=+, minor=1) with Box(VarParam(+, 1)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(+, 1)
;; Starting: Get VarParam(name=+, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=+, minor=1)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(+, 1)

;; Finished: Evaluating rhs for [ Set VarParam(name=+, minor=1) with Box(VarParam(+, 1)) ], value is expected in rax

mov PVAR(1), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=+, minor=1) with Box(VarParam(+, 1))

;; Finished: Item 1 in Seq statement #154


;; Starting: Item 2 in Seq statement #154
;; Starting: Set VarParam(name=null?, minor=2) with Box(VarParam(null?, 2))
;; Starting: Evaluating rhs for [ Set VarParam(name=null?, minor=2) with Box(VarParam(null?, 2)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(null?, 2)
;; Starting: Get VarParam(name=null?, minor=2)
mov rax, PVAR(2)
;; Finished: Get VarParam(name=null?, minor=2)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(null?, 2)

;; Finished: Evaluating rhs for [ Set VarParam(name=null?, minor=2) with Box(VarParam(null?, 2)) ], value is expected in rax

mov PVAR(2), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=null?, minor=2) with Box(VarParam(null?, 2))

;; Finished: Item 2 in Seq statement #154


;; Starting: Item 3 in Seq statement #154

;; Finished: Item 3 in Seq statement #154

;; Finished: Seq statement #154: (begin (set! VarParam(apply, 0) Box(VarParam(apply, 0)))  (set! VarParam(+, 1) Box(VarParam(+, 1)))  (set! VarParam(null?, 2) Box(VarParam(null?, 2)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 0, 2)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(+, 0, 1)) 0/1  (VarFree(*) -1/1  BoxGet(VarParam(x, 0)))) (BoxGet(VarBound(+, 0, 1)) BoxGet(VarParam(x, 0))  (VarFree(*) -1/1  (BoxGet(VarBound(apply, 0, 0)) BoxGet(VarBound(+, 0, 1))  BoxGet(VarParam(y, 1)))))))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont153:

;; Finished: Creating CLOSURE of LambdaSimple#153 -> (lambda (apply + null?) (begin (set! VarParam(apply, 0) Box(VarParam(apply, 0)))  (set! VarParam(+, 1) Box(VarParam(+, 1)))  (set! VarParam(null?, 2) Box(VarParam(null?, 2)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 0, 2)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(+, 0, 1)) 0/1  (VarFree(*) -1/1  BoxGet(VarParam(x, 0)))) (BoxGet(VarBound(+, 0, 1)) BoxGet(VarParam(x, 0))  (VarFree(*) -1/1  (BoxGet(VarBound(apply, 0, 0)) BoxGet(VarBound(+, 0, 1))  BoxGet(VarParam(y, 1))))))))))

;; Finished: Evaluating proc to apply (in Applic #152)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic152
int 3
ContinueApplic152:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #152
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#152 of: ((lambda (apply + null?) (begin (set! VarParam(apply, 0) Box(VarParam(apply, 0)))  (set! VarParam(+, 1) Box(VarParam(+, 1)))  (set! VarParam(null?, 2) Box(VarParam(null?, 2)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 0, 2)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(+, 0, 1)) 0/1  (VarFree(*) -1/1  BoxGet(VarParam(x, 0)))) (BoxGet(VarBound(+, 0, 1)) BoxGet(VarParam(x, 0))  (VarFree(*) -1/1  (BoxGet(VarBound(apply, 0, 0)) BoxGet(VarBound(+, 0, 1))  BoxGet(VarParam(y, 1)))))))))) VarFree(apply)  VarFree(+)  VarFree(null?))

mov qword [fvar_tbl+8*26], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar - to ((lambda (apply + null?) (begin (set! VarParam(apply, 0) Box(VarParam(apply, 0)))  (set! VarParam(+, 1) Box(VarParam(+, 1)))  (set! VarParam(null?, 2) Box(VarParam(null?, 2)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 0, 2)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(+, 0, 1)) 0/1  (VarFree(*) -1/1  BoxGet(VarParam(x, 0)))) (BoxGet(VarBound(+, 0, 1)) BoxGet(VarParam(x, 0))  (VarFree(*) -1/1  (BoxGet(VarBound(apply, 0, 0)) BoxGet(VarBound(+, 0, 1))  BoxGet(VarParam(y, 1)))))))))) VarFree(apply)  VarFree(+)  VarFree(null?))

	call write_sob_if_not_void

;; Starting: Set fvar > to ((lambda (null? not < = fold-left) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(not, 1) Box(VarParam(not, 1)))  (set! VarParam(<, 2) Box(VarParam(<, 2)))  (set! VarParam(=, 3) Box(VarParam(=, 3)))  (set! VarParam(fold-left, 4) Box(VarParam(fold-left, 4)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 0, 4)) (lambda (a y) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if BoxGet(VarParam(a, 0)) (BoxGet(VarBound(not, 1, 1)) (or (BoxGet(VarBound(<, 1, 2)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 1)))  (BoxGet(VarBound(=, 1, 3)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 1))))) #f)))  #t  BoxGet(VarParam(ys, 1))))))) VarFree(null?)  VarFree(not)  VarFree(<)  VarFree(=)  VarFree(fold-left))
;; Starting: Perform Applic#155 of: ((lambda (null? not < = fold-left) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(not, 1) Box(VarParam(not, 1)))  (set! VarParam(<, 2) Box(VarParam(<, 2)))  (set! VarParam(=, 3) Box(VarParam(=, 3)))  (set! VarParam(fold-left, 4) Box(VarParam(fold-left, 4)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 0, 4)) (lambda (a y) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if BoxGet(VarParam(a, 0)) (BoxGet(VarBound(not, 1, 1)) (or (BoxGet(VarBound(<, 1, 2)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 1)))  (BoxGet(VarBound(=, 1, 3)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 1))))) #f)))  #t  BoxGet(VarParam(ys, 1))))))) VarFree(null?)  VarFree(not)  VarFree(<)  VarFree(=)  VarFree(fold-left))
;; Starting: Argument 4 of Applic statement #155
mov rax, qword [fvar_tbl+8*6]	; mov fvar fold-left to rax
;; Finished: Argument 4 of Applic statement #155

push rax ; Push argument to stack;; Starting: Argument 3 of Applic statement #155
mov rax, qword [fvar_tbl+8*21]	; mov fvar = to rax
;; Finished: Argument 3 of Applic statement #155

push rax ; Push argument to stack;; Starting: Argument 2 of Applic statement #155
mov rax, qword [fvar_tbl+8*22]	; mov fvar < to rax
;; Finished: Argument 2 of Applic statement #155

push rax ; Push argument to stack;; Starting: Argument 1 of Applic statement #155
mov rax, qword [fvar_tbl+8*14]	; mov fvar not to rax
;; Finished: Argument 1 of Applic statement #155

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #155
mov rax, qword [fvar_tbl+8*1]	; mov fvar null? to rax
;; Finished: Argument 0 of Applic statement #155

push rax ; Push argument to stack
push qword 5 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #155)
;; Starting: Creating CLOSURE of LambdaSimple#156 -> (lambda (null? not < = fold-left) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(not, 1) Box(VarParam(not, 1)))  (set! VarParam(<, 2) Box(VarParam(<, 2)))  (set! VarParam(=, 3) Box(VarParam(=, 3)))  (set! VarParam(fold-left, 4) Box(VarParam(fold-left, 4)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 0, 4)) (lambda (a y) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if BoxGet(VarParam(a, 0)) (BoxGet(VarBound(not, 1, 1)) (or (BoxGet(VarBound(<, 1, 2)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 1)))  (BoxGet(VarBound(=, 1, 3)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 1))))) #f)))  #t  BoxGet(VarParam(ys, 1)))))))
push rbx
; Env Extend Code Section For Closure#156
mov rbx, 0 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend156
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End156

LClosureEnvExtend156:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, -1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 0
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop156:
  jz LClosureEnvExtend_LoopEnd156
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop156

LClosureEnvExtend_LoopEnd156:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd156
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop156:
  jz LClosureEnvExtend_ParamsLoopEnd156

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop156

LClosureEnvExtend_ParamsLoopEnd156:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End156:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode156)
pop rbx
jmp LClosureCont156
LClosureCode156:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #157: (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(not, 1) Box(VarParam(not, 1)))  (set! VarParam(<, 2) Box(VarParam(<, 2)))  (set! VarParam(=, 3) Box(VarParam(=, 3)))  (set! VarParam(fold-left, 4) Box(VarParam(fold-left, 4)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 0, 4)) (lambda (a y) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if BoxGet(VarParam(a, 0)) (BoxGet(VarBound(not, 1, 1)) (or (BoxGet(VarBound(<, 1, 2)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 1)))  (BoxGet(VarBound(=, 1, 3)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 1))))) #f)))  #t  BoxGet(VarParam(ys, 1))))))
;; Starting: Item 0 in Seq statement #157
;; Starting: Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(null?, 0)
;; Starting: Get VarParam(name=null?, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=null?, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(null?, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0))

;; Finished: Item 0 in Seq statement #157


;; Starting: Item 1 in Seq statement #157
;; Starting: Set VarParam(name=not, minor=1) with Box(VarParam(not, 1))
;; Starting: Evaluating rhs for [ Set VarParam(name=not, minor=1) with Box(VarParam(not, 1)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(not, 1)
;; Starting: Get VarParam(name=not, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=not, minor=1)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(not, 1)

;; Finished: Evaluating rhs for [ Set VarParam(name=not, minor=1) with Box(VarParam(not, 1)) ], value is expected in rax

mov PVAR(1), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=not, minor=1) with Box(VarParam(not, 1))

;; Finished: Item 1 in Seq statement #157


;; Starting: Item 2 in Seq statement #157
;; Starting: Set VarParam(name=<, minor=2) with Box(VarParam(<, 2))
;; Starting: Evaluating rhs for [ Set VarParam(name=<, minor=2) with Box(VarParam(<, 2)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(<, 2)
;; Starting: Get VarParam(name=<, minor=2)
mov rax, PVAR(2)
;; Finished: Get VarParam(name=<, minor=2)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(<, 2)

;; Finished: Evaluating rhs for [ Set VarParam(name=<, minor=2) with Box(VarParam(<, 2)) ], value is expected in rax

mov PVAR(2), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=<, minor=2) with Box(VarParam(<, 2))

;; Finished: Item 2 in Seq statement #157


;; Starting: Item 3 in Seq statement #157
;; Starting: Set VarParam(name==, minor=3) with Box(VarParam(=, 3))
;; Starting: Evaluating rhs for [ Set VarParam(name==, minor=3) with Box(VarParam(=, 3)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(=, 3)
;; Starting: Get VarParam(name==, minor=3)
mov rax, PVAR(3)
;; Finished: Get VarParam(name==, minor=3)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(=, 3)

;; Finished: Evaluating rhs for [ Set VarParam(name==, minor=3) with Box(VarParam(=, 3)) ], value is expected in rax

mov PVAR(3), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name==, minor=3) with Box(VarParam(=, 3))

;; Finished: Item 3 in Seq statement #157


;; Starting: Item 4 in Seq statement #157
;; Starting: Set VarParam(name=fold-left, minor=4) with Box(VarParam(fold-left, 4))
;; Starting: Evaluating rhs for [ Set VarParam(name=fold-left, minor=4) with Box(VarParam(fold-left, 4)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(fold-left, 4)
;; Starting: Get VarParam(name=fold-left, minor=4)
mov rax, PVAR(4)
;; Finished: Get VarParam(name=fold-left, minor=4)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(fold-left, 4)

;; Finished: Evaluating rhs for [ Set VarParam(name=fold-left, minor=4) with Box(VarParam(fold-left, 4)) ], value is expected in rax

mov PVAR(4), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=fold-left, minor=4) with Box(VarParam(fold-left, 4))

;; Finished: Item 4 in Seq statement #157


;; Starting: Item 5 in Seq statement #157

;; Finished: Item 5 in Seq statement #157

;; Finished: Seq statement #157: (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(not, 1) Box(VarParam(not, 1)))  (set! VarParam(<, 2) Box(VarParam(<, 2)))  (set! VarParam(=, 3) Box(VarParam(=, 3)))  (set! VarParam(fold-left, 4) Box(VarParam(fold-left, 4)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 0, 4)) (lambda (a y) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if BoxGet(VarParam(a, 0)) (BoxGet(VarBound(not, 1, 1)) (or (BoxGet(VarBound(<, 1, 2)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 1)))  (BoxGet(VarBound(=, 1, 3)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 1))))) #f)))  #t  BoxGet(VarParam(ys, 1))))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont156:

;; Finished: Creating CLOSURE of LambdaSimple#156 -> (lambda (null? not < = fold-left) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(not, 1) Box(VarParam(not, 1)))  (set! VarParam(<, 2) Box(VarParam(<, 2)))  (set! VarParam(=, 3) Box(VarParam(=, 3)))  (set! VarParam(fold-left, 4) Box(VarParam(fold-left, 4)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 0, 4)) (lambda (a y) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if BoxGet(VarParam(a, 0)) (BoxGet(VarBound(not, 1, 1)) (or (BoxGet(VarBound(<, 1, 2)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 1)))  (BoxGet(VarBound(=, 1, 3)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 1))))) #f)))  #t  BoxGet(VarParam(ys, 1)))))))

;; Finished: Evaluating proc to apply (in Applic #155)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic155
int 3
ContinueApplic155:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #155
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#155 of: ((lambda (null? not < = fold-left) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(not, 1) Box(VarParam(not, 1)))  (set! VarParam(<, 2) Box(VarParam(<, 2)))  (set! VarParam(=, 3) Box(VarParam(=, 3)))  (set! VarParam(fold-left, 4) Box(VarParam(fold-left, 4)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 0, 4)) (lambda (a y) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if BoxGet(VarParam(a, 0)) (BoxGet(VarBound(not, 1, 1)) (or (BoxGet(VarBound(<, 1, 2)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 1)))  (BoxGet(VarBound(=, 1, 3)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 1))))) #f)))  #t  BoxGet(VarParam(ys, 1))))))) VarFree(null?)  VarFree(not)  VarFree(<)  VarFree(=)  VarFree(fold-left))

mov qword [fvar_tbl+8*27], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar > to ((lambda (null? not < = fold-left) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(not, 1) Box(VarParam(not, 1)))  (set! VarParam(<, 2) Box(VarParam(<, 2)))  (set! VarParam(=, 3) Box(VarParam(=, 3)))  (set! VarParam(fold-left, 4) Box(VarParam(fold-left, 4)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 0, 4)) (lambda (a y) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if BoxGet(VarParam(a, 0)) (BoxGet(VarBound(not, 1, 1)) (or (BoxGet(VarBound(<, 1, 2)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 1)))  (BoxGet(VarBound(=, 1, 3)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 1))))) #f)))  #t  BoxGet(VarParam(ys, 1))))))) VarFree(null?)  VarFree(not)  VarFree(<)  VarFree(=)  VarFree(fold-left))

	call write_sob_if_not_void

;; Starting: Set fvar gcd to ((lambda (gcd null? car cdr) (begin (set! VarParam(gcd, 0) Box(VarParam(gcd, 0)))  (set! VarParam(null?, 1) Box(VarParam(null?, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  ((lambda (gcd-loop) (begin (set! VarParam(gcd-loop, 0) Box(VarParam(gcd-loop, 0)))  BoxSet(VarParam(gcd-loop, 0), (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))))))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(null?, 1, 1)) BoxGet(VarParam(x, 0))) 0/1 (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(car, 1, 2)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(cdr, 1, 3)) BoxGet(VarParam(x, 0))))))))) whatever))) VarFree(gcd)  VarFree(null?)  VarFree(car)  VarFree(cdr))
;; Starting: Perform Applic#158 of: ((lambda (gcd null? car cdr) (begin (set! VarParam(gcd, 0) Box(VarParam(gcd, 0)))  (set! VarParam(null?, 1) Box(VarParam(null?, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  ((lambda (gcd-loop) (begin (set! VarParam(gcd-loop, 0) Box(VarParam(gcd-loop, 0)))  BoxSet(VarParam(gcd-loop, 0), (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))))))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(null?, 1, 1)) BoxGet(VarParam(x, 0))) 0/1 (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(car, 1, 2)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(cdr, 1, 3)) BoxGet(VarParam(x, 0))))))))) whatever))) VarFree(gcd)  VarFree(null?)  VarFree(car)  VarFree(cdr))
;; Starting: Argument 3 of Applic statement #158
mov rax, qword [fvar_tbl+8*3]	; mov fvar cdr to rax
;; Finished: Argument 3 of Applic statement #158

push rax ; Push argument to stack;; Starting: Argument 2 of Applic statement #158
mov rax, qword [fvar_tbl+8*2]	; mov fvar car to rax
;; Finished: Argument 2 of Applic statement #158

push rax ; Push argument to stack;; Starting: Argument 1 of Applic statement #158
mov rax, qword [fvar_tbl+8*1]	; mov fvar null? to rax
;; Finished: Argument 1 of Applic statement #158

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #158
mov rax, qword [fvar_tbl+8*20]	; mov fvar gcd to rax
;; Finished: Argument 0 of Applic statement #158

push rax ; Push argument to stack
push qword 4 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #158)
;; Starting: Creating CLOSURE of LambdaSimple#159 -> (lambda (gcd null? car cdr) (begin (set! VarParam(gcd, 0) Box(VarParam(gcd, 0)))  (set! VarParam(null?, 1) Box(VarParam(null?, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  ((lambda (gcd-loop) (begin (set! VarParam(gcd-loop, 0) Box(VarParam(gcd-loop, 0)))  BoxSet(VarParam(gcd-loop, 0), (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))))))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(null?, 1, 1)) BoxGet(VarParam(x, 0))) 0/1 (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(car, 1, 2)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(cdr, 1, 3)) BoxGet(VarParam(x, 0))))))))) whatever)))
push rbx
; Env Extend Code Section For Closure#159
mov rbx, 0 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend159
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End159

LClosureEnvExtend159:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, -1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 0
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop159:
  jz LClosureEnvExtend_LoopEnd159
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop159

LClosureEnvExtend_LoopEnd159:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd159
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop159:
  jz LClosureEnvExtend_ParamsLoopEnd159

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop159

LClosureEnvExtend_ParamsLoopEnd159:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End159:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode159)
pop rbx
jmp LClosureCont159
LClosureCode159:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #160: (begin (set! VarParam(gcd, 0) Box(VarParam(gcd, 0)))  (set! VarParam(null?, 1) Box(VarParam(null?, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  ((lambda (gcd-loop) (begin (set! VarParam(gcd-loop, 0) Box(VarParam(gcd-loop, 0)))  BoxSet(VarParam(gcd-loop, 0), (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))))))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(null?, 1, 1)) BoxGet(VarParam(x, 0))) 0/1 (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(car, 1, 2)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(cdr, 1, 3)) BoxGet(VarParam(x, 0))))))))) whatever))
;; Starting: Item 0 in Seq statement #160
;; Starting: Set VarParam(name=gcd, minor=0) with Box(VarParam(gcd, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=gcd, minor=0) with Box(VarParam(gcd, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(gcd, 0)
;; Starting: Get VarParam(name=gcd, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=gcd, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(gcd, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=gcd, minor=0) with Box(VarParam(gcd, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=gcd, minor=0) with Box(VarParam(gcd, 0))

;; Finished: Item 0 in Seq statement #160


;; Starting: Item 1 in Seq statement #160
;; Starting: Set VarParam(name=null?, minor=1) with Box(VarParam(null?, 1))
;; Starting: Evaluating rhs for [ Set VarParam(name=null?, minor=1) with Box(VarParam(null?, 1)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(null?, 1)
;; Starting: Get VarParam(name=null?, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=null?, minor=1)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(null?, 1)

;; Finished: Evaluating rhs for [ Set VarParam(name=null?, minor=1) with Box(VarParam(null?, 1)) ], value is expected in rax

mov PVAR(1), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=null?, minor=1) with Box(VarParam(null?, 1))

;; Finished: Item 1 in Seq statement #160


;; Starting: Item 2 in Seq statement #160
;; Starting: Set VarParam(name=car, minor=2) with Box(VarParam(car, 2))
;; Starting: Evaluating rhs for [ Set VarParam(name=car, minor=2) with Box(VarParam(car, 2)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(car, 2)
;; Starting: Get VarParam(name=car, minor=2)
mov rax, PVAR(2)
;; Finished: Get VarParam(name=car, minor=2)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(car, 2)

;; Finished: Evaluating rhs for [ Set VarParam(name=car, minor=2) with Box(VarParam(car, 2)) ], value is expected in rax

mov PVAR(2), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=car, minor=2) with Box(VarParam(car, 2))

;; Finished: Item 2 in Seq statement #160


;; Starting: Item 3 in Seq statement #160
;; Starting: Set VarParam(name=cdr, minor=3) with Box(VarParam(cdr, 3))
;; Starting: Evaluating rhs for [ Set VarParam(name=cdr, minor=3) with Box(VarParam(cdr, 3)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(cdr, 3)
;; Starting: Get VarParam(name=cdr, minor=3)
mov rax, PVAR(3)
;; Finished: Get VarParam(name=cdr, minor=3)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(cdr, 3)

;; Finished: Evaluating rhs for [ Set VarParam(name=cdr, minor=3) with Box(VarParam(cdr, 3)) ], value is expected in rax

mov PVAR(3), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=cdr, minor=3) with Box(VarParam(cdr, 3))

;; Finished: Item 3 in Seq statement #160


;; Starting: Item 4 in Seq statement #160
;; Starting: Perform Applic#161 of: ((lambda (gcd-loop) (begin (set! VarParam(gcd-loop, 0) Box(VarParam(gcd-loop, 0)))  BoxSet(VarParam(gcd-loop, 0), (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))))))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(null?, 1, 1)) BoxGet(VarParam(x, 0))) 0/1 (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(car, 1, 2)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(cdr, 1, 3)) BoxGet(VarParam(x, 0))))))))) whatever)
;; Starting: Argument 0 of Applic statement #161
mov rax, const_tbl+23	; mov const whatever to rax
;; Finished: Argument 0 of Applic statement #161

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #161)
;; Starting: Creating CLOSURE of LambdaSimple#162 -> (lambda (gcd-loop) (begin (set! VarParam(gcd-loop, 0) Box(VarParam(gcd-loop, 0)))  BoxSet(VarParam(gcd-loop, 0), (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))))))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(null?, 1, 1)) BoxGet(VarParam(x, 0))) 0/1 (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(car, 1, 2)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(cdr, 1, 3)) BoxGet(VarParam(x, 0)))))))))
push rbx
; Env Extend Code Section For Closure#162
mov rbx, 1 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend162
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End162

LClosureEnvExtend162:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 0
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 8
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop162:
  jz LClosureEnvExtend_LoopEnd162
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop162

LClosureEnvExtend_LoopEnd162:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd162
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop162:
  jz LClosureEnvExtend_ParamsLoopEnd162

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop162

LClosureEnvExtend_ParamsLoopEnd162:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End162:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode162)
pop rbx
jmp LClosureCont162
LClosureCode162:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #163: (begin (set! VarParam(gcd-loop, 0) Box(VarParam(gcd-loop, 0)))  BoxSet(VarParam(gcd-loop, 0), (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))))))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(null?, 1, 1)) BoxGet(VarParam(x, 0))) 0/1 (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(car, 1, 2)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(cdr, 1, 3)) BoxGet(VarParam(x, 0))))))))
;; Starting: Item 0 in Seq statement #163
;; Starting: Set VarParam(name=gcd-loop, minor=0) with Box(VarParam(gcd-loop, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=gcd-loop, minor=0) with Box(VarParam(gcd-loop, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(gcd-loop, 0)
;; Starting: Get VarParam(name=gcd-loop, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=gcd-loop, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(gcd-loop, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=gcd-loop, minor=0) with Box(VarParam(gcd-loop, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=gcd-loop, minor=0) with Box(VarParam(gcd-loop, 0))

;; Finished: Item 0 in Seq statement #163


;; Starting: Item 1 in Seq statement #163
;; Starting: BoxSet of VarParam(gcd-loop, 0) with (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1)))))
;; Starting: Evaluating rhs for [ BoxSet of VarParam(gcd-loop, 0) with (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))))) ], the VALUE is expected in rax
;; Starting: Creating CLOSURE of LambdaSimple#164 -> (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1)))))
push rbx
; Env Extend Code Section For Closure#164
mov rbx, 2 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend164
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End164

LClosureEnvExtend164:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 16
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop164:
  jz LClosureEnvExtend_LoopEnd164
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop164

LClosureEnvExtend_LoopEnd164:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd164
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop164:
  jz LClosureEnvExtend_ParamsLoopEnd164

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop164

LClosureEnvExtend_ParamsLoopEnd164:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End164:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode164)
pop rbx
jmp LClosureCont164
LClosureCode164:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: If statement (#165): (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))))
Lif165:
;; Starting: Perform Applic#166 of: (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1))
;; Starting: Argument 0 of Applic statement #166
;; Starting: Get VarParam(name=ys, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=ys, minor=1)

;; Finished: Argument 0 of Applic statement #166

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #166)
;; Starting: BoxGet of VarBound(null?, 1, 1)
;; Starting: Evaluating val for [ BoxGet of VarBound(null?, 1, 1) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=null?, major=1, minor=1)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
;; Finished: Get VarBound(name=null?, major=1, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarBound(null?, 1, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(null?, 1, 1)

;; Finished: Evaluating proc to apply (in Applic #166)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic166
int 3
ContinueApplic166:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #166
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#166 of: (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1))

cmp rax, SOB_FALSE_ADDRESS
je Lelse165
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

jmp LendIf165
Lelse165:
;; Starting: Perform Applic#167 of: (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1)))
;; Starting: Argument 1 of Applic statement #167
;; Starting: Perform Applic#170 of: (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))
;; Starting: Argument 0 of Applic statement #170
;; Starting: Get VarParam(name=ys, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=ys, minor=1)

;; Finished: Argument 0 of Applic statement #170

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #170)
;; Starting: BoxGet of VarBound(cdr, 1, 3)
;; Starting: Evaluating val for [ BoxGet of VarBound(cdr, 1, 3) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=cdr, major=1, minor=3)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]
;; Finished: Get VarBound(name=cdr, major=1, minor=3)

;; Finished: Evaluating val for [ BoxGet of VarBound(cdr, 1, 3) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(cdr, 1, 3)

;; Finished: Evaluating proc to apply (in Applic #170)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic170
int 3
ContinueApplic170:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #170
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#170 of: (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))

;; Finished: Argument 1 of Applic statement #167

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #167
;; Starting: Perform Applic#168 of: (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))
;; Starting: Argument 1 of Applic statement #168
;; Starting: Perform Applic#169 of: (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1))
;; Starting: Argument 0 of Applic statement #169
;; Starting: Get VarParam(name=ys, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=ys, minor=1)

;; Finished: Argument 0 of Applic statement #169

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #169)
;; Starting: BoxGet of VarBound(car, 1, 2)
;; Starting: Evaluating val for [ BoxGet of VarBound(car, 1, 2) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=car, major=1, minor=2)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]
;; Finished: Get VarBound(name=car, major=1, minor=2)

;; Finished: Evaluating val for [ BoxGet of VarBound(car, 1, 2) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(car, 1, 2)

;; Finished: Evaluating proc to apply (in Applic #169)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic169
int 3
ContinueApplic169:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #169
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#169 of: (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1))

;; Finished: Argument 1 of Applic statement #168

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #168
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Argument 0 of Applic statement #168

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #168)
;; Starting: BoxGet of VarBound(gcd, 1, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(gcd, 1, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=gcd, major=1, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=gcd, major=1, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(gcd, 1, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(gcd, 1, 0)

;; Finished: Evaluating proc to apply (in Applic #168)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic168
int 3
ContinueApplic168:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #168
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#168 of: (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))

;; Finished: Argument 0 of Applic statement #167

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #167)
;; Starting: BoxGet of VarBound(gcd-loop, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(gcd-loop, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=gcd-loop, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=gcd-loop, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(gcd-loop, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(gcd-loop, 0, 0)

;; Finished: Evaluating proc to apply (in Applic #167)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic167
int 3
ContinueApplic167:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #167
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#167 of: (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1)))

LendIf165:
;; Finished: If statement (#165): (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont164:

;; Finished: Creating CLOSURE of LambdaSimple#164 -> (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1)))))

;; Finished: Evaluating rhs for [ BoxSet of VarParam(gcd-loop, 0) with (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))))) ], the VALUE is expected in rax

; Save the value of rhs
push rax
;; Starting: Evaluating var for [ BoxSet of VarParam(gcd-loop, 0) with (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))))) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=gcd-loop, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=gcd-loop, minor=0)

;; Finished: Evaluating var for [ BoxSet of VarParam(gcd-loop, 0) with (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))))) ], the VALUE is expected in rax

; in RAX there is a address of a box, put the value we saved on stack earlier (from rhs) inside it
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;; Finished: BoxSet of VarParam(gcd-loop, 0) with (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1)))))

;; Finished: Item 1 in Seq statement #163


;; Starting: Item 2 in Seq statement #163
;; Starting: Creating CLOSURE of LambdaSimple#171 -> (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(null?, 1, 1)) BoxGet(VarParam(x, 0))) 0/1 (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(car, 1, 2)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(cdr, 1, 3)) BoxGet(VarParam(x, 0)))))))
push rbx
; Env Extend Code Section For Closure#171
mov rbx, 3 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend171
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End171

LClosureEnvExtend171:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 2
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 24
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop171:
  jz LClosureEnvExtend_LoopEnd171
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop171

LClosureEnvExtend_LoopEnd171:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd171
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop171:
  jz LClosureEnvExtend_ParamsLoopEnd171

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop171

LClosureEnvExtend_ParamsLoopEnd171:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End171:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode171)
pop rbx
jmp LClosureCont171
LClosureCode171:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #172: (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(null?, 1, 1)) BoxGet(VarParam(x, 0))) 0/1 (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(car, 1, 2)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(cdr, 1, 3)) BoxGet(VarParam(x, 0))))))
;; Starting: Item 0 in Seq statement #172
;; Starting: Set VarParam(name=x, minor=0) with Box(VarParam(x, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=x, minor=0) with Box(VarParam(x, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(x, 0)
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(x, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=x, minor=0) with Box(VarParam(x, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=x, minor=0) with Box(VarParam(x, 0))

;; Finished: Item 0 in Seq statement #172


;; Starting: Item 1 in Seq statement #172
;; Starting: If statement (#173): (if (BoxGet(VarBound(null?, 1, 1)) BoxGet(VarParam(x, 0))) 0/1 (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(car, 1, 2)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(cdr, 1, 3)) BoxGet(VarParam(x, 0)))))
Lif173:
;; Starting: Perform Applic#174 of: (BoxGet(VarBound(null?, 1, 1)) BoxGet(VarParam(x, 0)))
;; Starting: Argument 0 of Applic statement #174
;; Starting: BoxGet of VarParam(x, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(x, 0)

;; Finished: Argument 0 of Applic statement #174

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #174)
;; Starting: BoxGet of VarBound(null?, 1, 1)
;; Starting: Evaluating val for [ BoxGet of VarBound(null?, 1, 1) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=null?, major=1, minor=1)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
;; Finished: Get VarBound(name=null?, major=1, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarBound(null?, 1, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(null?, 1, 1)

;; Finished: Evaluating proc to apply (in Applic #174)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic174
int 3
ContinueApplic174:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #174
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#174 of: (BoxGet(VarBound(null?, 1, 1)) BoxGet(VarParam(x, 0)))

cmp rax, SOB_FALSE_ADDRESS
je Lelse173
mov rax, const_tbl+34	; mov const 0/1 to rax
jmp LendIf173
Lelse173:
;; Starting: Perform Applic#175 of: (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(car, 1, 2)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(cdr, 1, 3)) BoxGet(VarParam(x, 0))))
;; Starting: Argument 1 of Applic statement #175
;; Starting: Perform Applic#177 of: (BoxGet(VarBound(cdr, 1, 3)) BoxGet(VarParam(x, 0)))
;; Starting: Argument 0 of Applic statement #177
;; Starting: BoxGet of VarParam(x, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(x, 0)

;; Finished: Argument 0 of Applic statement #177

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #177)
;; Starting: BoxGet of VarBound(cdr, 1, 3)
;; Starting: Evaluating val for [ BoxGet of VarBound(cdr, 1, 3) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=cdr, major=1, minor=3)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]
;; Finished: Get VarBound(name=cdr, major=1, minor=3)

;; Finished: Evaluating val for [ BoxGet of VarBound(cdr, 1, 3) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(cdr, 1, 3)

;; Finished: Evaluating proc to apply (in Applic #177)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic177
int 3
ContinueApplic177:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #177
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#177 of: (BoxGet(VarBound(cdr, 1, 3)) BoxGet(VarParam(x, 0)))

;; Finished: Argument 1 of Applic statement #175

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #175
;; Starting: Perform Applic#176 of: (BoxGet(VarBound(car, 1, 2)) BoxGet(VarParam(x, 0)))
;; Starting: Argument 0 of Applic statement #176
;; Starting: BoxGet of VarParam(x, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(x, 0)

;; Finished: Argument 0 of Applic statement #176

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #176)
;; Starting: BoxGet of VarBound(car, 1, 2)
;; Starting: Evaluating val for [ BoxGet of VarBound(car, 1, 2) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=car, major=1, minor=2)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]
;; Finished: Get VarBound(name=car, major=1, minor=2)

;; Finished: Evaluating val for [ BoxGet of VarBound(car, 1, 2) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(car, 1, 2)

;; Finished: Evaluating proc to apply (in Applic #176)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic176
int 3
ContinueApplic176:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #176
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#176 of: (BoxGet(VarBound(car, 1, 2)) BoxGet(VarParam(x, 0)))

;; Finished: Argument 0 of Applic statement #175

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #175)
;; Starting: BoxGet of VarBound(gcd-loop, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(gcd-loop, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=gcd-loop, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=gcd-loop, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(gcd-loop, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(gcd-loop, 0, 0)

;; Finished: Evaluating proc to apply (in Applic #175)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic175
int 3
ContinueApplic175:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #175
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#175 of: (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(car, 1, 2)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(cdr, 1, 3)) BoxGet(VarParam(x, 0))))

LendIf173:
;; Finished: If statement (#173): (if (BoxGet(VarBound(null?, 1, 1)) BoxGet(VarParam(x, 0))) 0/1 (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(car, 1, 2)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(cdr, 1, 3)) BoxGet(VarParam(x, 0)))))

;; Finished: Item 1 in Seq statement #172

;; Finished: Seq statement #172: (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(null?, 1, 1)) BoxGet(VarParam(x, 0))) 0/1 (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(car, 1, 2)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(cdr, 1, 3)) BoxGet(VarParam(x, 0))))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont171:

;; Finished: Creating CLOSURE of LambdaSimple#171 -> (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(null?, 1, 1)) BoxGet(VarParam(x, 0))) 0/1 (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(car, 1, 2)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(cdr, 1, 3)) BoxGet(VarParam(x, 0)))))))

;; Finished: Item 2 in Seq statement #163

;; Finished: Seq statement #163: (begin (set! VarParam(gcd-loop, 0) Box(VarParam(gcd-loop, 0)))  BoxSet(VarParam(gcd-loop, 0), (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))))))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(null?, 1, 1)) BoxGet(VarParam(x, 0))) 0/1 (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(car, 1, 2)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(cdr, 1, 3)) BoxGet(VarParam(x, 0))))))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont162:

;; Finished: Creating CLOSURE of LambdaSimple#162 -> (lambda (gcd-loop) (begin (set! VarParam(gcd-loop, 0) Box(VarParam(gcd-loop, 0)))  BoxSet(VarParam(gcd-loop, 0), (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))))))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(null?, 1, 1)) BoxGet(VarParam(x, 0))) 0/1 (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(car, 1, 2)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(cdr, 1, 3)) BoxGet(VarParam(x, 0)))))))))

;; Finished: Evaluating proc to apply (in Applic #161)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic161
int 3
ContinueApplic161:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #161
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#161 of: ((lambda (gcd-loop) (begin (set! VarParam(gcd-loop, 0) Box(VarParam(gcd-loop, 0)))  BoxSet(VarParam(gcd-loop, 0), (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))))))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(null?, 1, 1)) BoxGet(VarParam(x, 0))) 0/1 (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(car, 1, 2)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(cdr, 1, 3)) BoxGet(VarParam(x, 0))))))))) whatever)

;; Finished: Item 4 in Seq statement #160

;; Finished: Seq statement #160: (begin (set! VarParam(gcd, 0) Box(VarParam(gcd, 0)))  (set! VarParam(null?, 1) Box(VarParam(null?, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  ((lambda (gcd-loop) (begin (set! VarParam(gcd-loop, 0) Box(VarParam(gcd-loop, 0)))  BoxSet(VarParam(gcd-loop, 0), (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))))))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(null?, 1, 1)) BoxGet(VarParam(x, 0))) 0/1 (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(car, 1, 2)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(cdr, 1, 3)) BoxGet(VarParam(x, 0))))))))) whatever))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont159:

;; Finished: Creating CLOSURE of LambdaSimple#159 -> (lambda (gcd null? car cdr) (begin (set! VarParam(gcd, 0) Box(VarParam(gcd, 0)))  (set! VarParam(null?, 1) Box(VarParam(null?, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  ((lambda (gcd-loop) (begin (set! VarParam(gcd-loop, 0) Box(VarParam(gcd-loop, 0)))  BoxSet(VarParam(gcd-loop, 0), (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))))))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(null?, 1, 1)) BoxGet(VarParam(x, 0))) 0/1 (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(car, 1, 2)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(cdr, 1, 3)) BoxGet(VarParam(x, 0))))))))) whatever)))

;; Finished: Evaluating proc to apply (in Applic #158)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic158
int 3
ContinueApplic158:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #158
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#158 of: ((lambda (gcd null? car cdr) (begin (set! VarParam(gcd, 0) Box(VarParam(gcd, 0)))  (set! VarParam(null?, 1) Box(VarParam(null?, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  ((lambda (gcd-loop) (begin (set! VarParam(gcd-loop, 0) Box(VarParam(gcd-loop, 0)))  BoxSet(VarParam(gcd-loop, 0), (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))))))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(null?, 1, 1)) BoxGet(VarParam(x, 0))) 0/1 (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(car, 1, 2)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(cdr, 1, 3)) BoxGet(VarParam(x, 0))))))))) whatever))) VarFree(gcd)  VarFree(null?)  VarFree(car)  VarFree(cdr))

mov qword [fvar_tbl+8*20], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar gcd to ((lambda (gcd null? car cdr) (begin (set! VarParam(gcd, 0) Box(VarParam(gcd, 0)))  (set! VarParam(null?, 1) Box(VarParam(null?, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  ((lambda (gcd-loop) (begin (set! VarParam(gcd-loop, 0) Box(VarParam(gcd-loop, 0)))  BoxSet(VarParam(gcd-loop, 0), (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))))))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(null?, 1, 1)) BoxGet(VarParam(x, 0))) 0/1 (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(car, 1, 2)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(cdr, 1, 3)) BoxGet(VarParam(x, 0))))))))) whatever))) VarFree(gcd)  VarFree(null?)  VarFree(car)  VarFree(cdr))

	call write_sob_if_not_void

;; Starting: Set fvar zero? to ((lambda (=) (begin (set! VarParam(=, 0) Box(VarParam(=, 0)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(=, 0, 0)) BoxGet(VarParam(x, 0))  0/1))))) VarFree(=))
;; Starting: Perform Applic#178 of: ((lambda (=) (begin (set! VarParam(=, 0) Box(VarParam(=, 0)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(=, 0, 0)) BoxGet(VarParam(x, 0))  0/1))))) VarFree(=))
;; Starting: Argument 0 of Applic statement #178
mov rax, qword [fvar_tbl+8*21]	; mov fvar = to rax
;; Finished: Argument 0 of Applic statement #178

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #178)
;; Starting: Creating CLOSURE of LambdaSimple#179 -> (lambda (=) (begin (set! VarParam(=, 0) Box(VarParam(=, 0)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(=, 0, 0)) BoxGet(VarParam(x, 0))  0/1)))))
push rbx
; Env Extend Code Section For Closure#179
mov rbx, 0 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend179
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End179

LClosureEnvExtend179:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, -1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 0
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop179:
  jz LClosureEnvExtend_LoopEnd179
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop179

LClosureEnvExtend_LoopEnd179:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd179
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop179:
  jz LClosureEnvExtend_ParamsLoopEnd179

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop179

LClosureEnvExtend_ParamsLoopEnd179:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End179:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode179)
pop rbx
jmp LClosureCont179
LClosureCode179:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #180: (begin (set! VarParam(=, 0) Box(VarParam(=, 0)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(=, 0, 0)) BoxGet(VarParam(x, 0))  0/1))))
;; Starting: Item 0 in Seq statement #180
;; Starting: Set VarParam(name==, minor=0) with Box(VarParam(=, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name==, minor=0) with Box(VarParam(=, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(=, 0)
;; Starting: Get VarParam(name==, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name==, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(=, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name==, minor=0) with Box(VarParam(=, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name==, minor=0) with Box(VarParam(=, 0))

;; Finished: Item 0 in Seq statement #180


;; Starting: Item 1 in Seq statement #180
;; Starting: Creating CLOSURE of LambdaSimple#181 -> (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(=, 0, 0)) BoxGet(VarParam(x, 0))  0/1)))
push rbx
; Env Extend Code Section For Closure#181
mov rbx, 1 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend181
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End181

LClosureEnvExtend181:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 0
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 8
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop181:
  jz LClosureEnvExtend_LoopEnd181
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop181

LClosureEnvExtend_LoopEnd181:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd181
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop181:
  jz LClosureEnvExtend_ParamsLoopEnd181

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop181

LClosureEnvExtend_ParamsLoopEnd181:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End181:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode181)
pop rbx
jmp LClosureCont181
LClosureCode181:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #182: (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(=, 0, 0)) BoxGet(VarParam(x, 0))  0/1))
;; Starting: Item 0 in Seq statement #182
;; Starting: Set VarParam(name=x, minor=0) with Box(VarParam(x, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=x, minor=0) with Box(VarParam(x, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(x, 0)
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(x, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=x, minor=0) with Box(VarParam(x, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=x, minor=0) with Box(VarParam(x, 0))

;; Finished: Item 0 in Seq statement #182


;; Starting: Item 1 in Seq statement #182
;; Starting: Perform Applic#183 of: (BoxGet(VarBound(=, 0, 0)) BoxGet(VarParam(x, 0))  0/1)
;; Starting: Argument 1 of Applic statement #183
mov rax, const_tbl+34	; mov const 0/1 to rax
;; Finished: Argument 1 of Applic statement #183

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #183
;; Starting: BoxGet of VarParam(x, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(x, 0)

;; Finished: Argument 0 of Applic statement #183

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #183)
;; Starting: BoxGet of VarBound(=, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(=, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name==, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name==, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(=, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(=, 0, 0)

;; Finished: Evaluating proc to apply (in Applic #183)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic183
int 3
ContinueApplic183:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #183
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#183 of: (BoxGet(VarBound(=, 0, 0)) BoxGet(VarParam(x, 0))  0/1)

;; Finished: Item 1 in Seq statement #182

;; Finished: Seq statement #182: (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(=, 0, 0)) BoxGet(VarParam(x, 0))  0/1))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont181:

;; Finished: Creating CLOSURE of LambdaSimple#181 -> (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(=, 0, 0)) BoxGet(VarParam(x, 0))  0/1)))

;; Finished: Item 1 in Seq statement #180

;; Finished: Seq statement #180: (begin (set! VarParam(=, 0) Box(VarParam(=, 0)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(=, 0, 0)) BoxGet(VarParam(x, 0))  0/1))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont179:

;; Finished: Creating CLOSURE of LambdaSimple#179 -> (lambda (=) (begin (set! VarParam(=, 0) Box(VarParam(=, 0)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(=, 0, 0)) BoxGet(VarParam(x, 0))  0/1)))))

;; Finished: Evaluating proc to apply (in Applic #178)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic178
int 3
ContinueApplic178:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #178
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#178 of: ((lambda (=) (begin (set! VarParam(=, 0) Box(VarParam(=, 0)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(=, 0, 0)) BoxGet(VarParam(x, 0))  0/1))))) VarFree(=))

mov qword [fvar_tbl+8*28], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar zero? to ((lambda (=) (begin (set! VarParam(=, 0) Box(VarParam(=, 0)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(=, 0, 0)) BoxGet(VarParam(x, 0))  0/1))))) VarFree(=))

	call write_sob_if_not_void

;; Starting: Set fvar integer? to ((lambda (rational? = denominator) (begin (set! VarParam(rational?, 0) Box(VarParam(rational?, 0)))  (set! VarParam(=, 1) Box(VarParam(=, 1)))  (set! VarParam(denominator, 2) Box(VarParam(denominator, 2)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(rational?, 0, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(=, 0, 1)) (BoxGet(VarBound(denominator, 0, 2)) BoxGet(VarParam(x, 0)))  1/1) #f))))) VarFree(rational?)  VarFree(=)  VarFree(denominator))
;; Starting: Perform Applic#184 of: ((lambda (rational? = denominator) (begin (set! VarParam(rational?, 0) Box(VarParam(rational?, 0)))  (set! VarParam(=, 1) Box(VarParam(=, 1)))  (set! VarParam(denominator, 2) Box(VarParam(denominator, 2)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(rational?, 0, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(=, 0, 1)) (BoxGet(VarBound(denominator, 0, 2)) BoxGet(VarParam(x, 0)))  1/1) #f))))) VarFree(rational?)  VarFree(=)  VarFree(denominator))
;; Starting: Argument 2 of Applic statement #184
mov rax, qword [fvar_tbl+8*19]	; mov fvar denominator to rax
;; Finished: Argument 2 of Applic statement #184

push rax ; Push argument to stack;; Starting: Argument 1 of Applic statement #184
mov rax, qword [fvar_tbl+8*21]	; mov fvar = to rax
;; Finished: Argument 1 of Applic statement #184

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #184
mov rax, qword [fvar_tbl+8*24]	; mov fvar rational? to rax
;; Finished: Argument 0 of Applic statement #184

push rax ; Push argument to stack
push qword 3 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #184)
;; Starting: Creating CLOSURE of LambdaSimple#185 -> (lambda (rational? = denominator) (begin (set! VarParam(rational?, 0) Box(VarParam(rational?, 0)))  (set! VarParam(=, 1) Box(VarParam(=, 1)))  (set! VarParam(denominator, 2) Box(VarParam(denominator, 2)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(rational?, 0, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(=, 0, 1)) (BoxGet(VarBound(denominator, 0, 2)) BoxGet(VarParam(x, 0)))  1/1) #f)))))
push rbx
; Env Extend Code Section For Closure#185
mov rbx, 0 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend185
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End185

LClosureEnvExtend185:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, -1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 0
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop185:
  jz LClosureEnvExtend_LoopEnd185
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop185

LClosureEnvExtend_LoopEnd185:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd185
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop185:
  jz LClosureEnvExtend_ParamsLoopEnd185

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop185

LClosureEnvExtend_ParamsLoopEnd185:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End185:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode185)
pop rbx
jmp LClosureCont185
LClosureCode185:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #186: (begin (set! VarParam(rational?, 0) Box(VarParam(rational?, 0)))  (set! VarParam(=, 1) Box(VarParam(=, 1)))  (set! VarParam(denominator, 2) Box(VarParam(denominator, 2)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(rational?, 0, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(=, 0, 1)) (BoxGet(VarBound(denominator, 0, 2)) BoxGet(VarParam(x, 0)))  1/1) #f))))
;; Starting: Item 0 in Seq statement #186
;; Starting: Set VarParam(name=rational?, minor=0) with Box(VarParam(rational?, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=rational?, minor=0) with Box(VarParam(rational?, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(rational?, 0)
;; Starting: Get VarParam(name=rational?, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=rational?, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(rational?, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=rational?, minor=0) with Box(VarParam(rational?, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=rational?, minor=0) with Box(VarParam(rational?, 0))

;; Finished: Item 0 in Seq statement #186


;; Starting: Item 1 in Seq statement #186
;; Starting: Set VarParam(name==, minor=1) with Box(VarParam(=, 1))
;; Starting: Evaluating rhs for [ Set VarParam(name==, minor=1) with Box(VarParam(=, 1)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(=, 1)
;; Starting: Get VarParam(name==, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name==, minor=1)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(=, 1)

;; Finished: Evaluating rhs for [ Set VarParam(name==, minor=1) with Box(VarParam(=, 1)) ], value is expected in rax

mov PVAR(1), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name==, minor=1) with Box(VarParam(=, 1))

;; Finished: Item 1 in Seq statement #186


;; Starting: Item 2 in Seq statement #186
;; Starting: Set VarParam(name=denominator, minor=2) with Box(VarParam(denominator, 2))
;; Starting: Evaluating rhs for [ Set VarParam(name=denominator, minor=2) with Box(VarParam(denominator, 2)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(denominator, 2)
;; Starting: Get VarParam(name=denominator, minor=2)
mov rax, PVAR(2)
;; Finished: Get VarParam(name=denominator, minor=2)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(denominator, 2)

;; Finished: Evaluating rhs for [ Set VarParam(name=denominator, minor=2) with Box(VarParam(denominator, 2)) ], value is expected in rax

mov PVAR(2), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=denominator, minor=2) with Box(VarParam(denominator, 2))

;; Finished: Item 2 in Seq statement #186


;; Starting: Item 3 in Seq statement #186
;; Starting: Creating CLOSURE of LambdaSimple#187 -> (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(rational?, 0, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(=, 0, 1)) (BoxGet(VarBound(denominator, 0, 2)) BoxGet(VarParam(x, 0)))  1/1) #f)))
push rbx
; Env Extend Code Section For Closure#187
mov rbx, 1 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend187
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End187

LClosureEnvExtend187:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 0
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 8
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop187:
  jz LClosureEnvExtend_LoopEnd187
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop187

LClosureEnvExtend_LoopEnd187:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd187
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop187:
  jz LClosureEnvExtend_ParamsLoopEnd187

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop187

LClosureEnvExtend_ParamsLoopEnd187:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End187:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode187)
pop rbx
jmp LClosureCont187
LClosureCode187:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #188: (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(rational?, 0, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(=, 0, 1)) (BoxGet(VarBound(denominator, 0, 2)) BoxGet(VarParam(x, 0)))  1/1) #f))
;; Starting: Item 0 in Seq statement #188
;; Starting: Set VarParam(name=x, minor=0) with Box(VarParam(x, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=x, minor=0) with Box(VarParam(x, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(x, 0)
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(x, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=x, minor=0) with Box(VarParam(x, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=x, minor=0) with Box(VarParam(x, 0))

;; Finished: Item 0 in Seq statement #188


;; Starting: Item 1 in Seq statement #188
;; Starting: If statement (#189): (if (BoxGet(VarBound(rational?, 0, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(=, 0, 1)) (BoxGet(VarBound(denominator, 0, 2)) BoxGet(VarParam(x, 0)))  1/1) #f)
Lif189:
;; Starting: Perform Applic#190 of: (BoxGet(VarBound(rational?, 0, 0)) BoxGet(VarParam(x, 0)))
;; Starting: Argument 0 of Applic statement #190
;; Starting: BoxGet of VarParam(x, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(x, 0)

;; Finished: Argument 0 of Applic statement #190

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #190)
;; Starting: BoxGet of VarBound(rational?, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(rational?, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=rational?, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=rational?, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(rational?, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(rational?, 0, 0)

;; Finished: Evaluating proc to apply (in Applic #190)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic190
int 3
ContinueApplic190:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #190
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#190 of: (BoxGet(VarBound(rational?, 0, 0)) BoxGet(VarParam(x, 0)))

cmp rax, SOB_FALSE_ADDRESS
je Lelse189
;; Starting: Perform Applic#191 of: (BoxGet(VarBound(=, 0, 1)) (BoxGet(VarBound(denominator, 0, 2)) BoxGet(VarParam(x, 0)))  1/1)
;; Starting: Argument 1 of Applic statement #191
mov rax, const_tbl+51	; mov const 1/1 to rax
;; Finished: Argument 1 of Applic statement #191

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #191
;; Starting: Perform Applic#192 of: (BoxGet(VarBound(denominator, 0, 2)) BoxGet(VarParam(x, 0)))
;; Starting: Argument 0 of Applic statement #192
;; Starting: BoxGet of VarParam(x, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(x, 0)

;; Finished: Argument 0 of Applic statement #192

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #192)
;; Starting: BoxGet of VarBound(denominator, 0, 2)
;; Starting: Evaluating val for [ BoxGet of VarBound(denominator, 0, 2) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=denominator, major=0, minor=2)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 2]
;; Finished: Get VarBound(name=denominator, major=0, minor=2)

;; Finished: Evaluating val for [ BoxGet of VarBound(denominator, 0, 2) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(denominator, 0, 2)

;; Finished: Evaluating proc to apply (in Applic #192)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic192
int 3
ContinueApplic192:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #192
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#192 of: (BoxGet(VarBound(denominator, 0, 2)) BoxGet(VarParam(x, 0)))

;; Finished: Argument 0 of Applic statement #191

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #191)
;; Starting: BoxGet of VarBound(=, 0, 1)
;; Starting: Evaluating val for [ BoxGet of VarBound(=, 0, 1) ], the VALUE is expected in rax
;; Starting: Get VarBound(name==, major=0, minor=1)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]
;; Finished: Get VarBound(name==, major=0, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarBound(=, 0, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(=, 0, 1)

;; Finished: Evaluating proc to apply (in Applic #191)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic191
int 3
ContinueApplic191:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #191
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#191 of: (BoxGet(VarBound(=, 0, 1)) (BoxGet(VarBound(denominator, 0, 2)) BoxGet(VarParam(x, 0)))  1/1)

jmp LendIf189
Lelse189:
mov rax, const_tbl+2	; mov const #f to rax
LendIf189:
;; Finished: If statement (#189): (if (BoxGet(VarBound(rational?, 0, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(=, 0, 1)) (BoxGet(VarBound(denominator, 0, 2)) BoxGet(VarParam(x, 0)))  1/1) #f)

;; Finished: Item 1 in Seq statement #188

;; Finished: Seq statement #188: (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(rational?, 0, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(=, 0, 1)) (BoxGet(VarBound(denominator, 0, 2)) BoxGet(VarParam(x, 0)))  1/1) #f))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont187:

;; Finished: Creating CLOSURE of LambdaSimple#187 -> (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(rational?, 0, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(=, 0, 1)) (BoxGet(VarBound(denominator, 0, 2)) BoxGet(VarParam(x, 0)))  1/1) #f)))

;; Finished: Item 3 in Seq statement #186

;; Finished: Seq statement #186: (begin (set! VarParam(rational?, 0) Box(VarParam(rational?, 0)))  (set! VarParam(=, 1) Box(VarParam(=, 1)))  (set! VarParam(denominator, 2) Box(VarParam(denominator, 2)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(rational?, 0, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(=, 0, 1)) (BoxGet(VarBound(denominator, 0, 2)) BoxGet(VarParam(x, 0)))  1/1) #f))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont185:

;; Finished: Creating CLOSURE of LambdaSimple#185 -> (lambda (rational? = denominator) (begin (set! VarParam(rational?, 0) Box(VarParam(rational?, 0)))  (set! VarParam(=, 1) Box(VarParam(=, 1)))  (set! VarParam(denominator, 2) Box(VarParam(denominator, 2)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(rational?, 0, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(=, 0, 1)) (BoxGet(VarBound(denominator, 0, 2)) BoxGet(VarParam(x, 0)))  1/1) #f)))))

;; Finished: Evaluating proc to apply (in Applic #184)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic184
int 3
ContinueApplic184:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #184
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#184 of: ((lambda (rational? = denominator) (begin (set! VarParam(rational?, 0) Box(VarParam(rational?, 0)))  (set! VarParam(=, 1) Box(VarParam(=, 1)))  (set! VarParam(denominator, 2) Box(VarParam(denominator, 2)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(rational?, 0, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(=, 0, 1)) (BoxGet(VarBound(denominator, 0, 2)) BoxGet(VarParam(x, 0)))  1/1) #f))))) VarFree(rational?)  VarFree(=)  VarFree(denominator))

mov qword [fvar_tbl+8*29], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar integer? to ((lambda (rational? = denominator) (begin (set! VarParam(rational?, 0) Box(VarParam(rational?, 0)))  (set! VarParam(=, 1) Box(VarParam(=, 1)))  (set! VarParam(denominator, 2) Box(VarParam(denominator, 2)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(rational?, 0, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(=, 0, 1)) (BoxGet(VarBound(denominator, 0, 2)) BoxGet(VarParam(x, 0)))  1/1) #f))))) VarFree(rational?)  VarFree(=)  VarFree(denominator))

	call write_sob_if_not_void

;; Starting: Set fvar number? to ((lambda (flonum? rational?) (begin (set! VarParam(flonum?, 0) Box(VarParam(flonum?, 0)))  (set! VarParam(rational?, 1) Box(VarParam(rational?, 1)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (or (BoxGet(VarBound(flonum?, 0, 0)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(rational?, 0, 1)) BoxGet(VarParam(x, 0)))))))) VarFree(flonum?)  VarFree(rational?))
;; Starting: Perform Applic#193 of: ((lambda (flonum? rational?) (begin (set! VarParam(flonum?, 0) Box(VarParam(flonum?, 0)))  (set! VarParam(rational?, 1) Box(VarParam(rational?, 1)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (or (BoxGet(VarBound(flonum?, 0, 0)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(rational?, 0, 1)) BoxGet(VarParam(x, 0)))))))) VarFree(flonum?)  VarFree(rational?))
;; Starting: Argument 1 of Applic statement #193
mov rax, qword [fvar_tbl+8*24]	; mov fvar rational? to rax
;; Finished: Argument 1 of Applic statement #193

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #193
mov rax, qword [fvar_tbl+8*23]	; mov fvar flonum? to rax
;; Finished: Argument 0 of Applic statement #193

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #193)
;; Starting: Creating CLOSURE of LambdaSimple#194 -> (lambda (flonum? rational?) (begin (set! VarParam(flonum?, 0) Box(VarParam(flonum?, 0)))  (set! VarParam(rational?, 1) Box(VarParam(rational?, 1)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (or (BoxGet(VarBound(flonum?, 0, 0)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(rational?, 0, 1)) BoxGet(VarParam(x, 0))))))))
push rbx
; Env Extend Code Section For Closure#194
mov rbx, 0 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend194
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End194

LClosureEnvExtend194:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, -1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 0
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop194:
  jz LClosureEnvExtend_LoopEnd194
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop194

LClosureEnvExtend_LoopEnd194:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd194
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop194:
  jz LClosureEnvExtend_ParamsLoopEnd194

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop194

LClosureEnvExtend_ParamsLoopEnd194:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End194:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode194)
pop rbx
jmp LClosureCont194
LClosureCode194:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #195: (begin (set! VarParam(flonum?, 0) Box(VarParam(flonum?, 0)))  (set! VarParam(rational?, 1) Box(VarParam(rational?, 1)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (or (BoxGet(VarBound(flonum?, 0, 0)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(rational?, 0, 1)) BoxGet(VarParam(x, 0)))))))
;; Starting: Item 0 in Seq statement #195
;; Starting: Set VarParam(name=flonum?, minor=0) with Box(VarParam(flonum?, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=flonum?, minor=0) with Box(VarParam(flonum?, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(flonum?, 0)
;; Starting: Get VarParam(name=flonum?, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=flonum?, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(flonum?, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=flonum?, minor=0) with Box(VarParam(flonum?, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=flonum?, minor=0) with Box(VarParam(flonum?, 0))

;; Finished: Item 0 in Seq statement #195


;; Starting: Item 1 in Seq statement #195
;; Starting: Set VarParam(name=rational?, minor=1) with Box(VarParam(rational?, 1))
;; Starting: Evaluating rhs for [ Set VarParam(name=rational?, minor=1) with Box(VarParam(rational?, 1)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(rational?, 1)
;; Starting: Get VarParam(name=rational?, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=rational?, minor=1)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(rational?, 1)

;; Finished: Evaluating rhs for [ Set VarParam(name=rational?, minor=1) with Box(VarParam(rational?, 1)) ], value is expected in rax

mov PVAR(1), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=rational?, minor=1) with Box(VarParam(rational?, 1))

;; Finished: Item 1 in Seq statement #195


;; Starting: Item 2 in Seq statement #195
;; Starting: Creating CLOSURE of LambdaSimple#196 -> (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (or (BoxGet(VarBound(flonum?, 0, 0)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(rational?, 0, 1)) BoxGet(VarParam(x, 0))))))
push rbx
; Env Extend Code Section For Closure#196
mov rbx, 1 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend196
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End196

LClosureEnvExtend196:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 0
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 8
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop196:
  jz LClosureEnvExtend_LoopEnd196
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop196

LClosureEnvExtend_LoopEnd196:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd196
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop196:
  jz LClosureEnvExtend_ParamsLoopEnd196

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop196

LClosureEnvExtend_ParamsLoopEnd196:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End196:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode196)
pop rbx
jmp LClosureCont196
LClosureCode196:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #197: (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (or (BoxGet(VarBound(flonum?, 0, 0)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(rational?, 0, 1)) BoxGet(VarParam(x, 0)))))
;; Starting: Item 0 in Seq statement #197
;; Starting: Set VarParam(name=x, minor=0) with Box(VarParam(x, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=x, minor=0) with Box(VarParam(x, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(x, 0)
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(x, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=x, minor=0) with Box(VarParam(x, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=x, minor=0) with Box(VarParam(x, 0))

;; Finished: Item 0 in Seq statement #197


;; Starting: Item 1 in Seq statement #197
;; Starting: Or statement (#198): (or (BoxGet(VarBound(flonum?, 0, 0)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(rational?, 0, 1)) BoxGet(VarParam(x, 0))))
Lor198: 
;; Starting: Item 0 in Or statement #198
;; Starting: Perform Applic#199 of: (BoxGet(VarBound(flonum?, 0, 0)) BoxGet(VarParam(x, 0)))
;; Starting: Argument 0 of Applic statement #199
;; Starting: BoxGet of VarParam(x, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(x, 0)

;; Finished: Argument 0 of Applic statement #199

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #199)
;; Starting: BoxGet of VarBound(flonum?, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(flonum?, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=flonum?, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=flonum?, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(flonum?, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(flonum?, 0, 0)

;; Finished: Evaluating proc to apply (in Applic #199)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic199
int 3
ContinueApplic199:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #199
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#199 of: (BoxGet(VarBound(flonum?, 0, 0)) BoxGet(VarParam(x, 0)))

;; Finished: Item 0 in Or statement #198
cmp rax, SOB_FALSE_ADDRESS 
jne LendOr198;; Starting: Item 1 in Or statement #198
;; Starting: Perform Applic#200 of: (BoxGet(VarBound(rational?, 0, 1)) BoxGet(VarParam(x, 0)))
;; Starting: Argument 0 of Applic statement #200
;; Starting: BoxGet of VarParam(x, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(x, 0)

;; Finished: Argument 0 of Applic statement #200

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #200)
;; Starting: BoxGet of VarBound(rational?, 0, 1)
;; Starting: Evaluating val for [ BoxGet of VarBound(rational?, 0, 1) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=rational?, major=0, minor=1)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]
;; Finished: Get VarBound(name=rational?, major=0, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarBound(rational?, 0, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(rational?, 0, 1)

;; Finished: Evaluating proc to apply (in Applic #200)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic200
int 3
ContinueApplic200:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #200
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#200 of: (BoxGet(VarBound(rational?, 0, 1)) BoxGet(VarParam(x, 0)))

;; Finished: Item 1 in Or statement #198
 
LendOr198:
;; Finished: Or statement (#198): (or (BoxGet(VarBound(flonum?, 0, 0)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(rational?, 0, 1)) BoxGet(VarParam(x, 0))))

;; Finished: Item 1 in Seq statement #197

;; Finished: Seq statement #197: (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (or (BoxGet(VarBound(flonum?, 0, 0)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(rational?, 0, 1)) BoxGet(VarParam(x, 0)))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont196:

;; Finished: Creating CLOSURE of LambdaSimple#196 -> (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (or (BoxGet(VarBound(flonum?, 0, 0)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(rational?, 0, 1)) BoxGet(VarParam(x, 0))))))

;; Finished: Item 2 in Seq statement #195

;; Finished: Seq statement #195: (begin (set! VarParam(flonum?, 0) Box(VarParam(flonum?, 0)))  (set! VarParam(rational?, 1) Box(VarParam(rational?, 1)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (or (BoxGet(VarBound(flonum?, 0, 0)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(rational?, 0, 1)) BoxGet(VarParam(x, 0)))))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont194:

;; Finished: Creating CLOSURE of LambdaSimple#194 -> (lambda (flonum? rational?) (begin (set! VarParam(flonum?, 0) Box(VarParam(flonum?, 0)))  (set! VarParam(rational?, 1) Box(VarParam(rational?, 1)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (or (BoxGet(VarBound(flonum?, 0, 0)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(rational?, 0, 1)) BoxGet(VarParam(x, 0))))))))

;; Finished: Evaluating proc to apply (in Applic #193)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic193
int 3
ContinueApplic193:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #193
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#193 of: ((lambda (flonum? rational?) (begin (set! VarParam(flonum?, 0) Box(VarParam(flonum?, 0)))  (set! VarParam(rational?, 1) Box(VarParam(rational?, 1)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (or (BoxGet(VarBound(flonum?, 0, 0)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(rational?, 0, 1)) BoxGet(VarParam(x, 0)))))))) VarFree(flonum?)  VarFree(rational?))

mov qword [fvar_tbl+8*30], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar number? to ((lambda (flonum? rational?) (begin (set! VarParam(flonum?, 0) Box(VarParam(flonum?, 0)))  (set! VarParam(rational?, 1) Box(VarParam(rational?, 1)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (or (BoxGet(VarBound(flonum?, 0, 0)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(rational?, 0, 1)) BoxGet(VarParam(x, 0)))))))) VarFree(flonum?)  VarFree(rational?))

	call write_sob_if_not_void

;; Starting: Set fvar length to ((lambda (fold-left +) (begin (set! VarParam(fold-left, 0) Box(VarParam(fold-left, 0)))  (set! VarParam(+, 1) Box(VarParam(+, 1)))  (lambda (l) (begin (set! VarParam(l, 0) Box(VarParam(l, 0)))  (BoxGet(VarBound(fold-left, 0, 0)) (lambda (acc e) (begin (set! VarParam(acc, 0) Box(VarParam(acc, 0)))  (set! VarParam(e, 1) Box(VarParam(e, 1)))  (BoxGet(VarBound(+, 1, 1)) BoxGet(VarParam(acc, 0))  1/1)))  0/1  BoxGet(VarParam(l, 0))))))) VarFree(fold-left)  VarFree(+))
;; Starting: Perform Applic#201 of: ((lambda (fold-left +) (begin (set! VarParam(fold-left, 0) Box(VarParam(fold-left, 0)))  (set! VarParam(+, 1) Box(VarParam(+, 1)))  (lambda (l) (begin (set! VarParam(l, 0) Box(VarParam(l, 0)))  (BoxGet(VarBound(fold-left, 0, 0)) (lambda (acc e) (begin (set! VarParam(acc, 0) Box(VarParam(acc, 0)))  (set! VarParam(e, 1) Box(VarParam(e, 1)))  (BoxGet(VarBound(+, 1, 1)) BoxGet(VarParam(acc, 0))  1/1)))  0/1  BoxGet(VarParam(l, 0))))))) VarFree(fold-left)  VarFree(+))
;; Starting: Argument 1 of Applic statement #201
mov rax, qword [fvar_tbl+8*15]	; mov fvar + to rax
;; Finished: Argument 1 of Applic statement #201

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #201
mov rax, qword [fvar_tbl+8*6]	; mov fvar fold-left to rax
;; Finished: Argument 0 of Applic statement #201

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #201)
;; Starting: Creating CLOSURE of LambdaSimple#202 -> (lambda (fold-left +) (begin (set! VarParam(fold-left, 0) Box(VarParam(fold-left, 0)))  (set! VarParam(+, 1) Box(VarParam(+, 1)))  (lambda (l) (begin (set! VarParam(l, 0) Box(VarParam(l, 0)))  (BoxGet(VarBound(fold-left, 0, 0)) (lambda (acc e) (begin (set! VarParam(acc, 0) Box(VarParam(acc, 0)))  (set! VarParam(e, 1) Box(VarParam(e, 1)))  (BoxGet(VarBound(+, 1, 1)) BoxGet(VarParam(acc, 0))  1/1)))  0/1  BoxGet(VarParam(l, 0)))))))
push rbx
; Env Extend Code Section For Closure#202
mov rbx, 0 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend202
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End202

LClosureEnvExtend202:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, -1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 0
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop202:
  jz LClosureEnvExtend_LoopEnd202
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop202

LClosureEnvExtend_LoopEnd202:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd202
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop202:
  jz LClosureEnvExtend_ParamsLoopEnd202

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop202

LClosureEnvExtend_ParamsLoopEnd202:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End202:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode202)
pop rbx
jmp LClosureCont202
LClosureCode202:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #203: (begin (set! VarParam(fold-left, 0) Box(VarParam(fold-left, 0)))  (set! VarParam(+, 1) Box(VarParam(+, 1)))  (lambda (l) (begin (set! VarParam(l, 0) Box(VarParam(l, 0)))  (BoxGet(VarBound(fold-left, 0, 0)) (lambda (acc e) (begin (set! VarParam(acc, 0) Box(VarParam(acc, 0)))  (set! VarParam(e, 1) Box(VarParam(e, 1)))  (BoxGet(VarBound(+, 1, 1)) BoxGet(VarParam(acc, 0))  1/1)))  0/1  BoxGet(VarParam(l, 0))))))
;; Starting: Item 0 in Seq statement #203
;; Starting: Set VarParam(name=fold-left, minor=0) with Box(VarParam(fold-left, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=fold-left, minor=0) with Box(VarParam(fold-left, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(fold-left, 0)
;; Starting: Get VarParam(name=fold-left, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=fold-left, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(fold-left, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=fold-left, minor=0) with Box(VarParam(fold-left, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=fold-left, minor=0) with Box(VarParam(fold-left, 0))

;; Finished: Item 0 in Seq statement #203


;; Starting: Item 1 in Seq statement #203
;; Starting: Set VarParam(name=+, minor=1) with Box(VarParam(+, 1))
;; Starting: Evaluating rhs for [ Set VarParam(name=+, minor=1) with Box(VarParam(+, 1)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(+, 1)
;; Starting: Get VarParam(name=+, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=+, minor=1)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(+, 1)

;; Finished: Evaluating rhs for [ Set VarParam(name=+, minor=1) with Box(VarParam(+, 1)) ], value is expected in rax

mov PVAR(1), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=+, minor=1) with Box(VarParam(+, 1))

;; Finished: Item 1 in Seq statement #203


;; Starting: Item 2 in Seq statement #203
;; Starting: Creating CLOSURE of LambdaSimple#204 -> (lambda (l) (begin (set! VarParam(l, 0) Box(VarParam(l, 0)))  (BoxGet(VarBound(fold-left, 0, 0)) (lambda (acc e) (begin (set! VarParam(acc, 0) Box(VarParam(acc, 0)))  (set! VarParam(e, 1) Box(VarParam(e, 1)))  (BoxGet(VarBound(+, 1, 1)) BoxGet(VarParam(acc, 0))  1/1)))  0/1  BoxGet(VarParam(l, 0)))))
push rbx
; Env Extend Code Section For Closure#204
mov rbx, 1 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend204
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End204

LClosureEnvExtend204:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 0
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 8
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop204:
  jz LClosureEnvExtend_LoopEnd204
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop204

LClosureEnvExtend_LoopEnd204:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd204
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop204:
  jz LClosureEnvExtend_ParamsLoopEnd204

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop204

LClosureEnvExtend_ParamsLoopEnd204:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End204:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode204)
pop rbx
jmp LClosureCont204
LClosureCode204:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #205: (begin (set! VarParam(l, 0) Box(VarParam(l, 0)))  (BoxGet(VarBound(fold-left, 0, 0)) (lambda (acc e) (begin (set! VarParam(acc, 0) Box(VarParam(acc, 0)))  (set! VarParam(e, 1) Box(VarParam(e, 1)))  (BoxGet(VarBound(+, 1, 1)) BoxGet(VarParam(acc, 0))  1/1)))  0/1  BoxGet(VarParam(l, 0))))
;; Starting: Item 0 in Seq statement #205
;; Starting: Set VarParam(name=l, minor=0) with Box(VarParam(l, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=l, minor=0) with Box(VarParam(l, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(l, 0)
;; Starting: Get VarParam(name=l, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=l, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(l, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=l, minor=0) with Box(VarParam(l, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=l, minor=0) with Box(VarParam(l, 0))

;; Finished: Item 0 in Seq statement #205


;; Starting: Item 1 in Seq statement #205
;; Starting: Perform Applic#206 of: (BoxGet(VarBound(fold-left, 0, 0)) (lambda (acc e) (begin (set! VarParam(acc, 0) Box(VarParam(acc, 0)))  (set! VarParam(e, 1) Box(VarParam(e, 1)))  (BoxGet(VarBound(+, 1, 1)) BoxGet(VarParam(acc, 0))  1/1)))  0/1  BoxGet(VarParam(l, 0)))
;; Starting: Argument 2 of Applic statement #206
;; Starting: BoxGet of VarParam(l, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(l, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=l, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=l, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(l, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(l, 0)

;; Finished: Argument 2 of Applic statement #206

push rax ; Push argument to stack;; Starting: Argument 1 of Applic statement #206
mov rax, const_tbl+34	; mov const 0/1 to rax
;; Finished: Argument 1 of Applic statement #206

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #206
;; Starting: Creating CLOSURE of LambdaSimple#207 -> (lambda (acc e) (begin (set! VarParam(acc, 0) Box(VarParam(acc, 0)))  (set! VarParam(e, 1) Box(VarParam(e, 1)))  (BoxGet(VarBound(+, 1, 1)) BoxGet(VarParam(acc, 0))  1/1)))
push rbx
; Env Extend Code Section For Closure#207
mov rbx, 2 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend207
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End207

LClosureEnvExtend207:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 16
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop207:
  jz LClosureEnvExtend_LoopEnd207
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop207

LClosureEnvExtend_LoopEnd207:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd207
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop207:
  jz LClosureEnvExtend_ParamsLoopEnd207

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop207

LClosureEnvExtend_ParamsLoopEnd207:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End207:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode207)
pop rbx
jmp LClosureCont207
LClosureCode207:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #208: (begin (set! VarParam(acc, 0) Box(VarParam(acc, 0)))  (set! VarParam(e, 1) Box(VarParam(e, 1)))  (BoxGet(VarBound(+, 1, 1)) BoxGet(VarParam(acc, 0))  1/1))
;; Starting: Item 0 in Seq statement #208
;; Starting: Set VarParam(name=acc, minor=0) with Box(VarParam(acc, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=acc, minor=0) with Box(VarParam(acc, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(acc, 0)
;; Starting: Get VarParam(name=acc, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=acc, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(acc, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=acc, minor=0) with Box(VarParam(acc, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=acc, minor=0) with Box(VarParam(acc, 0))

;; Finished: Item 0 in Seq statement #208


;; Starting: Item 1 in Seq statement #208
;; Starting: Set VarParam(name=e, minor=1) with Box(VarParam(e, 1))
;; Starting: Evaluating rhs for [ Set VarParam(name=e, minor=1) with Box(VarParam(e, 1)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(e, 1)
;; Starting: Get VarParam(name=e, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=e, minor=1)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(e, 1)

;; Finished: Evaluating rhs for [ Set VarParam(name=e, minor=1) with Box(VarParam(e, 1)) ], value is expected in rax

mov PVAR(1), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=e, minor=1) with Box(VarParam(e, 1))

;; Finished: Item 1 in Seq statement #208


;; Starting: Item 2 in Seq statement #208
;; Starting: Perform Applic#209 of: (BoxGet(VarBound(+, 1, 1)) BoxGet(VarParam(acc, 0))  1/1)
;; Starting: Argument 1 of Applic statement #209
mov rax, const_tbl+51	; mov const 1/1 to rax
;; Finished: Argument 1 of Applic statement #209

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #209
;; Starting: BoxGet of VarParam(acc, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(acc, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=acc, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=acc, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(acc, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(acc, 0)

;; Finished: Argument 0 of Applic statement #209

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #209)
;; Starting: BoxGet of VarBound(+, 1, 1)
;; Starting: Evaluating val for [ BoxGet of VarBound(+, 1, 1) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=+, major=1, minor=1)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
;; Finished: Get VarBound(name=+, major=1, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarBound(+, 1, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(+, 1, 1)

;; Finished: Evaluating proc to apply (in Applic #209)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic209
int 3
ContinueApplic209:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #209
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#209 of: (BoxGet(VarBound(+, 1, 1)) BoxGet(VarParam(acc, 0))  1/1)

;; Finished: Item 2 in Seq statement #208

;; Finished: Seq statement #208: (begin (set! VarParam(acc, 0) Box(VarParam(acc, 0)))  (set! VarParam(e, 1) Box(VarParam(e, 1)))  (BoxGet(VarBound(+, 1, 1)) BoxGet(VarParam(acc, 0))  1/1))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont207:

;; Finished: Creating CLOSURE of LambdaSimple#207 -> (lambda (acc e) (begin (set! VarParam(acc, 0) Box(VarParam(acc, 0)))  (set! VarParam(e, 1) Box(VarParam(e, 1)))  (BoxGet(VarBound(+, 1, 1)) BoxGet(VarParam(acc, 0))  1/1)))

;; Finished: Argument 0 of Applic statement #206

push rax ; Push argument to stack
push qword 3 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #206)
;; Starting: BoxGet of VarBound(fold-left, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(fold-left, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=fold-left, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=fold-left, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(fold-left, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(fold-left, 0, 0)

;; Finished: Evaluating proc to apply (in Applic #206)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic206
int 3
ContinueApplic206:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #206
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#206 of: (BoxGet(VarBound(fold-left, 0, 0)) (lambda (acc e) (begin (set! VarParam(acc, 0) Box(VarParam(acc, 0)))  (set! VarParam(e, 1) Box(VarParam(e, 1)))  (BoxGet(VarBound(+, 1, 1)) BoxGet(VarParam(acc, 0))  1/1)))  0/1  BoxGet(VarParam(l, 0)))

;; Finished: Item 1 in Seq statement #205

;; Finished: Seq statement #205: (begin (set! VarParam(l, 0) Box(VarParam(l, 0)))  (BoxGet(VarBound(fold-left, 0, 0)) (lambda (acc e) (begin (set! VarParam(acc, 0) Box(VarParam(acc, 0)))  (set! VarParam(e, 1) Box(VarParam(e, 1)))  (BoxGet(VarBound(+, 1, 1)) BoxGet(VarParam(acc, 0))  1/1)))  0/1  BoxGet(VarParam(l, 0))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont204:

;; Finished: Creating CLOSURE of LambdaSimple#204 -> (lambda (l) (begin (set! VarParam(l, 0) Box(VarParam(l, 0)))  (BoxGet(VarBound(fold-left, 0, 0)) (lambda (acc e) (begin (set! VarParam(acc, 0) Box(VarParam(acc, 0)))  (set! VarParam(e, 1) Box(VarParam(e, 1)))  (BoxGet(VarBound(+, 1, 1)) BoxGet(VarParam(acc, 0))  1/1)))  0/1  BoxGet(VarParam(l, 0)))))

;; Finished: Item 2 in Seq statement #203

;; Finished: Seq statement #203: (begin (set! VarParam(fold-left, 0) Box(VarParam(fold-left, 0)))  (set! VarParam(+, 1) Box(VarParam(+, 1)))  (lambda (l) (begin (set! VarParam(l, 0) Box(VarParam(l, 0)))  (BoxGet(VarBound(fold-left, 0, 0)) (lambda (acc e) (begin (set! VarParam(acc, 0) Box(VarParam(acc, 0)))  (set! VarParam(e, 1) Box(VarParam(e, 1)))  (BoxGet(VarBound(+, 1, 1)) BoxGet(VarParam(acc, 0))  1/1)))  0/1  BoxGet(VarParam(l, 0))))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont202:

;; Finished: Creating CLOSURE of LambdaSimple#202 -> (lambda (fold-left +) (begin (set! VarParam(fold-left, 0) Box(VarParam(fold-left, 0)))  (set! VarParam(+, 1) Box(VarParam(+, 1)))  (lambda (l) (begin (set! VarParam(l, 0) Box(VarParam(l, 0)))  (BoxGet(VarBound(fold-left, 0, 0)) (lambda (acc e) (begin (set! VarParam(acc, 0) Box(VarParam(acc, 0)))  (set! VarParam(e, 1) Box(VarParam(e, 1)))  (BoxGet(VarBound(+, 1, 1)) BoxGet(VarParam(acc, 0))  1/1)))  0/1  BoxGet(VarParam(l, 0)))))))

;; Finished: Evaluating proc to apply (in Applic #201)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic201
int 3
ContinueApplic201:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #201
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#201 of: ((lambda (fold-left +) (begin (set! VarParam(fold-left, 0) Box(VarParam(fold-left, 0)))  (set! VarParam(+, 1) Box(VarParam(+, 1)))  (lambda (l) (begin (set! VarParam(l, 0) Box(VarParam(l, 0)))  (BoxGet(VarBound(fold-left, 0, 0)) (lambda (acc e) (begin (set! VarParam(acc, 0) Box(VarParam(acc, 0)))  (set! VarParam(e, 1) Box(VarParam(e, 1)))  (BoxGet(VarBound(+, 1, 1)) BoxGet(VarParam(acc, 0))  1/1)))  0/1  BoxGet(VarParam(l, 0))))))) VarFree(fold-left)  VarFree(+))

mov qword [fvar_tbl+8*31], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar length to ((lambda (fold-left +) (begin (set! VarParam(fold-left, 0) Box(VarParam(fold-left, 0)))  (set! VarParam(+, 1) Box(VarParam(+, 1)))  (lambda (l) (begin (set! VarParam(l, 0) Box(VarParam(l, 0)))  (BoxGet(VarBound(fold-left, 0, 0)) (lambda (acc e) (begin (set! VarParam(acc, 0) Box(VarParam(acc, 0)))  (set! VarParam(e, 1) Box(VarParam(e, 1)))  (BoxGet(VarBound(+, 1, 1)) BoxGet(VarParam(acc, 0))  1/1)))  0/1  BoxGet(VarParam(l, 0))))))) VarFree(fold-left)  VarFree(+))

	call write_sob_if_not_void

;; Starting: Set fvar string->list to ((lambda (string-ref string-length < - cons) (begin (set! VarParam(string-ref, 0) Box(VarParam(string-ref, 0)))  (set! VarParam(string-length, 1) Box(VarParam(string-length, 1)))  (set! VarParam(<, 2) Box(VarParam(<, 2)))  (set! VarParam(-, 3) Box(VarParam(-, 3)))  (set! VarParam(cons, 4) Box(VarParam(cons, 4)))  (lambda (s) (begin (set! VarParam(s, 0) Box(VarParam(s, 0)))  ((lambda (s->l-loop) (begin (set! VarParam(s->l-loop, 0) Box(VarParam(s->l-loop, 0)))  BoxSet(VarParam(s->l-loop, 0), (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))))  (BoxGet(VarParam(s->l-loop, 0)) (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)  ()))) whatever))))) VarFree(string-ref)  VarFree(string-length)  VarFree(<)  VarFree(-)  VarFree(cons))
;; Starting: Perform Applic#210 of: ((lambda (string-ref string-length < - cons) (begin (set! VarParam(string-ref, 0) Box(VarParam(string-ref, 0)))  (set! VarParam(string-length, 1) Box(VarParam(string-length, 1)))  (set! VarParam(<, 2) Box(VarParam(<, 2)))  (set! VarParam(-, 3) Box(VarParam(-, 3)))  (set! VarParam(cons, 4) Box(VarParam(cons, 4)))  (lambda (s) (begin (set! VarParam(s, 0) Box(VarParam(s, 0)))  ((lambda (s->l-loop) (begin (set! VarParam(s->l-loop, 0) Box(VarParam(s->l-loop, 0)))  BoxSet(VarParam(s->l-loop, 0), (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))))  (BoxGet(VarParam(s->l-loop, 0)) (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)  ()))) whatever))))) VarFree(string-ref)  VarFree(string-length)  VarFree(<)  VarFree(-)  VarFree(cons))
;; Starting: Argument 4 of Applic statement #210
mov rax, qword [fvar_tbl+8*4]	; mov fvar cons to rax
;; Finished: Argument 4 of Applic statement #210

push rax ; Push argument to stack;; Starting: Argument 3 of Applic statement #210
mov rax, qword [fvar_tbl+8*26]	; mov fvar - to rax
;; Finished: Argument 3 of Applic statement #210

push rax ; Push argument to stack;; Starting: Argument 2 of Applic statement #210
mov rax, qword [fvar_tbl+8*22]	; mov fvar < to rax
;; Finished: Argument 2 of Applic statement #210

push rax ; Push argument to stack;; Starting: Argument 1 of Applic statement #210
mov rax, qword [fvar_tbl+8*34]	; mov fvar string-length to rax
;; Finished: Argument 1 of Applic statement #210

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #210
mov rax, qword [fvar_tbl+8*33]	; mov fvar string-ref to rax
;; Finished: Argument 0 of Applic statement #210

push rax ; Push argument to stack
push qword 5 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #210)
;; Starting: Creating CLOSURE of LambdaSimple#211 -> (lambda (string-ref string-length < - cons) (begin (set! VarParam(string-ref, 0) Box(VarParam(string-ref, 0)))  (set! VarParam(string-length, 1) Box(VarParam(string-length, 1)))  (set! VarParam(<, 2) Box(VarParam(<, 2)))  (set! VarParam(-, 3) Box(VarParam(-, 3)))  (set! VarParam(cons, 4) Box(VarParam(cons, 4)))  (lambda (s) (begin (set! VarParam(s, 0) Box(VarParam(s, 0)))  ((lambda (s->l-loop) (begin (set! VarParam(s->l-loop, 0) Box(VarParam(s->l-loop, 0)))  BoxSet(VarParam(s->l-loop, 0), (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))))  (BoxGet(VarParam(s->l-loop, 0)) (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)  ()))) whatever)))))
push rbx
; Env Extend Code Section For Closure#211
mov rbx, 0 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend211
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End211

LClosureEnvExtend211:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, -1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 0
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop211:
  jz LClosureEnvExtend_LoopEnd211
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop211

LClosureEnvExtend_LoopEnd211:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd211
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop211:
  jz LClosureEnvExtend_ParamsLoopEnd211

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop211

LClosureEnvExtend_ParamsLoopEnd211:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End211:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode211)
pop rbx
jmp LClosureCont211
LClosureCode211:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #212: (begin (set! VarParam(string-ref, 0) Box(VarParam(string-ref, 0)))  (set! VarParam(string-length, 1) Box(VarParam(string-length, 1)))  (set! VarParam(<, 2) Box(VarParam(<, 2)))  (set! VarParam(-, 3) Box(VarParam(-, 3)))  (set! VarParam(cons, 4) Box(VarParam(cons, 4)))  (lambda (s) (begin (set! VarParam(s, 0) Box(VarParam(s, 0)))  ((lambda (s->l-loop) (begin (set! VarParam(s->l-loop, 0) Box(VarParam(s->l-loop, 0)))  BoxSet(VarParam(s->l-loop, 0), (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))))  (BoxGet(VarParam(s->l-loop, 0)) (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)  ()))) whatever))))
;; Starting: Item 0 in Seq statement #212
;; Starting: Set VarParam(name=string-ref, minor=0) with Box(VarParam(string-ref, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=string-ref, minor=0) with Box(VarParam(string-ref, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(string-ref, 0)
;; Starting: Get VarParam(name=string-ref, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=string-ref, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(string-ref, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=string-ref, minor=0) with Box(VarParam(string-ref, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=string-ref, minor=0) with Box(VarParam(string-ref, 0))

;; Finished: Item 0 in Seq statement #212


;; Starting: Item 1 in Seq statement #212
;; Starting: Set VarParam(name=string-length, minor=1) with Box(VarParam(string-length, 1))
;; Starting: Evaluating rhs for [ Set VarParam(name=string-length, minor=1) with Box(VarParam(string-length, 1)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(string-length, 1)
;; Starting: Get VarParam(name=string-length, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=string-length, minor=1)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(string-length, 1)

;; Finished: Evaluating rhs for [ Set VarParam(name=string-length, minor=1) with Box(VarParam(string-length, 1)) ], value is expected in rax

mov PVAR(1), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=string-length, minor=1) with Box(VarParam(string-length, 1))

;; Finished: Item 1 in Seq statement #212


;; Starting: Item 2 in Seq statement #212
;; Starting: Set VarParam(name=<, minor=2) with Box(VarParam(<, 2))
;; Starting: Evaluating rhs for [ Set VarParam(name=<, minor=2) with Box(VarParam(<, 2)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(<, 2)
;; Starting: Get VarParam(name=<, minor=2)
mov rax, PVAR(2)
;; Finished: Get VarParam(name=<, minor=2)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(<, 2)

;; Finished: Evaluating rhs for [ Set VarParam(name=<, minor=2) with Box(VarParam(<, 2)) ], value is expected in rax

mov PVAR(2), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=<, minor=2) with Box(VarParam(<, 2))

;; Finished: Item 2 in Seq statement #212


;; Starting: Item 3 in Seq statement #212
;; Starting: Set VarParam(name=-, minor=3) with Box(VarParam(-, 3))
;; Starting: Evaluating rhs for [ Set VarParam(name=-, minor=3) with Box(VarParam(-, 3)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(-, 3)
;; Starting: Get VarParam(name=-, minor=3)
mov rax, PVAR(3)
;; Finished: Get VarParam(name=-, minor=3)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(-, 3)

;; Finished: Evaluating rhs for [ Set VarParam(name=-, minor=3) with Box(VarParam(-, 3)) ], value is expected in rax

mov PVAR(3), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=-, minor=3) with Box(VarParam(-, 3))

;; Finished: Item 3 in Seq statement #212


;; Starting: Item 4 in Seq statement #212
;; Starting: Set VarParam(name=cons, minor=4) with Box(VarParam(cons, 4))
;; Starting: Evaluating rhs for [ Set VarParam(name=cons, minor=4) with Box(VarParam(cons, 4)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(cons, 4)
;; Starting: Get VarParam(name=cons, minor=4)
mov rax, PVAR(4)
;; Finished: Get VarParam(name=cons, minor=4)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(cons, 4)

;; Finished: Evaluating rhs for [ Set VarParam(name=cons, minor=4) with Box(VarParam(cons, 4)) ], value is expected in rax

mov PVAR(4), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=cons, minor=4) with Box(VarParam(cons, 4))

;; Finished: Item 4 in Seq statement #212


;; Starting: Item 5 in Seq statement #212
;; Starting: Creating CLOSURE of LambdaSimple#213 -> (lambda (s) (begin (set! VarParam(s, 0) Box(VarParam(s, 0)))  ((lambda (s->l-loop) (begin (set! VarParam(s->l-loop, 0) Box(VarParam(s->l-loop, 0)))  BoxSet(VarParam(s->l-loop, 0), (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))))  (BoxGet(VarParam(s->l-loop, 0)) (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)  ()))) whatever)))
push rbx
; Env Extend Code Section For Closure#213
mov rbx, 1 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend213
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End213

LClosureEnvExtend213:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 0
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 8
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop213:
  jz LClosureEnvExtend_LoopEnd213
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop213

LClosureEnvExtend_LoopEnd213:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd213
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop213:
  jz LClosureEnvExtend_ParamsLoopEnd213

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop213

LClosureEnvExtend_ParamsLoopEnd213:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End213:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode213)
pop rbx
jmp LClosureCont213
LClosureCode213:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #214: (begin (set! VarParam(s, 0) Box(VarParam(s, 0)))  ((lambda (s->l-loop) (begin (set! VarParam(s->l-loop, 0) Box(VarParam(s->l-loop, 0)))  BoxSet(VarParam(s->l-loop, 0), (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))))  (BoxGet(VarParam(s->l-loop, 0)) (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)  ()))) whatever))
;; Starting: Item 0 in Seq statement #214
;; Starting: Set VarParam(name=s, minor=0) with Box(VarParam(s, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=s, minor=0) with Box(VarParam(s, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(s, 0)
;; Starting: Get VarParam(name=s, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=s, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(s, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=s, minor=0) with Box(VarParam(s, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=s, minor=0) with Box(VarParam(s, 0))

;; Finished: Item 0 in Seq statement #214


;; Starting: Item 1 in Seq statement #214
;; Starting: Perform Applic#215 of: ((lambda (s->l-loop) (begin (set! VarParam(s->l-loop, 0) Box(VarParam(s->l-loop, 0)))  BoxSet(VarParam(s->l-loop, 0), (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))))  (BoxGet(VarParam(s->l-loop, 0)) (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)  ()))) whatever)
;; Starting: Argument 0 of Applic statement #215
mov rax, const_tbl+23	; mov const whatever to rax
;; Finished: Argument 0 of Applic statement #215

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #215)
;; Starting: Creating CLOSURE of LambdaSimple#216 -> (lambda (s->l-loop) (begin (set! VarParam(s->l-loop, 0) Box(VarParam(s->l-loop, 0)))  BoxSet(VarParam(s->l-loop, 0), (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))))  (BoxGet(VarParam(s->l-loop, 0)) (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)  ())))
push rbx
; Env Extend Code Section For Closure#216
mov rbx, 2 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend216
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End216

LClosureEnvExtend216:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 16
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop216:
  jz LClosureEnvExtend_LoopEnd216
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop216

LClosureEnvExtend_LoopEnd216:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd216
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop216:
  jz LClosureEnvExtend_ParamsLoopEnd216

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop216

LClosureEnvExtend_ParamsLoopEnd216:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End216:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode216)
pop rbx
jmp LClosureCont216
LClosureCode216:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #217: (begin (set! VarParam(s->l-loop, 0) Box(VarParam(s->l-loop, 0)))  BoxSet(VarParam(s->l-loop, 0), (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))))  (BoxGet(VarParam(s->l-loop, 0)) (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)  ()))
;; Starting: Item 0 in Seq statement #217
;; Starting: Set VarParam(name=s->l-loop, minor=0) with Box(VarParam(s->l-loop, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=s->l-loop, minor=0) with Box(VarParam(s->l-loop, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(s->l-loop, 0)
;; Starting: Get VarParam(name=s->l-loop, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=s->l-loop, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(s->l-loop, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=s->l-loop, minor=0) with Box(VarParam(s->l-loop, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=s->l-loop, minor=0) with Box(VarParam(s->l-loop, 0))

;; Finished: Item 0 in Seq statement #217


;; Starting: Item 1 in Seq statement #217
;; Starting: BoxSet of VarParam(s->l-loop, 0) with (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1)))))
;; Starting: Evaluating rhs for [ BoxSet of VarParam(s->l-loop, 0) with (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))) ], the VALUE is expected in rax
;; Starting: Creating CLOSURE of LambdaSimple#218 -> (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1)))))
push rbx
; Env Extend Code Section For Closure#218
mov rbx, 3 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend218
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End218

LClosureEnvExtend218:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 2
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 24
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop218:
  jz LClosureEnvExtend_LoopEnd218
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop218

LClosureEnvExtend_LoopEnd218:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd218
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop218:
  jz LClosureEnvExtend_ParamsLoopEnd218

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop218

LClosureEnvExtend_ParamsLoopEnd218:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End218:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode218)
pop rbx
jmp LClosureCont218
LClosureCode218:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: If statement (#219): (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))
Lif219:
;; Starting: Perform Applic#220 of: (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1)
;; Starting: Argument 1 of Applic statement #220
mov rax, const_tbl+34	; mov const 0/1 to rax
;; Finished: Argument 1 of Applic statement #220

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #220
;; Starting: Get VarParam(name=n, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=n, minor=0)

;; Finished: Argument 0 of Applic statement #220

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #220)
;; Starting: BoxGet of VarBound(<, 2, 2)
;; Starting: Evaluating val for [ BoxGet of VarBound(<, 2, 2) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=<, major=2, minor=2)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 2]
;; Finished: Get VarBound(name=<, major=2, minor=2)

;; Finished: Evaluating val for [ BoxGet of VarBound(<, 2, 2) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(<, 2, 2)

;; Finished: Evaluating proc to apply (in Applic #220)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic220
int 3
ContinueApplic220:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #220
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#220 of: (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1)

cmp rax, SOB_FALSE_ADDRESS
je Lelse219
;; Starting: Get VarParam(name=a, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=a, minor=1)

jmp LendIf219
Lelse219:
;; Starting: Perform Applic#221 of: (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1)))
;; Starting: Argument 1 of Applic statement #221
;; Starting: Perform Applic#223 of: (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))
;; Starting: Argument 1 of Applic statement #223
;; Starting: Get VarParam(name=a, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=a, minor=1)

;; Finished: Argument 1 of Applic statement #223

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #223
;; Starting: Perform Applic#224 of: (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))
;; Starting: Argument 1 of Applic statement #224
;; Starting: Get VarParam(name=n, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=n, minor=0)

;; Finished: Argument 1 of Applic statement #224

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #224
;; Starting: BoxGet of VarBound(s, 1, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(s, 1, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=s, major=1, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=s, major=1, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(s, 1, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(s, 1, 0)

;; Finished: Argument 0 of Applic statement #224

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #224)
;; Starting: BoxGet of VarBound(string-ref, 2, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(string-ref, 2, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=string-ref, major=2, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=string-ref, major=2, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(string-ref, 2, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(string-ref, 2, 0)

;; Finished: Evaluating proc to apply (in Applic #224)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic224
int 3
ContinueApplic224:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #224
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#224 of: (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))

;; Finished: Argument 0 of Applic statement #223

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #223)
;; Starting: BoxGet of VarBound(cons, 2, 4)
;; Starting: Evaluating val for [ BoxGet of VarBound(cons, 2, 4) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=cons, major=2, minor=4)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 4]
;; Finished: Get VarBound(name=cons, major=2, minor=4)

;; Finished: Evaluating val for [ BoxGet of VarBound(cons, 2, 4) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(cons, 2, 4)

;; Finished: Evaluating proc to apply (in Applic #223)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic223
int 3
ContinueApplic223:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #223
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#223 of: (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))

;; Finished: Argument 1 of Applic statement #221

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #221
;; Starting: Perform Applic#222 of: (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)
;; Starting: Argument 1 of Applic statement #222
mov rax, const_tbl+51	; mov const 1/1 to rax
;; Finished: Argument 1 of Applic statement #222

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #222
;; Starting: Get VarParam(name=n, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=n, minor=0)

;; Finished: Argument 0 of Applic statement #222

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #222)
;; Starting: BoxGet of VarBound(-, 2, 3)
;; Starting: Evaluating val for [ BoxGet of VarBound(-, 2, 3) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=-, major=2, minor=3)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 3]
;; Finished: Get VarBound(name=-, major=2, minor=3)

;; Finished: Evaluating val for [ BoxGet of VarBound(-, 2, 3) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(-, 2, 3)

;; Finished: Evaluating proc to apply (in Applic #222)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic222
int 3
ContinueApplic222:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #222
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#222 of: (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)

;; Finished: Argument 0 of Applic statement #221

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #221)
;; Starting: BoxGet of VarBound(s->l-loop, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(s->l-loop, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=s->l-loop, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=s->l-loop, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(s->l-loop, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(s->l-loop, 0, 0)

;; Finished: Evaluating proc to apply (in Applic #221)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic221
int 3
ContinueApplic221:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #221
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#221 of: (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1)))

LendIf219:
;; Finished: If statement (#219): (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont218:

;; Finished: Creating CLOSURE of LambdaSimple#218 -> (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1)))))

;; Finished: Evaluating rhs for [ BoxSet of VarParam(s->l-loop, 0) with (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))) ], the VALUE is expected in rax

; Save the value of rhs
push rax
;; Starting: Evaluating var for [ BoxSet of VarParam(s->l-loop, 0) with (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=s->l-loop, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=s->l-loop, minor=0)

;; Finished: Evaluating var for [ BoxSet of VarParam(s->l-loop, 0) with (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))) ], the VALUE is expected in rax

; in RAX there is a address of a box, put the value we saved on stack earlier (from rhs) inside it
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;; Finished: BoxSet of VarParam(s->l-loop, 0) with (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1)))))

;; Finished: Item 1 in Seq statement #217


;; Starting: Item 2 in Seq statement #217
;; Starting: Perform Applic#225 of: (BoxGet(VarParam(s->l-loop, 0)) (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)  ())
;; Starting: Argument 1 of Applic statement #225
mov rax, const_tbl+1	; mov const () to rax
;; Finished: Argument 1 of Applic statement #225

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #225
;; Starting: Perform Applic#226 of: (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)
;; Starting: Argument 1 of Applic statement #226
mov rax, const_tbl+51	; mov const 1/1 to rax
;; Finished: Argument 1 of Applic statement #226

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #226
;; Starting: Perform Applic#227 of: (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))
;; Starting: Argument 0 of Applic statement #227
;; Starting: BoxGet of VarBound(s, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(s, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=s, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=s, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(s, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(s, 0, 0)

;; Finished: Argument 0 of Applic statement #227

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #227)
;; Starting: BoxGet of VarBound(string-length, 1, 1)
;; Starting: Evaluating val for [ BoxGet of VarBound(string-length, 1, 1) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=string-length, major=1, minor=1)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
;; Finished: Get VarBound(name=string-length, major=1, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarBound(string-length, 1, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(string-length, 1, 1)

;; Finished: Evaluating proc to apply (in Applic #227)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic227
int 3
ContinueApplic227:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #227
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#227 of: (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))

;; Finished: Argument 0 of Applic statement #226

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #226)
;; Starting: BoxGet of VarBound(-, 1, 3)
;; Starting: Evaluating val for [ BoxGet of VarBound(-, 1, 3) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=-, major=1, minor=3)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]
;; Finished: Get VarBound(name=-, major=1, minor=3)

;; Finished: Evaluating val for [ BoxGet of VarBound(-, 1, 3) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(-, 1, 3)

;; Finished: Evaluating proc to apply (in Applic #226)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic226
int 3
ContinueApplic226:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #226
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#226 of: (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)

;; Finished: Argument 0 of Applic statement #225

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #225)
;; Starting: BoxGet of VarParam(s->l-loop, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(s->l-loop, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=s->l-loop, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=s->l-loop, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(s->l-loop, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(s->l-loop, 0)

;; Finished: Evaluating proc to apply (in Applic #225)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic225
int 3
ContinueApplic225:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #225
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#225 of: (BoxGet(VarParam(s->l-loop, 0)) (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)  ())

;; Finished: Item 2 in Seq statement #217

;; Finished: Seq statement #217: (begin (set! VarParam(s->l-loop, 0) Box(VarParam(s->l-loop, 0)))  BoxSet(VarParam(s->l-loop, 0), (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))))  (BoxGet(VarParam(s->l-loop, 0)) (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)  ()))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont216:

;; Finished: Creating CLOSURE of LambdaSimple#216 -> (lambda (s->l-loop) (begin (set! VarParam(s->l-loop, 0) Box(VarParam(s->l-loop, 0)))  BoxSet(VarParam(s->l-loop, 0), (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))))  (BoxGet(VarParam(s->l-loop, 0)) (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)  ())))

;; Finished: Evaluating proc to apply (in Applic #215)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic215
int 3
ContinueApplic215:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #215
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#215 of: ((lambda (s->l-loop) (begin (set! VarParam(s->l-loop, 0) Box(VarParam(s->l-loop, 0)))  BoxSet(VarParam(s->l-loop, 0), (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))))  (BoxGet(VarParam(s->l-loop, 0)) (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)  ()))) whatever)

;; Finished: Item 1 in Seq statement #214

;; Finished: Seq statement #214: (begin (set! VarParam(s, 0) Box(VarParam(s, 0)))  ((lambda (s->l-loop) (begin (set! VarParam(s->l-loop, 0) Box(VarParam(s->l-loop, 0)))  BoxSet(VarParam(s->l-loop, 0), (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))))  (BoxGet(VarParam(s->l-loop, 0)) (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)  ()))) whatever))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont213:

;; Finished: Creating CLOSURE of LambdaSimple#213 -> (lambda (s) (begin (set! VarParam(s, 0) Box(VarParam(s, 0)))  ((lambda (s->l-loop) (begin (set! VarParam(s->l-loop, 0) Box(VarParam(s->l-loop, 0)))  BoxSet(VarParam(s->l-loop, 0), (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))))  (BoxGet(VarParam(s->l-loop, 0)) (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)  ()))) whatever)))

;; Finished: Item 5 in Seq statement #212

;; Finished: Seq statement #212: (begin (set! VarParam(string-ref, 0) Box(VarParam(string-ref, 0)))  (set! VarParam(string-length, 1) Box(VarParam(string-length, 1)))  (set! VarParam(<, 2) Box(VarParam(<, 2)))  (set! VarParam(-, 3) Box(VarParam(-, 3)))  (set! VarParam(cons, 4) Box(VarParam(cons, 4)))  (lambda (s) (begin (set! VarParam(s, 0) Box(VarParam(s, 0)))  ((lambda (s->l-loop) (begin (set! VarParam(s->l-loop, 0) Box(VarParam(s->l-loop, 0)))  BoxSet(VarParam(s->l-loop, 0), (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))))  (BoxGet(VarParam(s->l-loop, 0)) (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)  ()))) whatever))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont211:

;; Finished: Creating CLOSURE of LambdaSimple#211 -> (lambda (string-ref string-length < - cons) (begin (set! VarParam(string-ref, 0) Box(VarParam(string-ref, 0)))  (set! VarParam(string-length, 1) Box(VarParam(string-length, 1)))  (set! VarParam(<, 2) Box(VarParam(<, 2)))  (set! VarParam(-, 3) Box(VarParam(-, 3)))  (set! VarParam(cons, 4) Box(VarParam(cons, 4)))  (lambda (s) (begin (set! VarParam(s, 0) Box(VarParam(s, 0)))  ((lambda (s->l-loop) (begin (set! VarParam(s->l-loop, 0) Box(VarParam(s->l-loop, 0)))  BoxSet(VarParam(s->l-loop, 0), (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))))  (BoxGet(VarParam(s->l-loop, 0)) (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)  ()))) whatever)))))

;; Finished: Evaluating proc to apply (in Applic #210)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic210
int 3
ContinueApplic210:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #210
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#210 of: ((lambda (string-ref string-length < - cons) (begin (set! VarParam(string-ref, 0) Box(VarParam(string-ref, 0)))  (set! VarParam(string-length, 1) Box(VarParam(string-length, 1)))  (set! VarParam(<, 2) Box(VarParam(<, 2)))  (set! VarParam(-, 3) Box(VarParam(-, 3)))  (set! VarParam(cons, 4) Box(VarParam(cons, 4)))  (lambda (s) (begin (set! VarParam(s, 0) Box(VarParam(s, 0)))  ((lambda (s->l-loop) (begin (set! VarParam(s->l-loop, 0) Box(VarParam(s->l-loop, 0)))  BoxSet(VarParam(s->l-loop, 0), (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))))  (BoxGet(VarParam(s->l-loop, 0)) (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)  ()))) whatever))))) VarFree(string-ref)  VarFree(string-length)  VarFree(<)  VarFree(-)  VarFree(cons))

mov qword [fvar_tbl+8*32], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar string->list to ((lambda (string-ref string-length < - cons) (begin (set! VarParam(string-ref, 0) Box(VarParam(string-ref, 0)))  (set! VarParam(string-length, 1) Box(VarParam(string-length, 1)))  (set! VarParam(<, 2) Box(VarParam(<, 2)))  (set! VarParam(-, 3) Box(VarParam(-, 3)))  (set! VarParam(cons, 4) Box(VarParam(cons, 4)))  (lambda (s) (begin (set! VarParam(s, 0) Box(VarParam(s, 0)))  ((lambda (s->l-loop) (begin (set! VarParam(s->l-loop, 0) Box(VarParam(s->l-loop, 0)))  BoxSet(VarParam(s->l-loop, 0), (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))))  (BoxGet(VarParam(s->l-loop, 0)) (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)  ()))) whatever))))) VarFree(string-ref)  VarFree(string-length)  VarFree(<)  VarFree(-)  VarFree(cons))

	call write_sob_if_not_void

;; Starting: Set fvar equal? to ((lambda (= string->list rational? flonum? pair? char? string? eq? car cdr char->integer) (begin (set! VarParam(=, 0) Box(VarParam(=, 0)))  (set! VarParam(string->list, 1) Box(VarParam(string->list, 1)))  (set! VarParam(rational?, 2) Box(VarParam(rational?, 2)))  (set! VarParam(flonum?, 3) Box(VarParam(flonum?, 3)))  (set! VarParam(pair?, 4) Box(VarParam(pair?, 4)))  (set! VarParam(char?, 5) Box(VarParam(char?, 5)))  (set! VarParam(string?, 6) Box(VarParam(string?, 6)))  (set! VarParam(eq?, 7) Box(VarParam(eq?, 7)))  (set! VarParam(car, 8) Box(VarParam(car, 8)))  (set! VarParam(cdr, 9) Box(VarParam(cdr, 9)))  (set! VarParam(char->integer, 10) Box(VarParam(char->integer, 10)))  ((lambda (equal?-loop) (begin (set! VarParam(equal?-loop, 0) Box(VarParam(equal?-loop, 0)))  BoxSet(VarParam(equal?-loop, 0), (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))))))  BoxGet(VarParam(equal?-loop, 0)))) whatever))) VarFree(=)  VarFree(string->list)  VarFree(rational?)  VarFree(flonum?)  VarFree(pair?)  VarFree(char?)  VarFree(string?)  VarFree(eq?)  VarFree(car)  VarFree(cdr)  VarFree(char->integer))
;; Starting: Perform Applic#228 of: ((lambda (= string->list rational? flonum? pair? char? string? eq? car cdr char->integer) (begin (set! VarParam(=, 0) Box(VarParam(=, 0)))  (set! VarParam(string->list, 1) Box(VarParam(string->list, 1)))  (set! VarParam(rational?, 2) Box(VarParam(rational?, 2)))  (set! VarParam(flonum?, 3) Box(VarParam(flonum?, 3)))  (set! VarParam(pair?, 4) Box(VarParam(pair?, 4)))  (set! VarParam(char?, 5) Box(VarParam(char?, 5)))  (set! VarParam(string?, 6) Box(VarParam(string?, 6)))  (set! VarParam(eq?, 7) Box(VarParam(eq?, 7)))  (set! VarParam(car, 8) Box(VarParam(car, 8)))  (set! VarParam(cdr, 9) Box(VarParam(cdr, 9)))  (set! VarParam(char->integer, 10) Box(VarParam(char->integer, 10)))  ((lambda (equal?-loop) (begin (set! VarParam(equal?-loop, 0) Box(VarParam(equal?-loop, 0)))  BoxSet(VarParam(equal?-loop, 0), (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))))))  BoxGet(VarParam(equal?-loop, 0)))) whatever))) VarFree(=)  VarFree(string->list)  VarFree(rational?)  VarFree(flonum?)  VarFree(pair?)  VarFree(char?)  VarFree(string?)  VarFree(eq?)  VarFree(car)  VarFree(cdr)  VarFree(char->integer))
;; Starting: Argument 10 of Applic statement #228
mov rax, qword [fvar_tbl+8*39]	; mov fvar char->integer to rax
;; Finished: Argument 10 of Applic statement #228

push rax ; Push argument to stack;; Starting: Argument 9 of Applic statement #228
mov rax, qword [fvar_tbl+8*3]	; mov fvar cdr to rax
;; Finished: Argument 9 of Applic statement #228

push rax ; Push argument to stack;; Starting: Argument 8 of Applic statement #228
mov rax, qword [fvar_tbl+8*2]	; mov fvar car to rax
;; Finished: Argument 8 of Applic statement #228

push rax ; Push argument to stack;; Starting: Argument 7 of Applic statement #228
mov rax, qword [fvar_tbl+8*38]	; mov fvar eq? to rax
;; Finished: Argument 7 of Applic statement #228

push rax ; Push argument to stack;; Starting: Argument 6 of Applic statement #228
mov rax, qword [fvar_tbl+8*37]	; mov fvar string? to rax
;; Finished: Argument 6 of Applic statement #228

push rax ; Push argument to stack;; Starting: Argument 5 of Applic statement #228
mov rax, qword [fvar_tbl+8*36]	; mov fvar char? to rax
;; Finished: Argument 5 of Applic statement #228

push rax ; Push argument to stack;; Starting: Argument 4 of Applic statement #228
mov rax, qword [fvar_tbl+8*12]	; mov fvar pair? to rax
;; Finished: Argument 4 of Applic statement #228

push rax ; Push argument to stack;; Starting: Argument 3 of Applic statement #228
mov rax, qword [fvar_tbl+8*23]	; mov fvar flonum? to rax
;; Finished: Argument 3 of Applic statement #228

push rax ; Push argument to stack;; Starting: Argument 2 of Applic statement #228
mov rax, qword [fvar_tbl+8*24]	; mov fvar rational? to rax
;; Finished: Argument 2 of Applic statement #228

push rax ; Push argument to stack;; Starting: Argument 1 of Applic statement #228
mov rax, qword [fvar_tbl+8*32]	; mov fvar string->list to rax
;; Finished: Argument 1 of Applic statement #228

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #228
mov rax, qword [fvar_tbl+8*21]	; mov fvar = to rax
;; Finished: Argument 0 of Applic statement #228

push rax ; Push argument to stack
push qword 11 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #228)
;; Starting: Creating CLOSURE of LambdaSimple#229 -> (lambda (= string->list rational? flonum? pair? char? string? eq? car cdr char->integer) (begin (set! VarParam(=, 0) Box(VarParam(=, 0)))  (set! VarParam(string->list, 1) Box(VarParam(string->list, 1)))  (set! VarParam(rational?, 2) Box(VarParam(rational?, 2)))  (set! VarParam(flonum?, 3) Box(VarParam(flonum?, 3)))  (set! VarParam(pair?, 4) Box(VarParam(pair?, 4)))  (set! VarParam(char?, 5) Box(VarParam(char?, 5)))  (set! VarParam(string?, 6) Box(VarParam(string?, 6)))  (set! VarParam(eq?, 7) Box(VarParam(eq?, 7)))  (set! VarParam(car, 8) Box(VarParam(car, 8)))  (set! VarParam(cdr, 9) Box(VarParam(cdr, 9)))  (set! VarParam(char->integer, 10) Box(VarParam(char->integer, 10)))  ((lambda (equal?-loop) (begin (set! VarParam(equal?-loop, 0) Box(VarParam(equal?-loop, 0)))  BoxSet(VarParam(equal?-loop, 0), (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))))))  BoxGet(VarParam(equal?-loop, 0)))) whatever)))
push rbx
; Env Extend Code Section For Closure#229
mov rbx, 0 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend229
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End229

LClosureEnvExtend229:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, -1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 0
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop229:
  jz LClosureEnvExtend_LoopEnd229
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop229

LClosureEnvExtend_LoopEnd229:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd229
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop229:
  jz LClosureEnvExtend_ParamsLoopEnd229

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop229

LClosureEnvExtend_ParamsLoopEnd229:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End229:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode229)
pop rbx
jmp LClosureCont229
LClosureCode229:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #230: (begin (set! VarParam(=, 0) Box(VarParam(=, 0)))  (set! VarParam(string->list, 1) Box(VarParam(string->list, 1)))  (set! VarParam(rational?, 2) Box(VarParam(rational?, 2)))  (set! VarParam(flonum?, 3) Box(VarParam(flonum?, 3)))  (set! VarParam(pair?, 4) Box(VarParam(pair?, 4)))  (set! VarParam(char?, 5) Box(VarParam(char?, 5)))  (set! VarParam(string?, 6) Box(VarParam(string?, 6)))  (set! VarParam(eq?, 7) Box(VarParam(eq?, 7)))  (set! VarParam(car, 8) Box(VarParam(car, 8)))  (set! VarParam(cdr, 9) Box(VarParam(cdr, 9)))  (set! VarParam(char->integer, 10) Box(VarParam(char->integer, 10)))  ((lambda (equal?-loop) (begin (set! VarParam(equal?-loop, 0) Box(VarParam(equal?-loop, 0)))  BoxSet(VarParam(equal?-loop, 0), (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))))))  BoxGet(VarParam(equal?-loop, 0)))) whatever))
;; Starting: Item 0 in Seq statement #230
;; Starting: Set VarParam(name==, minor=0) with Box(VarParam(=, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name==, minor=0) with Box(VarParam(=, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(=, 0)
;; Starting: Get VarParam(name==, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name==, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(=, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name==, minor=0) with Box(VarParam(=, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name==, minor=0) with Box(VarParam(=, 0))

;; Finished: Item 0 in Seq statement #230


;; Starting: Item 1 in Seq statement #230
;; Starting: Set VarParam(name=string->list, minor=1) with Box(VarParam(string->list, 1))
;; Starting: Evaluating rhs for [ Set VarParam(name=string->list, minor=1) with Box(VarParam(string->list, 1)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(string->list, 1)
;; Starting: Get VarParam(name=string->list, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=string->list, minor=1)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(string->list, 1)

;; Finished: Evaluating rhs for [ Set VarParam(name=string->list, minor=1) with Box(VarParam(string->list, 1)) ], value is expected in rax

mov PVAR(1), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=string->list, minor=1) with Box(VarParam(string->list, 1))

;; Finished: Item 1 in Seq statement #230


;; Starting: Item 2 in Seq statement #230
;; Starting: Set VarParam(name=rational?, minor=2) with Box(VarParam(rational?, 2))
;; Starting: Evaluating rhs for [ Set VarParam(name=rational?, minor=2) with Box(VarParam(rational?, 2)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(rational?, 2)
;; Starting: Get VarParam(name=rational?, minor=2)
mov rax, PVAR(2)
;; Finished: Get VarParam(name=rational?, minor=2)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(rational?, 2)

;; Finished: Evaluating rhs for [ Set VarParam(name=rational?, minor=2) with Box(VarParam(rational?, 2)) ], value is expected in rax

mov PVAR(2), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=rational?, minor=2) with Box(VarParam(rational?, 2))

;; Finished: Item 2 in Seq statement #230


;; Starting: Item 3 in Seq statement #230
;; Starting: Set VarParam(name=flonum?, minor=3) with Box(VarParam(flonum?, 3))
;; Starting: Evaluating rhs for [ Set VarParam(name=flonum?, minor=3) with Box(VarParam(flonum?, 3)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(flonum?, 3)
;; Starting: Get VarParam(name=flonum?, minor=3)
mov rax, PVAR(3)
;; Finished: Get VarParam(name=flonum?, minor=3)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(flonum?, 3)

;; Finished: Evaluating rhs for [ Set VarParam(name=flonum?, minor=3) with Box(VarParam(flonum?, 3)) ], value is expected in rax

mov PVAR(3), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=flonum?, minor=3) with Box(VarParam(flonum?, 3))

;; Finished: Item 3 in Seq statement #230


;; Starting: Item 4 in Seq statement #230
;; Starting: Set VarParam(name=pair?, minor=4) with Box(VarParam(pair?, 4))
;; Starting: Evaluating rhs for [ Set VarParam(name=pair?, minor=4) with Box(VarParam(pair?, 4)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(pair?, 4)
;; Starting: Get VarParam(name=pair?, minor=4)
mov rax, PVAR(4)
;; Finished: Get VarParam(name=pair?, minor=4)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(pair?, 4)

;; Finished: Evaluating rhs for [ Set VarParam(name=pair?, minor=4) with Box(VarParam(pair?, 4)) ], value is expected in rax

mov PVAR(4), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=pair?, minor=4) with Box(VarParam(pair?, 4))

;; Finished: Item 4 in Seq statement #230


;; Starting: Item 5 in Seq statement #230
;; Starting: Set VarParam(name=char?, minor=5) with Box(VarParam(char?, 5))
;; Starting: Evaluating rhs for [ Set VarParam(name=char?, minor=5) with Box(VarParam(char?, 5)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(char?, 5)
;; Starting: Get VarParam(name=char?, minor=5)
mov rax, PVAR(5)
;; Finished: Get VarParam(name=char?, minor=5)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(char?, 5)

;; Finished: Evaluating rhs for [ Set VarParam(name=char?, minor=5) with Box(VarParam(char?, 5)) ], value is expected in rax

mov PVAR(5), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=char?, minor=5) with Box(VarParam(char?, 5))

;; Finished: Item 5 in Seq statement #230


;; Starting: Item 6 in Seq statement #230
;; Starting: Set VarParam(name=string?, minor=6) with Box(VarParam(string?, 6))
;; Starting: Evaluating rhs for [ Set VarParam(name=string?, minor=6) with Box(VarParam(string?, 6)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(string?, 6)
;; Starting: Get VarParam(name=string?, minor=6)
mov rax, PVAR(6)
;; Finished: Get VarParam(name=string?, minor=6)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(string?, 6)

;; Finished: Evaluating rhs for [ Set VarParam(name=string?, minor=6) with Box(VarParam(string?, 6)) ], value is expected in rax

mov PVAR(6), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=string?, minor=6) with Box(VarParam(string?, 6))

;; Finished: Item 6 in Seq statement #230


;; Starting: Item 7 in Seq statement #230
;; Starting: Set VarParam(name=eq?, minor=7) with Box(VarParam(eq?, 7))
;; Starting: Evaluating rhs for [ Set VarParam(name=eq?, minor=7) with Box(VarParam(eq?, 7)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(eq?, 7)
;; Starting: Get VarParam(name=eq?, minor=7)
mov rax, PVAR(7)
;; Finished: Get VarParam(name=eq?, minor=7)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(eq?, 7)

;; Finished: Evaluating rhs for [ Set VarParam(name=eq?, minor=7) with Box(VarParam(eq?, 7)) ], value is expected in rax

mov PVAR(7), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=eq?, minor=7) with Box(VarParam(eq?, 7))

;; Finished: Item 7 in Seq statement #230


;; Starting: Item 8 in Seq statement #230
;; Starting: Set VarParam(name=car, minor=8) with Box(VarParam(car, 8))
;; Starting: Evaluating rhs for [ Set VarParam(name=car, minor=8) with Box(VarParam(car, 8)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(car, 8)
;; Starting: Get VarParam(name=car, minor=8)
mov rax, PVAR(8)
;; Finished: Get VarParam(name=car, minor=8)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(car, 8)

;; Finished: Evaluating rhs for [ Set VarParam(name=car, minor=8) with Box(VarParam(car, 8)) ], value is expected in rax

mov PVAR(8), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=car, minor=8) with Box(VarParam(car, 8))

;; Finished: Item 8 in Seq statement #230


;; Starting: Item 9 in Seq statement #230
;; Starting: Set VarParam(name=cdr, minor=9) with Box(VarParam(cdr, 9))
;; Starting: Evaluating rhs for [ Set VarParam(name=cdr, minor=9) with Box(VarParam(cdr, 9)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(cdr, 9)
;; Starting: Get VarParam(name=cdr, minor=9)
mov rax, PVAR(9)
;; Finished: Get VarParam(name=cdr, minor=9)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(cdr, 9)

;; Finished: Evaluating rhs for [ Set VarParam(name=cdr, minor=9) with Box(VarParam(cdr, 9)) ], value is expected in rax

mov PVAR(9), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=cdr, minor=9) with Box(VarParam(cdr, 9))

;; Finished: Item 9 in Seq statement #230


;; Starting: Item 10 in Seq statement #230
;; Starting: Set VarParam(name=char->integer, minor=10) with Box(VarParam(char->integer, 10))
;; Starting: Evaluating rhs for [ Set VarParam(name=char->integer, minor=10) with Box(VarParam(char->integer, 10)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(char->integer, 10)
;; Starting: Get VarParam(name=char->integer, minor=10)
mov rax, PVAR(10)
;; Finished: Get VarParam(name=char->integer, minor=10)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(char->integer, 10)

;; Finished: Evaluating rhs for [ Set VarParam(name=char->integer, minor=10) with Box(VarParam(char->integer, 10)) ], value is expected in rax

mov PVAR(10), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=char->integer, minor=10) with Box(VarParam(char->integer, 10))

;; Finished: Item 10 in Seq statement #230


;; Starting: Item 11 in Seq statement #230
;; Starting: Perform Applic#231 of: ((lambda (equal?-loop) (begin (set! VarParam(equal?-loop, 0) Box(VarParam(equal?-loop, 0)))  BoxSet(VarParam(equal?-loop, 0), (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))))))  BoxGet(VarParam(equal?-loop, 0)))) whatever)
;; Starting: Argument 0 of Applic statement #231
mov rax, const_tbl+23	; mov const whatever to rax
;; Finished: Argument 0 of Applic statement #231

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #231)
;; Starting: Creating CLOSURE of LambdaSimple#232 -> (lambda (equal?-loop) (begin (set! VarParam(equal?-loop, 0) Box(VarParam(equal?-loop, 0)))  BoxSet(VarParam(equal?-loop, 0), (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))))))  BoxGet(VarParam(equal?-loop, 0))))
push rbx
; Env Extend Code Section For Closure#232
mov rbx, 1 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend232
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End232

LClosureEnvExtend232:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 0
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 8
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop232:
  jz LClosureEnvExtend_LoopEnd232
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop232

LClosureEnvExtend_LoopEnd232:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd232
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop232:
  jz LClosureEnvExtend_ParamsLoopEnd232

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop232

LClosureEnvExtend_ParamsLoopEnd232:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End232:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode232)
pop rbx
jmp LClosureCont232
LClosureCode232:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #233: (begin (set! VarParam(equal?-loop, 0) Box(VarParam(equal?-loop, 0)))  BoxSet(VarParam(equal?-loop, 0), (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))))))  BoxGet(VarParam(equal?-loop, 0)))
;; Starting: Item 0 in Seq statement #233
;; Starting: Set VarParam(name=equal?-loop, minor=0) with Box(VarParam(equal?-loop, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=equal?-loop, minor=0) with Box(VarParam(equal?-loop, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(equal?-loop, 0)
;; Starting: Get VarParam(name=equal?-loop, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=equal?-loop, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(equal?-loop, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=equal?-loop, minor=0) with Box(VarParam(equal?-loop, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=equal?-loop, minor=0) with Box(VarParam(equal?-loop, 0))

;; Finished: Item 0 in Seq statement #233


;; Starting: Item 1 in Seq statement #233
;; Starting: BoxSet of VarParam(equal?-loop, 0) with (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1))))))))
;; Starting: Evaluating rhs for [ BoxSet of VarParam(equal?-loop, 0) with (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))))) ], the VALUE is expected in rax
;; Starting: Creating CLOSURE of LambdaSimple#234 -> (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1))))))))
push rbx
; Env Extend Code Section For Closure#234
mov rbx, 2 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend234
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End234

LClosureEnvExtend234:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 16
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop234:
  jz LClosureEnvExtend_LoopEnd234
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop234

LClosureEnvExtend_LoopEnd234:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd234
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop234:
  jz LClosureEnvExtend_ParamsLoopEnd234

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop234

LClosureEnvExtend_ParamsLoopEnd234:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End234:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode234)
pop rbx
jmp LClosureCont234
LClosureCode234:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: If statement (#235): (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))))
Lif235:
;; Starting: If statement (#236): (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f)
Lif236:
;; Starting: Perform Applic#237 of: (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0))
;; Starting: Argument 0 of Applic statement #237
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Argument 0 of Applic statement #237

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #237)
;; Starting: BoxGet of VarBound(rational?, 1, 2)
;; Starting: Evaluating val for [ BoxGet of VarBound(rational?, 1, 2) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=rational?, major=1, minor=2)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]
;; Finished: Get VarBound(name=rational?, major=1, minor=2)

;; Finished: Evaluating val for [ BoxGet of VarBound(rational?, 1, 2) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(rational?, 1, 2)

;; Finished: Evaluating proc to apply (in Applic #237)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic237
int 3
ContinueApplic237:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #237
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#237 of: (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0))

cmp rax, SOB_FALSE_ADDRESS
je Lelse236
;; Starting: Perform Applic#238 of: (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1))
;; Starting: Argument 0 of Applic statement #238
;; Starting: Get VarParam(name=y, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=y, minor=1)

;; Finished: Argument 0 of Applic statement #238

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #238)
;; Starting: BoxGet of VarBound(rational?, 1, 2)
;; Starting: Evaluating val for [ BoxGet of VarBound(rational?, 1, 2) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=rational?, major=1, minor=2)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]
;; Finished: Get VarBound(name=rational?, major=1, minor=2)

;; Finished: Evaluating val for [ BoxGet of VarBound(rational?, 1, 2) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(rational?, 1, 2)

;; Finished: Evaluating proc to apply (in Applic #238)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic238
int 3
ContinueApplic238:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #238
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#238 of: (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1))

jmp LendIf236
Lelse236:
mov rax, const_tbl+2	; mov const #f to rax
LendIf236:
;; Finished: If statement (#236): (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f)

cmp rax, SOB_FALSE_ADDRESS
je Lelse235
;; Starting: Perform Applic#239 of: (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1))
;; Starting: Argument 1 of Applic statement #239
;; Starting: Get VarParam(name=y, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=y, minor=1)

;; Finished: Argument 1 of Applic statement #239

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #239
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Argument 0 of Applic statement #239

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #239)
;; Starting: BoxGet of VarBound(=, 1, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(=, 1, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name==, major=1, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name==, major=1, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(=, 1, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(=, 1, 0)

;; Finished: Evaluating proc to apply (in Applic #239)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic239
int 3
ContinueApplic239:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #239
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#239 of: (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1))

jmp LendIf235
Lelse235:
;; Starting: If statement (#240): (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1))))))
Lif240:
;; Starting: If statement (#241): (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f)
Lif241:
;; Starting: Perform Applic#242 of: (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0))
;; Starting: Argument 0 of Applic statement #242
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Argument 0 of Applic statement #242

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #242)
;; Starting: BoxGet of VarBound(flonum?, 1, 3)
;; Starting: Evaluating val for [ BoxGet of VarBound(flonum?, 1, 3) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=flonum?, major=1, minor=3)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]
;; Finished: Get VarBound(name=flonum?, major=1, minor=3)

;; Finished: Evaluating val for [ BoxGet of VarBound(flonum?, 1, 3) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(flonum?, 1, 3)

;; Finished: Evaluating proc to apply (in Applic #242)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic242
int 3
ContinueApplic242:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #242
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#242 of: (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0))

cmp rax, SOB_FALSE_ADDRESS
je Lelse241
;; Starting: Perform Applic#243 of: (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1))
;; Starting: Argument 0 of Applic statement #243
;; Starting: Get VarParam(name=y, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=y, minor=1)

;; Finished: Argument 0 of Applic statement #243

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #243)
;; Starting: BoxGet of VarBound(flonum?, 1, 3)
;; Starting: Evaluating val for [ BoxGet of VarBound(flonum?, 1, 3) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=flonum?, major=1, minor=3)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]
;; Finished: Get VarBound(name=flonum?, major=1, minor=3)

;; Finished: Evaluating val for [ BoxGet of VarBound(flonum?, 1, 3) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(flonum?, 1, 3)

;; Finished: Evaluating proc to apply (in Applic #243)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic243
int 3
ContinueApplic243:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #243
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#243 of: (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1))

jmp LendIf241
Lelse241:
mov rax, const_tbl+2	; mov const #f to rax
LendIf241:
;; Finished: If statement (#241): (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f)

cmp rax, SOB_FALSE_ADDRESS
je Lelse240
;; Starting: Perform Applic#244 of: (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1))
;; Starting: Argument 1 of Applic statement #244
;; Starting: Get VarParam(name=y, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=y, minor=1)

;; Finished: Argument 1 of Applic statement #244

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #244
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Argument 0 of Applic statement #244

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #244)
;; Starting: BoxGet of VarBound(=, 1, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(=, 1, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name==, major=1, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name==, major=1, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(=, 1, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(=, 1, 0)

;; Finished: Evaluating proc to apply (in Applic #244)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic244
int 3
ContinueApplic244:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #244
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#244 of: (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1))

jmp LendIf240
Lelse240:
;; Starting: If statement (#245): (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))
Lif245:
;; Starting: If statement (#246): (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f)
Lif246:
;; Starting: Perform Applic#247 of: (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0))
;; Starting: Argument 0 of Applic statement #247
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Argument 0 of Applic statement #247

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #247)
;; Starting: BoxGet of VarBound(char?, 1, 5)
;; Starting: Evaluating val for [ BoxGet of VarBound(char?, 1, 5) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=char?, major=1, minor=5)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 5]
;; Finished: Get VarBound(name=char?, major=1, minor=5)

;; Finished: Evaluating val for [ BoxGet of VarBound(char?, 1, 5) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(char?, 1, 5)

;; Finished: Evaluating proc to apply (in Applic #247)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic247
int 3
ContinueApplic247:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #247
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#247 of: (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0))

cmp rax, SOB_FALSE_ADDRESS
je Lelse246
;; Starting: Perform Applic#248 of: (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1))
;; Starting: Argument 0 of Applic statement #248
;; Starting: Get VarParam(name=y, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=y, minor=1)

;; Finished: Argument 0 of Applic statement #248

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #248)
;; Starting: BoxGet of VarBound(char?, 1, 5)
;; Starting: Evaluating val for [ BoxGet of VarBound(char?, 1, 5) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=char?, major=1, minor=5)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 5]
;; Finished: Get VarBound(name=char?, major=1, minor=5)

;; Finished: Evaluating val for [ BoxGet of VarBound(char?, 1, 5) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(char?, 1, 5)

;; Finished: Evaluating proc to apply (in Applic #248)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic248
int 3
ContinueApplic248:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #248
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#248 of: (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1))

jmp LendIf246
Lelse246:
mov rax, const_tbl+2	; mov const #f to rax
LendIf246:
;; Finished: If statement (#246): (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f)

cmp rax, SOB_FALSE_ADDRESS
je Lelse245
;; Starting: Perform Applic#249 of: (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1)))
;; Starting: Argument 1 of Applic statement #249
;; Starting: Perform Applic#251 of: (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))
;; Starting: Argument 0 of Applic statement #251
;; Starting: Get VarParam(name=y, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=y, minor=1)

;; Finished: Argument 0 of Applic statement #251

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #251)
;; Starting: BoxGet of VarBound(char->integer, 1, 10)
;; Starting: Evaluating val for [ BoxGet of VarBound(char->integer, 1, 10) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=char->integer, major=1, minor=10)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 10]
;; Finished: Get VarBound(name=char->integer, major=1, minor=10)

;; Finished: Evaluating val for [ BoxGet of VarBound(char->integer, 1, 10) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(char->integer, 1, 10)

;; Finished: Evaluating proc to apply (in Applic #251)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic251
int 3
ContinueApplic251:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #251
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#251 of: (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))

;; Finished: Argument 1 of Applic statement #249

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #249
;; Starting: Perform Applic#250 of: (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))
;; Starting: Argument 0 of Applic statement #250
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Argument 0 of Applic statement #250

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #250)
;; Starting: BoxGet of VarBound(char->integer, 1, 10)
;; Starting: Evaluating val for [ BoxGet of VarBound(char->integer, 1, 10) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=char->integer, major=1, minor=10)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 10]
;; Finished: Get VarBound(name=char->integer, major=1, minor=10)

;; Finished: Evaluating val for [ BoxGet of VarBound(char->integer, 1, 10) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(char->integer, 1, 10)

;; Finished: Evaluating proc to apply (in Applic #250)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic250
int 3
ContinueApplic250:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #250
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#250 of: (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))

;; Finished: Argument 0 of Applic statement #249

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #249)
;; Starting: BoxGet of VarBound(=, 1, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(=, 1, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name==, major=1, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name==, major=1, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(=, 1, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(=, 1, 0)

;; Finished: Evaluating proc to apply (in Applic #249)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic249
int 3
ContinueApplic249:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #249
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#249 of: (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1)))

jmp LendIf245
Lelse245:
;; Starting: If statement (#252): (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1))))
Lif252:
;; Starting: If statement (#253): (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f)
Lif253:
;; Starting: Perform Applic#254 of: (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0))
;; Starting: Argument 0 of Applic statement #254
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Argument 0 of Applic statement #254

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #254)
;; Starting: BoxGet of VarBound(pair?, 1, 4)
;; Starting: Evaluating val for [ BoxGet of VarBound(pair?, 1, 4) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=pair?, major=1, minor=4)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 4]
;; Finished: Get VarBound(name=pair?, major=1, minor=4)

;; Finished: Evaluating val for [ BoxGet of VarBound(pair?, 1, 4) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(pair?, 1, 4)

;; Finished: Evaluating proc to apply (in Applic #254)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic254
int 3
ContinueApplic254:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #254
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#254 of: (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0))

cmp rax, SOB_FALSE_ADDRESS
je Lelse253
;; Starting: Perform Applic#255 of: (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1))
;; Starting: Argument 0 of Applic statement #255
;; Starting: Get VarParam(name=y, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=y, minor=1)

;; Finished: Argument 0 of Applic statement #255

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #255)
;; Starting: BoxGet of VarBound(pair?, 1, 4)
;; Starting: Evaluating val for [ BoxGet of VarBound(pair?, 1, 4) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=pair?, major=1, minor=4)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 4]
;; Finished: Get VarBound(name=pair?, major=1, minor=4)

;; Finished: Evaluating val for [ BoxGet of VarBound(pair?, 1, 4) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(pair?, 1, 4)

;; Finished: Evaluating proc to apply (in Applic #255)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic255
int 3
ContinueApplic255:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #255
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#255 of: (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1))

jmp LendIf253
Lelse253:
mov rax, const_tbl+2	; mov const #f to rax
LendIf253:
;; Finished: If statement (#253): (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f)

cmp rax, SOB_FALSE_ADDRESS
je Lelse252
;; Starting: Seq statement #256: (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1))))
;; Starting: Item 0 in Seq statement #256
;; Starting: Perform Applic#257 of: (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))
;; Starting: Argument 1 of Applic statement #257
;; Starting: Perform Applic#259 of: (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1))
;; Starting: Argument 0 of Applic statement #259
;; Starting: Get VarParam(name=y, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=y, minor=1)

;; Finished: Argument 0 of Applic statement #259

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #259)
;; Starting: BoxGet of VarBound(car, 1, 8)
;; Starting: Evaluating val for [ BoxGet of VarBound(car, 1, 8) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=car, major=1, minor=8)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 8]
;; Finished: Get VarBound(name=car, major=1, minor=8)

;; Finished: Evaluating val for [ BoxGet of VarBound(car, 1, 8) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(car, 1, 8)

;; Finished: Evaluating proc to apply (in Applic #259)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic259
int 3
ContinueApplic259:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #259
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#259 of: (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1))

;; Finished: Argument 1 of Applic statement #257

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #257
;; Starting: Perform Applic#258 of: (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))
;; Starting: Argument 0 of Applic statement #258
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Argument 0 of Applic statement #258

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #258)
;; Starting: BoxGet of VarBound(car, 1, 8)
;; Starting: Evaluating val for [ BoxGet of VarBound(car, 1, 8) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=car, major=1, minor=8)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 8]
;; Finished: Get VarBound(name=car, major=1, minor=8)

;; Finished: Evaluating val for [ BoxGet of VarBound(car, 1, 8) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(car, 1, 8)

;; Finished: Evaluating proc to apply (in Applic #258)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic258
int 3
ContinueApplic258:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #258
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#258 of: (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))

;; Finished: Argument 0 of Applic statement #257

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #257)
;; Starting: BoxGet of VarBound(equal?-loop, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(equal?-loop, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=equal?-loop, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=equal?-loop, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(equal?-loop, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(equal?-loop, 0, 0)

;; Finished: Evaluating proc to apply (in Applic #257)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic257
int 3
ContinueApplic257:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #257
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#257 of: (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))

;; Finished: Item 0 in Seq statement #256


;; Starting: Item 1 in Seq statement #256
;; Starting: Perform Applic#260 of: (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))
;; Starting: Argument 1 of Applic statement #260
;; Starting: Perform Applic#262 of: (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1))
;; Starting: Argument 0 of Applic statement #262
;; Starting: Get VarParam(name=y, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=y, minor=1)

;; Finished: Argument 0 of Applic statement #262

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #262)
;; Starting: BoxGet of VarBound(cdr, 1, 9)
;; Starting: Evaluating val for [ BoxGet of VarBound(cdr, 1, 9) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=cdr, major=1, minor=9)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 9]
;; Finished: Get VarBound(name=cdr, major=1, minor=9)

;; Finished: Evaluating val for [ BoxGet of VarBound(cdr, 1, 9) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(cdr, 1, 9)

;; Finished: Evaluating proc to apply (in Applic #262)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic262
int 3
ContinueApplic262:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #262
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#262 of: (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1))

;; Finished: Argument 1 of Applic statement #260

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #260
;; Starting: Perform Applic#261 of: (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))
;; Starting: Argument 0 of Applic statement #261
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Argument 0 of Applic statement #261

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #261)
;; Starting: BoxGet of VarBound(cdr, 1, 9)
;; Starting: Evaluating val for [ BoxGet of VarBound(cdr, 1, 9) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=cdr, major=1, minor=9)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 9]
;; Finished: Get VarBound(name=cdr, major=1, minor=9)

;; Finished: Evaluating val for [ BoxGet of VarBound(cdr, 1, 9) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(cdr, 1, 9)

;; Finished: Evaluating proc to apply (in Applic #261)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic261
int 3
ContinueApplic261:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #261
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#261 of: (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))

;; Finished: Argument 0 of Applic statement #260

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #260)
;; Starting: BoxGet of VarBound(equal?-loop, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(equal?-loop, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=equal?-loop, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=equal?-loop, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(equal?-loop, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(equal?-loop, 0, 0)

;; Finished: Evaluating proc to apply (in Applic #260)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic260
int 3
ContinueApplic260:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #260
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#260 of: (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))

;; Finished: Item 1 in Seq statement #256

;; Finished: Seq statement #256: (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1))))

jmp LendIf252
Lelse252:
;; Starting: If statement (#263): (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))
Lif263:
;; Starting: If statement (#264): (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f)
Lif264:
;; Starting: Perform Applic#265 of: (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0))
;; Starting: Argument 0 of Applic statement #265
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Argument 0 of Applic statement #265

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #265)
;; Starting: BoxGet of VarBound(string?, 1, 6)
;; Starting: Evaluating val for [ BoxGet of VarBound(string?, 1, 6) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=string?, major=1, minor=6)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 6]
;; Finished: Get VarBound(name=string?, major=1, minor=6)

;; Finished: Evaluating val for [ BoxGet of VarBound(string?, 1, 6) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(string?, 1, 6)

;; Finished: Evaluating proc to apply (in Applic #265)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic265
int 3
ContinueApplic265:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #265
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#265 of: (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0))

cmp rax, SOB_FALSE_ADDRESS
je Lelse264
;; Starting: Perform Applic#266 of: (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1))
;; Starting: Argument 0 of Applic statement #266
;; Starting: Get VarParam(name=y, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=y, minor=1)

;; Finished: Argument 0 of Applic statement #266

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #266)
;; Starting: BoxGet of VarBound(string?, 1, 6)
;; Starting: Evaluating val for [ BoxGet of VarBound(string?, 1, 6) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=string?, major=1, minor=6)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 6]
;; Finished: Get VarBound(name=string?, major=1, minor=6)

;; Finished: Evaluating val for [ BoxGet of VarBound(string?, 1, 6) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(string?, 1, 6)

;; Finished: Evaluating proc to apply (in Applic #266)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic266
int 3
ContinueApplic266:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #266
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#266 of: (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1))

jmp LendIf264
Lelse264:
mov rax, const_tbl+2	; mov const #f to rax
LendIf264:
;; Finished: If statement (#264): (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f)

cmp rax, SOB_FALSE_ADDRESS
je Lelse263
;; Starting: Perform Applic#267 of: (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1)))
;; Starting: Argument 1 of Applic statement #267
;; Starting: Perform Applic#269 of: (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))
;; Starting: Argument 0 of Applic statement #269
;; Starting: Get VarParam(name=y, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=y, minor=1)

;; Finished: Argument 0 of Applic statement #269

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #269)
;; Starting: BoxGet of VarBound(string->list, 1, 1)
;; Starting: Evaluating val for [ BoxGet of VarBound(string->list, 1, 1) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=string->list, major=1, minor=1)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
;; Finished: Get VarBound(name=string->list, major=1, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarBound(string->list, 1, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(string->list, 1, 1)

;; Finished: Evaluating proc to apply (in Applic #269)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic269
int 3
ContinueApplic269:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #269
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#269 of: (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))

;; Finished: Argument 1 of Applic statement #267

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #267
;; Starting: Perform Applic#268 of: (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))
;; Starting: Argument 0 of Applic statement #268
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Argument 0 of Applic statement #268

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #268)
;; Starting: BoxGet of VarBound(string->list, 1, 1)
;; Starting: Evaluating val for [ BoxGet of VarBound(string->list, 1, 1) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=string->list, major=1, minor=1)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
;; Finished: Get VarBound(name=string->list, major=1, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarBound(string->list, 1, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(string->list, 1, 1)

;; Finished: Evaluating proc to apply (in Applic #268)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic268
int 3
ContinueApplic268:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #268
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#268 of: (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))

;; Finished: Argument 0 of Applic statement #267

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #267)
;; Starting: BoxGet of VarBound(equal?-loop, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(equal?-loop, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=equal?-loop, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=equal?-loop, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(equal?-loop, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(equal?-loop, 0, 0)

;; Finished: Evaluating proc to apply (in Applic #267)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic267
int 3
ContinueApplic267:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #267
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#267 of: (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1)))

jmp LendIf263
Lelse263:
;; Starting: Perform Applic#270 of: (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1))
;; Starting: Argument 1 of Applic statement #270
;; Starting: Get VarParam(name=y, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=y, minor=1)

;; Finished: Argument 1 of Applic statement #270

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #270
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Argument 0 of Applic statement #270

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #270)
;; Starting: BoxGet of VarBound(eq?, 1, 7)
;; Starting: Evaluating val for [ BoxGet of VarBound(eq?, 1, 7) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=eq?, major=1, minor=7)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 7]
;; Finished: Get VarBound(name=eq?, major=1, minor=7)

;; Finished: Evaluating val for [ BoxGet of VarBound(eq?, 1, 7) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(eq?, 1, 7)

;; Finished: Evaluating proc to apply (in Applic #270)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic270
int 3
ContinueApplic270:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #270
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#270 of: (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1))

LendIf263:
;; Finished: If statement (#263): (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))

LendIf252:
;; Finished: If statement (#252): (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1))))

LendIf245:
;; Finished: If statement (#245): (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))

LendIf240:
;; Finished: If statement (#240): (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1))))))

LendIf235:
;; Finished: If statement (#235): (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont234:

;; Finished: Creating CLOSURE of LambdaSimple#234 -> (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1))))))))

;; Finished: Evaluating rhs for [ BoxSet of VarParam(equal?-loop, 0) with (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))))) ], the VALUE is expected in rax

; Save the value of rhs
push rax
;; Starting: Evaluating var for [ BoxSet of VarParam(equal?-loop, 0) with (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))))) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=equal?-loop, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=equal?-loop, minor=0)

;; Finished: Evaluating var for [ BoxSet of VarParam(equal?-loop, 0) with (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))))) ], the VALUE is expected in rax

; in RAX there is a address of a box, put the value we saved on stack earlier (from rhs) inside it
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;; Finished: BoxSet of VarParam(equal?-loop, 0) with (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1))))))))

;; Finished: Item 1 in Seq statement #233


;; Starting: Item 2 in Seq statement #233
;; Starting: BoxGet of VarParam(equal?-loop, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(equal?-loop, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=equal?-loop, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=equal?-loop, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(equal?-loop, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(equal?-loop, 0)

;; Finished: Item 2 in Seq statement #233

;; Finished: Seq statement #233: (begin (set! VarParam(equal?-loop, 0) Box(VarParam(equal?-loop, 0)))  BoxSet(VarParam(equal?-loop, 0), (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))))))  BoxGet(VarParam(equal?-loop, 0)))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont232:

;; Finished: Creating CLOSURE of LambdaSimple#232 -> (lambda (equal?-loop) (begin (set! VarParam(equal?-loop, 0) Box(VarParam(equal?-loop, 0)))  BoxSet(VarParam(equal?-loop, 0), (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))))))  BoxGet(VarParam(equal?-loop, 0))))

;; Finished: Evaluating proc to apply (in Applic #231)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic231
int 3
ContinueApplic231:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #231
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#231 of: ((lambda (equal?-loop) (begin (set! VarParam(equal?-loop, 0) Box(VarParam(equal?-loop, 0)))  BoxSet(VarParam(equal?-loop, 0), (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))))))  BoxGet(VarParam(equal?-loop, 0)))) whatever)

;; Finished: Item 11 in Seq statement #230

;; Finished: Seq statement #230: (begin (set! VarParam(=, 0) Box(VarParam(=, 0)))  (set! VarParam(string->list, 1) Box(VarParam(string->list, 1)))  (set! VarParam(rational?, 2) Box(VarParam(rational?, 2)))  (set! VarParam(flonum?, 3) Box(VarParam(flonum?, 3)))  (set! VarParam(pair?, 4) Box(VarParam(pair?, 4)))  (set! VarParam(char?, 5) Box(VarParam(char?, 5)))  (set! VarParam(string?, 6) Box(VarParam(string?, 6)))  (set! VarParam(eq?, 7) Box(VarParam(eq?, 7)))  (set! VarParam(car, 8) Box(VarParam(car, 8)))  (set! VarParam(cdr, 9) Box(VarParam(cdr, 9)))  (set! VarParam(char->integer, 10) Box(VarParam(char->integer, 10)))  ((lambda (equal?-loop) (begin (set! VarParam(equal?-loop, 0) Box(VarParam(equal?-loop, 0)))  BoxSet(VarParam(equal?-loop, 0), (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))))))  BoxGet(VarParam(equal?-loop, 0)))) whatever))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont229:

;; Finished: Creating CLOSURE of LambdaSimple#229 -> (lambda (= string->list rational? flonum? pair? char? string? eq? car cdr char->integer) (begin (set! VarParam(=, 0) Box(VarParam(=, 0)))  (set! VarParam(string->list, 1) Box(VarParam(string->list, 1)))  (set! VarParam(rational?, 2) Box(VarParam(rational?, 2)))  (set! VarParam(flonum?, 3) Box(VarParam(flonum?, 3)))  (set! VarParam(pair?, 4) Box(VarParam(pair?, 4)))  (set! VarParam(char?, 5) Box(VarParam(char?, 5)))  (set! VarParam(string?, 6) Box(VarParam(string?, 6)))  (set! VarParam(eq?, 7) Box(VarParam(eq?, 7)))  (set! VarParam(car, 8) Box(VarParam(car, 8)))  (set! VarParam(cdr, 9) Box(VarParam(cdr, 9)))  (set! VarParam(char->integer, 10) Box(VarParam(char->integer, 10)))  ((lambda (equal?-loop) (begin (set! VarParam(equal?-loop, 0) Box(VarParam(equal?-loop, 0)))  BoxSet(VarParam(equal?-loop, 0), (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))))))  BoxGet(VarParam(equal?-loop, 0)))) whatever)))

;; Finished: Evaluating proc to apply (in Applic #228)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic228
int 3
ContinueApplic228:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #228
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#228 of: ((lambda (= string->list rational? flonum? pair? char? string? eq? car cdr char->integer) (begin (set! VarParam(=, 0) Box(VarParam(=, 0)))  (set! VarParam(string->list, 1) Box(VarParam(string->list, 1)))  (set! VarParam(rational?, 2) Box(VarParam(rational?, 2)))  (set! VarParam(flonum?, 3) Box(VarParam(flonum?, 3)))  (set! VarParam(pair?, 4) Box(VarParam(pair?, 4)))  (set! VarParam(char?, 5) Box(VarParam(char?, 5)))  (set! VarParam(string?, 6) Box(VarParam(string?, 6)))  (set! VarParam(eq?, 7) Box(VarParam(eq?, 7)))  (set! VarParam(car, 8) Box(VarParam(car, 8)))  (set! VarParam(cdr, 9) Box(VarParam(cdr, 9)))  (set! VarParam(char->integer, 10) Box(VarParam(char->integer, 10)))  ((lambda (equal?-loop) (begin (set! VarParam(equal?-loop, 0) Box(VarParam(equal?-loop, 0)))  BoxSet(VarParam(equal?-loop, 0), (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))))))  BoxGet(VarParam(equal?-loop, 0)))) whatever))) VarFree(=)  VarFree(string->list)  VarFree(rational?)  VarFree(flonum?)  VarFree(pair?)  VarFree(char?)  VarFree(string?)  VarFree(eq?)  VarFree(car)  VarFree(cdr)  VarFree(char->integer))

mov qword [fvar_tbl+8*35], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar equal? to ((lambda (= string->list rational? flonum? pair? char? string? eq? car cdr char->integer) (begin (set! VarParam(=, 0) Box(VarParam(=, 0)))  (set! VarParam(string->list, 1) Box(VarParam(string->list, 1)))  (set! VarParam(rational?, 2) Box(VarParam(rational?, 2)))  (set! VarParam(flonum?, 3) Box(VarParam(flonum?, 3)))  (set! VarParam(pair?, 4) Box(VarParam(pair?, 4)))  (set! VarParam(char?, 5) Box(VarParam(char?, 5)))  (set! VarParam(string?, 6) Box(VarParam(string?, 6)))  (set! VarParam(eq?, 7) Box(VarParam(eq?, 7)))  (set! VarParam(car, 8) Box(VarParam(car, 8)))  (set! VarParam(cdr, 9) Box(VarParam(cdr, 9)))  (set! VarParam(char->integer, 10) Box(VarParam(char->integer, 10)))  ((lambda (equal?-loop) (begin (set! VarParam(equal?-loop, 0) Box(VarParam(equal?-loop, 0)))  BoxSet(VarParam(equal?-loop, 0), (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))))))  BoxGet(VarParam(equal?-loop, 0)))) whatever))) VarFree(=)  VarFree(string->list)  VarFree(rational?)  VarFree(flonum?)  VarFree(pair?)  VarFree(char?)  VarFree(string?)  VarFree(eq?)  VarFree(car)  VarFree(cdr)  VarFree(char->integer))

	call write_sob_if_not_void

;; Starting: Perform Applic#271 of: (VarFree(+) 1/1  2/1)
;; Starting: Argument 1 of Applic statement #271
mov rax, const_tbl+85	; mov const 2/1 to rax
;; Finished: Argument 1 of Applic statement #271

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #271
mov rax, const_tbl+51	; mov const 1/1 to rax
;; Finished: Argument 0 of Applic statement #271

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #271)
mov rax, qword [fvar_tbl+8*15]	; mov fvar + to rax
;; Finished: Evaluating proc to apply (in Applic #271)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic271
int 3
ContinueApplic271:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #271
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#271 of: (VarFree(+) 1/1  2/1)

	call write_sob_if_not_void
;;;Finished User Code
;;; Clean up the dummy frame, set the exit status to 0 ("success"), 
   ;;; and return from main
   pop rbp
   add rsp, 3*8
   mov rax, 0

   ret
boolean?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_BOOL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

flonum?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_FLOAT
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

rational?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_RATIONAL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

pair?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_PAIR
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

null?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_NIL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

char?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_CHAR
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

string?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_STRING
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

symbol?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_SYMBOL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

procedure?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_CLOSURE
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

div:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .div_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  divsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .div_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          MAKE_RATIONAL(rax, rdx, rdi)
         mov PVAR(1), rax
         pop rbp
         jmp mul
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

mul:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .mul_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  mulsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .mul_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          imul rsi, rdi
	 imul rcx, rdx
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

add:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .add_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  addsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .add_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          imul rsi, rdx
	 imul rdi, rcx
	 add rsi, rdi
	 imul rcx, rdx
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

eq:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .eq_rat
             FLOAT_VAL rsi, rsi
	 FLOAT_VAL rdi, rdi
	 cmp rsi, rdi
             jmp .op_return
          .eq_rat:
             NUMERATOR rcx, rsi
	 NUMERATOR rdx, rdi
	 cmp rcx, rdx
	 jne .false
	 DENOMINATOR rcx, rsi
	 DENOMINATOR rdx, rdi
	 cmp rcx, rdx
         .false:
          .op_return:
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

lt:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .lt_rat
             FLOAT_VAL rsi, rsi
	 movq xmm0, rsi
	 FLOAT_VAL rdi, rdi
	 movq xmm1, rdi
	 ucomisd xmm0, xmm1
             jmp .op_return
          .lt_rat:
             DENOMINATOR rcx, rsi
	 DENOMINATOR rdx, rdi
	 NUMERATOR rsi, rsi
	 NUMERATOR rdi, rdi
	 imul rsi, rdx
	 imul rdi, rcx
	 cmp rsi, rdi
          .op_return:
      jl .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

string_length:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	STRING_LENGTH rsi, rsi
         MAKE_RATIONAL(rax, rsi, 1)
         pop rbp
         ret

string_ref:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	STRING_ELEMENTS rsi, rsi
         NUMERATOR rdi, rdi
         add rsi, rdi
         mov sil, byte [rsi]
         MAKE_CHAR(rax, sil)
         pop rbp
         ret

string_set:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov rdx, PVAR(2)
	STRING_ELEMENTS rsi, rsi
         NUMERATOR rdi, rdi
         add rsi, rdi
         CHAR_VAL rax, rdx
         mov byte [rsi], al
         mov rax, SOB_VOID_ADDRESS
         pop rbp
         ret

make_string:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	NUMERATOR rsi, rsi
         CHAR_VAL rdi, rdi
         and rdi, 255
         MAKE_STRING rax, rsi, dil
         pop rbp
         ret

symbol_to_string:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	SYMBOL_VAL rsi, rsi
	 STRING_LENGTH rcx, rsi
	 STRING_ELEMENTS rdi, rsi
	 push rcx
	 push rdi
	 mov dil, byte [rdi]
	 MAKE_CHAR(rax, dil)
	 push rax
	 MAKE_RATIONAL(rax, rcx, 1)
	 push rax
	 push 2
	 push SOB_NIL_ADDRESS
	 call make_string
	 add rsp, 4*8
	 STRING_ELEMENTS rsi, rax   
	 pop rdi
	 pop rcx
	 cmp rcx, 0
	 je .end
         .loop:
	 lea r8, [rdi+rcx]
	 lea r9, [rsi+rcx]
	 mov bl, byte [r8]
	 mov byte [r9], bl
	 loop .loop
         .end:
         pop rbp
         ret

eq?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	cmp rsi, rdi
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

char_to_integer:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	CHAR_VAL rsi, rsi
	 and rsi, 255
	 MAKE_RATIONAL(rax, rsi, 1)
         pop rbp
         ret

integer_to_char:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	NUMERATOR rsi, rsi
	 and rsi, 255
	 MAKE_CHAR(rax, sil)
         pop rbp
         ret

exact_to_inexact:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	DENOMINATOR rdi, rsi
	 NUMERATOR rsi, rsi 
	 cvtsi2sd xmm0, rsi
	 cvtsi2sd xmm1, rdi
	 divsd xmm0, xmm1
	 movq rsi, xmm0
	 MAKE_FLOAT(rax, rsi)
         pop rbp
         ret

numerator:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	NUMERATOR rsi, rsi
	 mov rdi, 1
	 MAKE_RATIONAL(rax, rsi, rdi)
         pop rbp
         ret

denominator:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	DENOMINATOR rsi, rsi
	 mov rdi, 1
	 MAKE_RATIONAL(rax, rsi, rdi)
         pop rbp
         ret

gcd:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	xor rdx, rdx
	 NUMERATOR rax, rsi
         NUMERATOR rdi, rdi
       .loop:
	 and rdi, rdi
	 jz .end_loop
	 xor rdx, rdx 
	 div rdi
	 mov rax, rdi
	 mov rdi, rdx
	 jmp .loop	
       .end_loop:
	 mov rdx, rax
         MAKE_RATIONAL(rax, rdx, 1)
         pop rbp
         ret

car:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	CAR rax, rsi
         pop rbp
         ret

cdr:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	CDR rax, rsi
         pop rbp
         ret

set_car:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	lea rsi, [rsi+TYPE_SIZE]
   mov rsi, rdi
         pop rbp
         ret

set_cdr:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	lea rsi, [rsi+TYPE_SIZE+WORD_SIZE]
   mov rsi, rdi
         pop rbp
         ret

cons:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	MAKE_PAIR(rax, rsi, rdi)
         pop rbp
         ret