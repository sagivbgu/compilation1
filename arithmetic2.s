;;; All the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include "compiler.s"

section .bss
;;; This pointer is used to manage allocations on our heap.
malloc_pointer:
    resq 1

;;; here we REServe enough Quad-words (64-bit "cells") for the free variables
;;; each free variable has 8 bytes reserved for a 64-bit pointer to its value
fvar_tbl:
    resq 40

section .data
const_tbl:
db T_VOID	; offset 0, #<void>
db T_NIL	; offset 1, ()
db T_BOOL, 0	; offset 2, #f
db T_BOOL, 1	; offset 4, #t
MAKE_LITERAL_STRING "whatever"	; offset 6, "whatever"
MAKE_LITERAL_SYMBOL(const_tbl+6)	; offset 23, whatever
MAKE_LITERAL_CHAR(0)	; offset 32, char 0
MAKE_LITERAL_RATIONAL(0, 1)	; offset 34, 0/1
MAKE_LITERAL_RATIONAL(1, 1)	; offset 51, 1/1
MAKE_LITERAL_RATIONAL(-1, 1)	; offset 68, -1/1
MAKE_LITERAL_RATIONAL(2, 1)	; offset 85, 2/1

;;; These macro definitions are required for the primitive
;;; definitions in the epilogue to work properly
%define SOB_VOID_ADDRESS const_tbl+0
%define SOB_NIL_ADDRESS const_tbl+1
%define SOB_FALSE_ADDRESS const_tbl+2
%define SOB_TRUE_ADDRESS const_tbl+4

global main
section .text
main:
    ;; set up the heap
    mov rdi, GB(2)
    call malloc
    mov [malloc_pointer], rax

    ;; Set up the dummy activation frame
    ;; The dummy return address is T_UNDEFINED
    ;; (which a is a macro for 0) so that returning
    ;; from the top level (which SHOULD NOT HAPPEN
    ;; AND IS A BUG) will cause a segfault.
    push 0                ; argument count
    push SOB_NIL_ADDRESS  ; lexical environment address
    push T_UNDEFINED      ; return address
    push rbp                    
    mov rbp, rsp                ; anchor the dummy frame

    ;; Set up the primitive stdlib fvars:
    ;; Since the primtive procedures are defined in assembly,
    ;; they are not generated by scheme (define ...) expressions.
    ;; This is where we simulate the missing (define ...) expressions
    ;; for all the primitive procedures.
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, flonum?)
mov [fvar_tbl+8*23], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, rational?)
mov [fvar_tbl+8*24], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, pair?)
mov [fvar_tbl+8*12], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, null?)
mov [fvar_tbl+8*1], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char?)
mov [fvar_tbl+8*36], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string?)
mov [fvar_tbl+8*37], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_length)
mov [fvar_tbl+8*34], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_ref)
mov [fvar_tbl+8*33], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, make_string)
mov [fvar_tbl+8*13], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char_to_integer)
mov [fvar_tbl+8*39], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, exact_to_inexact)
mov [fvar_tbl+8*25], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, eq?)
mov [fvar_tbl+8*38], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, add)
mov [fvar_tbl+8*15], rax
Debug0:
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, mul)
mov [fvar_tbl+8*16], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, div)
mov [fvar_tbl+8*17], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, eq)
mov [fvar_tbl+8*21], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, lt)
mov [fvar_tbl+8*22], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, numerator)
mov [fvar_tbl+8*18], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, denominator)
mov [fvar_tbl+8*19], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, gcd)
mov [fvar_tbl+8*20], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, car)
mov [fvar_tbl+8*2], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cdr)
mov [fvar_tbl+8*3], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cons)
mov [fvar_tbl+8*4], rax

user_code_fragment:
;;; The code you compiled will be added here.
;;; It will be executed immediately after the closures for 
;;; the primitive procedures are set up.
;; Starting: Set fvar map to ((lambda (null? car cdr cons apply) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(car, 1) Box(VarParam(car, 1)))  (set! VarParam(cdr, 2) Box(VarParam(cdr, 2)))  (set! VarParam(cons, 3) Box(VarParam(cons, 3)))  (set! VarParam(apply, 4) Box(VarParam(apply, 4)))  ((lambda (map-many map-one) (begin (set! VarParam(map-many, 0) Box(VarParam(map-many, 0)))  (set! VarParam(map-one, 1) Box(VarParam(map-one, 1)))  BoxSet(VarParam(map-many, 0), (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))))))  BoxSet(VarParam(map-one, 1), (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))))))  (lambda (f . args) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(args, 1) Box(VarParam(args, 1)))  (BoxGet(VarBound(map-many, 0, 0)) BoxGet(VarParam(f, 0))  BoxGet(VarParam(args, 1))))))) whatever  whatever))) VarFree(null?)  VarFree(car)  VarFree(cdr)  VarFree(cons)  VarFree(apply))
;; Starting: Perform Applic#1 of: ((lambda (null? car cdr cons apply) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(car, 1) Box(VarParam(car, 1)))  (set! VarParam(cdr, 2) Box(VarParam(cdr, 2)))  (set! VarParam(cons, 3) Box(VarParam(cons, 3)))  (set! VarParam(apply, 4) Box(VarParam(apply, 4)))  ((lambda (map-many map-one) (begin (set! VarParam(map-many, 0) Box(VarParam(map-many, 0)))  (set! VarParam(map-one, 1) Box(VarParam(map-one, 1)))  BoxSet(VarParam(map-many, 0), (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))))))  BoxSet(VarParam(map-one, 1), (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))))))  (lambda (f . args) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(args, 1) Box(VarParam(args, 1)))  (BoxGet(VarBound(map-many, 0, 0)) BoxGet(VarParam(f, 0))  BoxGet(VarParam(args, 1))))))) whatever  whatever))) VarFree(null?)  VarFree(car)  VarFree(cdr)  VarFree(cons)  VarFree(apply))
;; Starting: Argument 4 of Applic statement #1
mov rax, qword [fvar_tbl+8*5]	; mov fvar apply to rax
;; Finished: Argument 4 of Applic statement #1

push rax ; Push argument to stack;; Starting: Argument 3 of Applic statement #1
mov rax, qword [fvar_tbl+8*4]	; mov fvar cons to rax
;; Finished: Argument 3 of Applic statement #1

push rax ; Push argument to stack;; Starting: Argument 2 of Applic statement #1
mov rax, qword [fvar_tbl+8*3]	; mov fvar cdr to rax
;; Finished: Argument 2 of Applic statement #1

push rax ; Push argument to stack;; Starting: Argument 1 of Applic statement #1
mov rax, qword [fvar_tbl+8*2]	; mov fvar car to rax
;; Finished: Argument 1 of Applic statement #1

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #1
mov rax, qword [fvar_tbl+8*1]	; mov fvar null? to rax
;; Finished: Argument 0 of Applic statement #1

push rax ; Push argument to stack
push qword 5 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #1)
;; Starting: Creating CLOSURE of LambdaSimple#2 -> (lambda (null? car cdr cons apply) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(car, 1) Box(VarParam(car, 1)))  (set! VarParam(cdr, 2) Box(VarParam(cdr, 2)))  (set! VarParam(cons, 3) Box(VarParam(cons, 3)))  (set! VarParam(apply, 4) Box(VarParam(apply, 4)))  ((lambda (map-many map-one) (begin (set! VarParam(map-many, 0) Box(VarParam(map-many, 0)))  (set! VarParam(map-one, 1) Box(VarParam(map-one, 1)))  BoxSet(VarParam(map-many, 0), (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))))))  BoxSet(VarParam(map-one, 1), (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))))))  (lambda (f . args) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(args, 1) Box(VarParam(args, 1)))  (BoxGet(VarBound(map-many, 0, 0)) BoxGet(VarParam(f, 0))  BoxGet(VarParam(args, 1))))))) whatever  whatever)))
push rbx
; Env Extend Code Section For Closure#2
mov rbx, 0 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend2
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End2

LClosureEnvExtend2:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, -1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 0
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop2:
  jz LClosureEnvExtend_LoopEnd2
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop2

LClosureEnvExtend_LoopEnd2:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd2
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop2:
  jz LClosureEnvExtend_ParamsLoopEnd2

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop2

LClosureEnvExtend_ParamsLoopEnd2:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End2:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode2)
pop rbx
jmp LClosureCont2
LClosureCode2:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #3: (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(car, 1) Box(VarParam(car, 1)))  (set! VarParam(cdr, 2) Box(VarParam(cdr, 2)))  (set! VarParam(cons, 3) Box(VarParam(cons, 3)))  (set! VarParam(apply, 4) Box(VarParam(apply, 4)))  ((lambda (map-many map-one) (begin (set! VarParam(map-many, 0) Box(VarParam(map-many, 0)))  (set! VarParam(map-one, 1) Box(VarParam(map-one, 1)))  BoxSet(VarParam(map-many, 0), (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))))))  BoxSet(VarParam(map-one, 1), (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))))))  (lambda (f . args) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(args, 1) Box(VarParam(args, 1)))  (BoxGet(VarBound(map-many, 0, 0)) BoxGet(VarParam(f, 0))  BoxGet(VarParam(args, 1))))))) whatever  whatever))
;; Starting: Item 0 in Seq statement #3
;; Starting: Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(null?, 0)
;; Starting: Get VarParam(name=null?, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=null?, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(null?, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0))

;; Finished: Item 0 in Seq statement #3


;; Starting: Item 1 in Seq statement #3
;; Starting: Set VarParam(name=car, minor=1) with Box(VarParam(car, 1))
;; Starting: Evaluating rhs for [ Set VarParam(name=car, minor=1) with Box(VarParam(car, 1)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(car, 1)
;; Starting: Get VarParam(name=car, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=car, minor=1)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(car, 1)

;; Finished: Evaluating rhs for [ Set VarParam(name=car, minor=1) with Box(VarParam(car, 1)) ], value is expected in rax

mov PVAR(1), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=car, minor=1) with Box(VarParam(car, 1))

;; Finished: Item 1 in Seq statement #3


;; Starting: Item 2 in Seq statement #3
;; Starting: Set VarParam(name=cdr, minor=2) with Box(VarParam(cdr, 2))
;; Starting: Evaluating rhs for [ Set VarParam(name=cdr, minor=2) with Box(VarParam(cdr, 2)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(cdr, 2)
;; Starting: Get VarParam(name=cdr, minor=2)
mov rax, PVAR(2)
;; Finished: Get VarParam(name=cdr, minor=2)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(cdr, 2)

;; Finished: Evaluating rhs for [ Set VarParam(name=cdr, minor=2) with Box(VarParam(cdr, 2)) ], value is expected in rax

mov PVAR(2), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=cdr, minor=2) with Box(VarParam(cdr, 2))

;; Finished: Item 2 in Seq statement #3


;; Starting: Item 3 in Seq statement #3
;; Starting: Set VarParam(name=cons, minor=3) with Box(VarParam(cons, 3))
;; Starting: Evaluating rhs for [ Set VarParam(name=cons, minor=3) with Box(VarParam(cons, 3)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(cons, 3)
;; Starting: Get VarParam(name=cons, minor=3)
mov rax, PVAR(3)
;; Finished: Get VarParam(name=cons, minor=3)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(cons, 3)

;; Finished: Evaluating rhs for [ Set VarParam(name=cons, minor=3) with Box(VarParam(cons, 3)) ], value is expected in rax

mov PVAR(3), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=cons, minor=3) with Box(VarParam(cons, 3))

;; Finished: Item 3 in Seq statement #3


;; Starting: Item 4 in Seq statement #3
;; Starting: Set VarParam(name=apply, minor=4) with Box(VarParam(apply, 4))
;; Starting: Evaluating rhs for [ Set VarParam(name=apply, minor=4) with Box(VarParam(apply, 4)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(apply, 4)
;; Starting: Get VarParam(name=apply, minor=4)
mov rax, PVAR(4)
;; Finished: Get VarParam(name=apply, minor=4)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(apply, 4)

;; Finished: Evaluating rhs for [ Set VarParam(name=apply, minor=4) with Box(VarParam(apply, 4)) ], value is expected in rax

mov PVAR(4), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=apply, minor=4) with Box(VarParam(apply, 4))

;; Finished: Item 4 in Seq statement #3


;; Starting: Item 5 in Seq statement #3
;; Starting: Perform Applic#4 of: ((lambda (map-many map-one) (begin (set! VarParam(map-many, 0) Box(VarParam(map-many, 0)))  (set! VarParam(map-one, 1) Box(VarParam(map-one, 1)))  BoxSet(VarParam(map-many, 0), (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))))))  BoxSet(VarParam(map-one, 1), (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))))))  (lambda (f . args) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(args, 1) Box(VarParam(args, 1)))  (BoxGet(VarBound(map-many, 0, 0)) BoxGet(VarParam(f, 0))  BoxGet(VarParam(args, 1))))))) whatever  whatever)
;; Starting: Argument 1 of Applic statement #4
mov rax, const_tbl+23	; mov const whatever to rax
;; Finished: Argument 1 of Applic statement #4

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #4
mov rax, const_tbl+23	; mov const whatever to rax
;; Finished: Argument 0 of Applic statement #4

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #4)
;; Starting: Creating CLOSURE of LambdaSimple#5 -> (lambda (map-many map-one) (begin (set! VarParam(map-many, 0) Box(VarParam(map-many, 0)))  (set! VarParam(map-one, 1) Box(VarParam(map-one, 1)))  BoxSet(VarParam(map-many, 0), (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))))))  BoxSet(VarParam(map-one, 1), (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))))))  (lambda (f . args) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(args, 1) Box(VarParam(args, 1)))  (BoxGet(VarBound(map-many, 0, 0)) BoxGet(VarParam(f, 0))  BoxGet(VarParam(args, 1)))))))
push rbx
; Env Extend Code Section For Closure#5
mov rbx, 1 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend5
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End5

LClosureEnvExtend5:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 0
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 8
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop5:
  jz LClosureEnvExtend_LoopEnd5
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop5

LClosureEnvExtend_LoopEnd5:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd5
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop5:
  jz LClosureEnvExtend_ParamsLoopEnd5

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop5

LClosureEnvExtend_ParamsLoopEnd5:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End5:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode5)
pop rbx
jmp LClosureCont5
LClosureCode5:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #6: (begin (set! VarParam(map-many, 0) Box(VarParam(map-many, 0)))  (set! VarParam(map-one, 1) Box(VarParam(map-one, 1)))  BoxSet(VarParam(map-many, 0), (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))))))  BoxSet(VarParam(map-one, 1), (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))))))  (lambda (f . args) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(args, 1) Box(VarParam(args, 1)))  (BoxGet(VarBound(map-many, 0, 0)) BoxGet(VarParam(f, 0))  BoxGet(VarParam(args, 1))))))
;; Starting: Item 0 in Seq statement #6
;; Starting: Set VarParam(name=map-many, minor=0) with Box(VarParam(map-many, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=map-many, minor=0) with Box(VarParam(map-many, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(map-many, 0)
;; Starting: Get VarParam(name=map-many, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=map-many, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(map-many, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=map-many, minor=0) with Box(VarParam(map-many, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=map-many, minor=0) with Box(VarParam(map-many, 0))

;; Finished: Item 0 in Seq statement #6


;; Starting: Item 1 in Seq statement #6
;; Starting: Set VarParam(name=map-one, minor=1) with Box(VarParam(map-one, 1))
;; Starting: Evaluating rhs for [ Set VarParam(name=map-one, minor=1) with Box(VarParam(map-one, 1)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(map-one, 1)
;; Starting: Get VarParam(name=map-one, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=map-one, minor=1)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(map-one, 1)

;; Finished: Evaluating rhs for [ Set VarParam(name=map-one, minor=1) with Box(VarParam(map-one, 1)) ], value is expected in rax

mov PVAR(1), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=map-one, minor=1) with Box(VarParam(map-one, 1))

;; Finished: Item 1 in Seq statement #6


;; Starting: Item 2 in Seq statement #6
;; Starting: BoxSet of VarParam(map-many, 0) with (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1))))))
;; Starting: Evaluating rhs for [ BoxSet of VarParam(map-many, 0) with (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))))) ], the VALUE is expected in rax
;; Starting: Creating CLOSURE of LambdaSimple#7 -> (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1))))))
push rbx
; Env Extend Code Section For Closure#7
mov rbx, 2 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend7
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End7

LClosureEnvExtend7:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 16
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop7:
  jz LClosureEnvExtend_LoopEnd7
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop7

LClosureEnvExtend_LoopEnd7:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd7
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop7:
  jz LClosureEnvExtend_ParamsLoopEnd7

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop7

LClosureEnvExtend_ParamsLoopEnd7:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End7:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode7)
pop rbx
jmp LClosureCont7
LClosureCode7:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: If statement (#8): (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))))
Lif8:
;; Starting: Perform Applic#9 of: (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1)))
;; Starting: Argument 0 of Applic statement #9
;; Starting: Perform Applic#10 of: (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))
;; Starting: Argument 0 of Applic statement #10
;; Starting: Get VarParam(name=lists, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=lists, minor=1)

;; Finished: Argument 0 of Applic statement #10

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #10)
;; Starting: BoxGet of VarBound(car, 1, 1)
;; Starting: Evaluating val for [ BoxGet of VarBound(car, 1, 1) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=car, major=1, minor=1)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
;; Finished: Get VarBound(name=car, major=1, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarBound(car, 1, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(car, 1, 1)

;; Finished: Evaluating proc to apply (in Applic #10)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic10
; int3
ContinueApplic10:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #10
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#10 of: (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))

;; Finished: Argument 0 of Applic statement #9

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #9)
;; Starting: BoxGet of VarBound(null?, 1, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(null?, 1, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=null?, major=1, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=null?, major=1, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(null?, 1, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(null?, 1, 0)

;; Finished: Evaluating proc to apply (in Applic #9)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic9
; int3
ContinueApplic9:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #9
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#9 of: (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1)))

cmp rax, SOB_FALSE_ADDRESS
je Lelse8
mov rax, const_tbl+1	; mov const () to rax
jmp LendIf8
Lelse8:
;; Starting: Perform Applic#11 of: (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1))))
;; Starting: Argument 1 of Applic statement #11
;; Starting: Perform Applic#14 of: (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))
;; Starting: Argument 1 of Applic statement #14
;; Starting: Perform Applic#15 of: (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1))
;; Starting: Argument 1 of Applic statement #15
;; Starting: Get VarParam(name=lists, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=lists, minor=1)

;; Finished: Argument 1 of Applic statement #15

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #15
;; Starting: BoxGet of VarBound(cdr, 1, 2)
;; Starting: Evaluating val for [ BoxGet of VarBound(cdr, 1, 2) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=cdr, major=1, minor=2)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]
;; Finished: Get VarBound(name=cdr, major=1, minor=2)

;; Finished: Evaluating val for [ BoxGet of VarBound(cdr, 1, 2) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(cdr, 1, 2)

;; Finished: Argument 0 of Applic statement #15

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #15)
;; Starting: BoxGet of VarBound(map-one, 0, 1)
;; Starting: Evaluating val for [ BoxGet of VarBound(map-one, 0, 1) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=map-one, major=0, minor=1)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]
;; Finished: Get VarBound(name=map-one, major=0, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarBound(map-one, 0, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(map-one, 0, 1)

;; Finished: Evaluating proc to apply (in Applic #15)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic15
; int3
ContinueApplic15:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #15
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#15 of: (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1))

;; Finished: Argument 1 of Applic statement #14

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #14
;; Starting: Get VarParam(name=f, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=f, minor=0)

;; Finished: Argument 0 of Applic statement #14

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #14)
;; Starting: BoxGet of VarBound(map-many, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(map-many, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=map-many, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=map-many, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(map-many, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(map-many, 0, 0)

;; Finished: Evaluating proc to apply (in Applic #14)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic14
; int3
ContinueApplic14:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #14
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#14 of: (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))

;; Finished: Argument 1 of Applic statement #11

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #11
;; Starting: Perform Applic#12 of: (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))
;; Starting: Argument 1 of Applic statement #12
;; Starting: Perform Applic#13 of: (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1))
;; Starting: Argument 1 of Applic statement #13
;; Starting: Get VarParam(name=lists, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=lists, minor=1)

;; Finished: Argument 1 of Applic statement #13

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #13
;; Starting: BoxGet of VarBound(car, 1, 1)
;; Starting: Evaluating val for [ BoxGet of VarBound(car, 1, 1) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=car, major=1, minor=1)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
;; Finished: Get VarBound(name=car, major=1, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarBound(car, 1, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(car, 1, 1)

;; Finished: Argument 0 of Applic statement #13

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #13)
;; Starting: BoxGet of VarBound(map-one, 0, 1)
;; Starting: Evaluating val for [ BoxGet of VarBound(map-one, 0, 1) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=map-one, major=0, minor=1)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]
;; Finished: Get VarBound(name=map-one, major=0, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarBound(map-one, 0, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(map-one, 0, 1)

;; Finished: Evaluating proc to apply (in Applic #13)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic13
; int3
ContinueApplic13:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #13
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#13 of: (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1))

;; Finished: Argument 1 of Applic statement #12

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #12
;; Starting: Get VarParam(name=f, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=f, minor=0)

;; Finished: Argument 0 of Applic statement #12

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #12)
;; Starting: BoxGet of VarBound(apply, 1, 4)
;; Starting: Evaluating val for [ BoxGet of VarBound(apply, 1, 4) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=apply, major=1, minor=4)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 4]
;; Finished: Get VarBound(name=apply, major=1, minor=4)

;; Finished: Evaluating val for [ BoxGet of VarBound(apply, 1, 4) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(apply, 1, 4)

;; Finished: Evaluating proc to apply (in Applic #12)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic12
; int3
ContinueApplic12:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #12
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#12 of: (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))

;; Finished: Argument 0 of Applic statement #11

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #11)
;; Starting: BoxGet of VarBound(cons, 1, 3)
;; Starting: Evaluating val for [ BoxGet of VarBound(cons, 1, 3) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=cons, major=1, minor=3)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]
;; Finished: Get VarBound(name=cons, major=1, minor=3)

;; Finished: Evaluating val for [ BoxGet of VarBound(cons, 1, 3) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(cons, 1, 3)

;; Finished: Evaluating proc to apply (in Applic #11)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic11
; int3
ContinueApplic11:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #11
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#11 of: (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1))))

LendIf8:
;; Finished: If statement (#8): (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont7:

;; Finished: Creating CLOSURE of LambdaSimple#7 -> (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1))))))

;; Finished: Evaluating rhs for [ BoxSet of VarParam(map-many, 0) with (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))))) ], the VALUE is expected in rax

; Save the value of rhs
push rax
;; Starting: Evaluating var for [ BoxSet of VarParam(map-many, 0) with (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))))) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=map-many, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=map-many, minor=0)

;; Finished: Evaluating var for [ BoxSet of VarParam(map-many, 0) with (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))))) ], the VALUE is expected in rax

; in RAX there is a address of a box, put the value we saved on stack earlier (from rhs) inside it
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;; Finished: BoxSet of VarParam(map-many, 0) with (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1))))))

;; Finished: Item 2 in Seq statement #6


;; Starting: Item 3 in Seq statement #6
;; Starting: BoxSet of VarParam(map-one, 1) with (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1))))))
;; Starting: Evaluating rhs for [ BoxSet of VarParam(map-one, 1) with (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))))) ], the VALUE is expected in rax
;; Starting: Creating CLOSURE of LambdaSimple#16 -> (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1))))))
push rbx
; Env Extend Code Section For Closure#16
mov rbx, 3 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend16
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End16

LClosureEnvExtend16:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 2
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 24
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop16:
  jz LClosureEnvExtend_LoopEnd16
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop16

LClosureEnvExtend_LoopEnd16:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd16
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop16:
  jz LClosureEnvExtend_ParamsLoopEnd16

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop16

LClosureEnvExtend_ParamsLoopEnd16:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End16:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode16)
pop rbx
jmp LClosureCont16
LClosureCode16:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: If statement (#17): (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))))
Lif17:
;; Starting: Perform Applic#18 of: (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1))
;; Starting: Argument 0 of Applic statement #18
;; Starting: Get VarParam(name=s, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=s, minor=1)

;; Finished: Argument 0 of Applic statement #18

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #18)
;; Starting: BoxGet of VarBound(null?, 1, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(null?, 1, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=null?, major=1, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=null?, major=1, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(null?, 1, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(null?, 1, 0)

;; Finished: Evaluating proc to apply (in Applic #18)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic18
; int3
ContinueApplic18:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #18
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#18 of: (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1))

cmp rax, SOB_FALSE_ADDRESS
je Lelse17
mov rax, const_tbl+1	; mov const () to rax
jmp LendIf17
Lelse17:
;; Starting: Perform Applic#19 of: (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1))))
;; Starting: Argument 1 of Applic statement #19
;; Starting: Perform Applic#22 of: (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))
;; Starting: Argument 1 of Applic statement #22
;; Starting: Perform Applic#23 of: (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1))
;; Starting: Argument 0 of Applic statement #23
;; Starting: Get VarParam(name=s, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=s, minor=1)

;; Finished: Argument 0 of Applic statement #23

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #23)
;; Starting: BoxGet of VarBound(cdr, 1, 2)
;; Starting: Evaluating val for [ BoxGet of VarBound(cdr, 1, 2) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=cdr, major=1, minor=2)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]
;; Finished: Get VarBound(name=cdr, major=1, minor=2)

;; Finished: Evaluating val for [ BoxGet of VarBound(cdr, 1, 2) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(cdr, 1, 2)

;; Finished: Evaluating proc to apply (in Applic #23)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic23
; int3
ContinueApplic23:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #23
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#23 of: (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1))

;; Finished: Argument 1 of Applic statement #22

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #22
;; Starting: Get VarParam(name=f, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=f, minor=0)

;; Finished: Argument 0 of Applic statement #22

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #22)
;; Starting: BoxGet of VarBound(map-one, 0, 1)
;; Starting: Evaluating val for [ BoxGet of VarBound(map-one, 0, 1) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=map-one, major=0, minor=1)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]
;; Finished: Get VarBound(name=map-one, major=0, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarBound(map-one, 0, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(map-one, 0, 1)

;; Finished: Evaluating proc to apply (in Applic #22)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic22
; int3
ContinueApplic22:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #22
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#22 of: (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))

;; Finished: Argument 1 of Applic statement #19

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #19
;; Starting: Perform Applic#20 of: (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))
;; Starting: Argument 0 of Applic statement #20
;; Starting: Perform Applic#21 of: (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1))
;; Starting: Argument 0 of Applic statement #21
;; Starting: Get VarParam(name=s, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=s, minor=1)

;; Finished: Argument 0 of Applic statement #21

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #21)
;; Starting: BoxGet of VarBound(car, 1, 1)
;; Starting: Evaluating val for [ BoxGet of VarBound(car, 1, 1) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=car, major=1, minor=1)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
;; Finished: Get VarBound(name=car, major=1, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarBound(car, 1, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(car, 1, 1)

;; Finished: Evaluating proc to apply (in Applic #21)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic21
; int3
ContinueApplic21:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #21
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#21 of: (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1))

;; Finished: Argument 0 of Applic statement #20

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #20)
;; Starting: Get VarParam(name=f, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=f, minor=0)

;; Finished: Evaluating proc to apply (in Applic #20)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic20
; int3
ContinueApplic20:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #20
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#20 of: (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))

;; Finished: Argument 0 of Applic statement #19

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #19)
;; Starting: BoxGet of VarBound(cons, 1, 3)
;; Starting: Evaluating val for [ BoxGet of VarBound(cons, 1, 3) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=cons, major=1, minor=3)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]
;; Finished: Get VarBound(name=cons, major=1, minor=3)

;; Finished: Evaluating val for [ BoxGet of VarBound(cons, 1, 3) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(cons, 1, 3)

;; Finished: Evaluating proc to apply (in Applic #19)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic19
; int3
ContinueApplic19:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #19
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#19 of: (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1))))

LendIf17:
;; Finished: If statement (#17): (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont16:

;; Finished: Creating CLOSURE of LambdaSimple#16 -> (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1))))))

;; Finished: Evaluating rhs for [ BoxSet of VarParam(map-one, 1) with (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))))) ], the VALUE is expected in rax

; Save the value of rhs
push rax
;; Starting: Evaluating var for [ BoxSet of VarParam(map-one, 1) with (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))))) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=map-one, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=map-one, minor=1)

;; Finished: Evaluating var for [ BoxSet of VarParam(map-one, 1) with (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))))) ], the VALUE is expected in rax

; in RAX there is a address of a box, put the value we saved on stack earlier (from rhs) inside it
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;; Finished: BoxSet of VarParam(map-one, 1) with (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1))))))

;; Finished: Item 3 in Seq statement #6


;; Starting: Item 4 in Seq statement #6

;; Finished: Item 4 in Seq statement #6

;; Finished: Seq statement #6: (begin (set! VarParam(map-many, 0) Box(VarParam(map-many, 0)))  (set! VarParam(map-one, 1) Box(VarParam(map-one, 1)))  BoxSet(VarParam(map-many, 0), (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))))))  BoxSet(VarParam(map-one, 1), (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))))))  (lambda (f . args) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(args, 1) Box(VarParam(args, 1)))  (BoxGet(VarBound(map-many, 0, 0)) BoxGet(VarParam(f, 0))  BoxGet(VarParam(args, 1))))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont5:

;; Finished: Creating CLOSURE of LambdaSimple#5 -> (lambda (map-many map-one) (begin (set! VarParam(map-many, 0) Box(VarParam(map-many, 0)))  (set! VarParam(map-one, 1) Box(VarParam(map-one, 1)))  BoxSet(VarParam(map-many, 0), (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))))))  BoxSet(VarParam(map-one, 1), (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))))))  (lambda (f . args) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(args, 1) Box(VarParam(args, 1)))  (BoxGet(VarBound(map-many, 0, 0)) BoxGet(VarParam(f, 0))  BoxGet(VarParam(args, 1)))))))

;; Finished: Evaluating proc to apply (in Applic #4)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic4
; int3
ContinueApplic4:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #4
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#4 of: ((lambda (map-many map-one) (begin (set! VarParam(map-many, 0) Box(VarParam(map-many, 0)))  (set! VarParam(map-one, 1) Box(VarParam(map-one, 1)))  BoxSet(VarParam(map-many, 0), (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))))))  BoxSet(VarParam(map-one, 1), (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))))))  (lambda (f . args) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(args, 1) Box(VarParam(args, 1)))  (BoxGet(VarBound(map-many, 0, 0)) BoxGet(VarParam(f, 0))  BoxGet(VarParam(args, 1))))))) whatever  whatever)

;; Finished: Item 5 in Seq statement #3

;; Finished: Seq statement #3: (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(car, 1) Box(VarParam(car, 1)))  (set! VarParam(cdr, 2) Box(VarParam(cdr, 2)))  (set! VarParam(cons, 3) Box(VarParam(cons, 3)))  (set! VarParam(apply, 4) Box(VarParam(apply, 4)))  ((lambda (map-many map-one) (begin (set! VarParam(map-many, 0) Box(VarParam(map-many, 0)))  (set! VarParam(map-one, 1) Box(VarParam(map-one, 1)))  BoxSet(VarParam(map-many, 0), (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))))))  BoxSet(VarParam(map-one, 1), (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))))))  (lambda (f . args) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(args, 1) Box(VarParam(args, 1)))  (BoxGet(VarBound(map-many, 0, 0)) BoxGet(VarParam(f, 0))  BoxGet(VarParam(args, 1))))))) whatever  whatever))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont2:

;; Finished: Creating CLOSURE of LambdaSimple#2 -> (lambda (null? car cdr cons apply) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(car, 1) Box(VarParam(car, 1)))  (set! VarParam(cdr, 2) Box(VarParam(cdr, 2)))  (set! VarParam(cons, 3) Box(VarParam(cons, 3)))  (set! VarParam(apply, 4) Box(VarParam(apply, 4)))  ((lambda (map-many map-one) (begin (set! VarParam(map-many, 0) Box(VarParam(map-many, 0)))  (set! VarParam(map-one, 1) Box(VarParam(map-one, 1)))  BoxSet(VarParam(map-many, 0), (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))))))  BoxSet(VarParam(map-one, 1), (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))))))  (lambda (f . args) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(args, 1) Box(VarParam(args, 1)))  (BoxGet(VarBound(map-many, 0, 0)) BoxGet(VarParam(f, 0))  BoxGet(VarParam(args, 1))))))) whatever  whatever)))

;; Finished: Evaluating proc to apply (in Applic #1)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic1
; int3
ContinueApplic1:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #1
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#1 of: ((lambda (null? car cdr cons apply) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(car, 1) Box(VarParam(car, 1)))  (set! VarParam(cdr, 2) Box(VarParam(cdr, 2)))  (set! VarParam(cons, 3) Box(VarParam(cons, 3)))  (set! VarParam(apply, 4) Box(VarParam(apply, 4)))  ((lambda (map-many map-one) (begin (set! VarParam(map-many, 0) Box(VarParam(map-many, 0)))  (set! VarParam(map-one, 1) Box(VarParam(map-one, 1)))  BoxSet(VarParam(map-many, 0), (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))))))  BoxSet(VarParam(map-one, 1), (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))))))  (lambda (f . args) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(args, 1) Box(VarParam(args, 1)))  (BoxGet(VarBound(map-many, 0, 0)) BoxGet(VarParam(f, 0))  BoxGet(VarParam(args, 1))))))) whatever  whatever))) VarFree(null?)  VarFree(car)  VarFree(cdr)  VarFree(cons)  VarFree(apply))

mov qword [fvar_tbl+8*0], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar map to ((lambda (null? car cdr cons apply) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(car, 1) Box(VarParam(car, 1)))  (set! VarParam(cdr, 2) Box(VarParam(cdr, 2)))  (set! VarParam(cons, 3) Box(VarParam(cons, 3)))  (set! VarParam(apply, 4) Box(VarParam(apply, 4)))  ((lambda (map-many map-one) (begin (set! VarParam(map-many, 0) Box(VarParam(map-many, 0)))  (set! VarParam(map-one, 1) Box(VarParam(map-one, 1)))  BoxSet(VarParam(map-many, 0), (lambda (f lists) (if (BoxGet(VarBound(null?, 1, 0)) (BoxGet(VarBound(car, 1, 1)) VarParam(lists, 1))) () (BoxGet(VarBound(cons, 1, 3)) (BoxGet(VarBound(apply, 1, 4)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(car, 1, 1))  VarParam(lists, 1)))  (BoxGet(VarBound(map-many, 0, 0)) VarParam(f, 0)  (BoxGet(VarBound(map-one, 0, 1)) BoxGet(VarBound(cdr, 1, 2))  VarParam(lists, 1)))))))  BoxSet(VarParam(map-one, 1), (lambda (f s) (if (BoxGet(VarBound(null?, 1, 0)) VarParam(s, 1)) () (BoxGet(VarBound(cons, 1, 3)) (VarParam(f, 0) (BoxGet(VarBound(car, 1, 1)) VarParam(s, 1)))  (BoxGet(VarBound(map-one, 0, 1)) VarParam(f, 0)  (BoxGet(VarBound(cdr, 1, 2)) VarParam(s, 1)))))))  (lambda (f . args) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(args, 1) Box(VarParam(args, 1)))  (BoxGet(VarBound(map-many, 0, 0)) BoxGet(VarParam(f, 0))  BoxGet(VarParam(args, 1))))))) whatever  whatever))) VarFree(null?)  VarFree(car)  VarFree(cdr)  VarFree(cons)  VarFree(apply))

	call write_sob_if_not_void

;; Starting: Set fvar fold-left to ((lambda (null? apply cons map car cdr) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(apply, 1) Box(VarParam(apply, 1)))  (set! VarParam(cons, 2) Box(VarParam(cons, 2)))  (set! VarParam(map, 3) Box(VarParam(map, 3)))  (set! VarParam(car, 4) Box(VarParam(car, 4)))  (set! VarParam(cdr, 5) Box(VarParam(cdr, 5)))  (lambda (f obj . lists) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(obj, 1) Box(VarParam(obj, 1)))  (set! VarParam(lists, 2) Box(VarParam(lists, 2)))  ((lambda (fold) (begin (set! VarParam(fold, 0) Box(VarParam(fold, 0)))  BoxSet(VarParam(fold, 0), (lambda (obj lists) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(car, 2, 4)) VarParam(lists, 1))) VarParam(obj, 0) (BoxGet(VarBound(fold, 0, 0)) (BoxGet(VarBound(apply, 2, 1)) BoxGet(VarBound(f, 1, 0))  (BoxGet(VarBound(cons, 2, 2)) VarParam(obj, 0)  (BoxGet(VarBound(map, 2, 3)) BoxGet(VarBound(car, 2, 4))  VarParam(lists, 1))))  (BoxGet(VarBound(map, 2, 3)) BoxGet(VarBound(cdr, 2, 5))  VarParam(lists, 1))))))  (BoxGet(VarParam(fold, 0)) BoxGet(VarBound(obj, 0, 1))  BoxGet(VarBound(lists, 0, 2))))) whatever))))) VarFree(null?)  VarFree(apply)  VarFree(cons)  VarFree(map)  VarFree(car)  VarFree(cdr))
;; Starting: Perform Applic#24 of: ((lambda (null? apply cons map car cdr) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(apply, 1) Box(VarParam(apply, 1)))  (set! VarParam(cons, 2) Box(VarParam(cons, 2)))  (set! VarParam(map, 3) Box(VarParam(map, 3)))  (set! VarParam(car, 4) Box(VarParam(car, 4)))  (set! VarParam(cdr, 5) Box(VarParam(cdr, 5)))  (lambda (f obj . lists) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(obj, 1) Box(VarParam(obj, 1)))  (set! VarParam(lists, 2) Box(VarParam(lists, 2)))  ((lambda (fold) (begin (set! VarParam(fold, 0) Box(VarParam(fold, 0)))  BoxSet(VarParam(fold, 0), (lambda (obj lists) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(car, 2, 4)) VarParam(lists, 1))) VarParam(obj, 0) (BoxGet(VarBound(fold, 0, 0)) (BoxGet(VarBound(apply, 2, 1)) BoxGet(VarBound(f, 1, 0))  (BoxGet(VarBound(cons, 2, 2)) VarParam(obj, 0)  (BoxGet(VarBound(map, 2, 3)) BoxGet(VarBound(car, 2, 4))  VarParam(lists, 1))))  (BoxGet(VarBound(map, 2, 3)) BoxGet(VarBound(cdr, 2, 5))  VarParam(lists, 1))))))  (BoxGet(VarParam(fold, 0)) BoxGet(VarBound(obj, 0, 1))  BoxGet(VarBound(lists, 0, 2))))) whatever))))) VarFree(null?)  VarFree(apply)  VarFree(cons)  VarFree(map)  VarFree(car)  VarFree(cdr))
;; Starting: Argument 5 of Applic statement #24
mov rax, qword [fvar_tbl+8*3]	; mov fvar cdr to rax
;; Finished: Argument 5 of Applic statement #24

push rax ; Push argument to stack;; Starting: Argument 4 of Applic statement #24
mov rax, qword [fvar_tbl+8*2]	; mov fvar car to rax
;; Finished: Argument 4 of Applic statement #24

push rax ; Push argument to stack;; Starting: Argument 3 of Applic statement #24
mov rax, qword [fvar_tbl+8*0]	; mov fvar map to rax
;; Finished: Argument 3 of Applic statement #24

push rax ; Push argument to stack;; Starting: Argument 2 of Applic statement #24
mov rax, qword [fvar_tbl+8*4]	; mov fvar cons to rax
;; Finished: Argument 2 of Applic statement #24

push rax ; Push argument to stack;; Starting: Argument 1 of Applic statement #24
mov rax, qword [fvar_tbl+8*5]	; mov fvar apply to rax
;; Finished: Argument 1 of Applic statement #24

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #24
mov rax, qword [fvar_tbl+8*1]	; mov fvar null? to rax
;; Finished: Argument 0 of Applic statement #24

push rax ; Push argument to stack
push qword 6 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #24)
;; Starting: Creating CLOSURE of LambdaSimple#25 -> (lambda (null? apply cons map car cdr) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(apply, 1) Box(VarParam(apply, 1)))  (set! VarParam(cons, 2) Box(VarParam(cons, 2)))  (set! VarParam(map, 3) Box(VarParam(map, 3)))  (set! VarParam(car, 4) Box(VarParam(car, 4)))  (set! VarParam(cdr, 5) Box(VarParam(cdr, 5)))  (lambda (f obj . lists) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(obj, 1) Box(VarParam(obj, 1)))  (set! VarParam(lists, 2) Box(VarParam(lists, 2)))  ((lambda (fold) (begin (set! VarParam(fold, 0) Box(VarParam(fold, 0)))  BoxSet(VarParam(fold, 0), (lambda (obj lists) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(car, 2, 4)) VarParam(lists, 1))) VarParam(obj, 0) (BoxGet(VarBound(fold, 0, 0)) (BoxGet(VarBound(apply, 2, 1)) BoxGet(VarBound(f, 1, 0))  (BoxGet(VarBound(cons, 2, 2)) VarParam(obj, 0)  (BoxGet(VarBound(map, 2, 3)) BoxGet(VarBound(car, 2, 4))  VarParam(lists, 1))))  (BoxGet(VarBound(map, 2, 3)) BoxGet(VarBound(cdr, 2, 5))  VarParam(lists, 1))))))  (BoxGet(VarParam(fold, 0)) BoxGet(VarBound(obj, 0, 1))  BoxGet(VarBound(lists, 0, 2))))) whatever)))))
push rbx
; Env Extend Code Section For Closure#25
mov rbx, 0 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend25
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End25

LClosureEnvExtend25:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, -1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 0
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop25:
  jz LClosureEnvExtend_LoopEnd25
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop25

LClosureEnvExtend_LoopEnd25:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd25
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop25:
  jz LClosureEnvExtend_ParamsLoopEnd25

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop25

LClosureEnvExtend_ParamsLoopEnd25:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End25:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode25)
pop rbx
jmp LClosureCont25
LClosureCode25:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #26: (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(apply, 1) Box(VarParam(apply, 1)))  (set! VarParam(cons, 2) Box(VarParam(cons, 2)))  (set! VarParam(map, 3) Box(VarParam(map, 3)))  (set! VarParam(car, 4) Box(VarParam(car, 4)))  (set! VarParam(cdr, 5) Box(VarParam(cdr, 5)))  (lambda (f obj . lists) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(obj, 1) Box(VarParam(obj, 1)))  (set! VarParam(lists, 2) Box(VarParam(lists, 2)))  ((lambda (fold) (begin (set! VarParam(fold, 0) Box(VarParam(fold, 0)))  BoxSet(VarParam(fold, 0), (lambda (obj lists) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(car, 2, 4)) VarParam(lists, 1))) VarParam(obj, 0) (BoxGet(VarBound(fold, 0, 0)) (BoxGet(VarBound(apply, 2, 1)) BoxGet(VarBound(f, 1, 0))  (BoxGet(VarBound(cons, 2, 2)) VarParam(obj, 0)  (BoxGet(VarBound(map, 2, 3)) BoxGet(VarBound(car, 2, 4))  VarParam(lists, 1))))  (BoxGet(VarBound(map, 2, 3)) BoxGet(VarBound(cdr, 2, 5))  VarParam(lists, 1))))))  (BoxGet(VarParam(fold, 0)) BoxGet(VarBound(obj, 0, 1))  BoxGet(VarBound(lists, 0, 2))))) whatever))))
;; Starting: Item 0 in Seq statement #26
;; Starting: Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(null?, 0)
;; Starting: Get VarParam(name=null?, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=null?, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(null?, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0))

;; Finished: Item 0 in Seq statement #26


;; Starting: Item 1 in Seq statement #26
;; Starting: Set VarParam(name=apply, minor=1) with Box(VarParam(apply, 1))
;; Starting: Evaluating rhs for [ Set VarParam(name=apply, minor=1) with Box(VarParam(apply, 1)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(apply, 1)
;; Starting: Get VarParam(name=apply, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=apply, minor=1)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(apply, 1)

;; Finished: Evaluating rhs for [ Set VarParam(name=apply, minor=1) with Box(VarParam(apply, 1)) ], value is expected in rax

mov PVAR(1), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=apply, minor=1) with Box(VarParam(apply, 1))

;; Finished: Item 1 in Seq statement #26


;; Starting: Item 2 in Seq statement #26
;; Starting: Set VarParam(name=cons, minor=2) with Box(VarParam(cons, 2))
;; Starting: Evaluating rhs for [ Set VarParam(name=cons, minor=2) with Box(VarParam(cons, 2)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(cons, 2)
;; Starting: Get VarParam(name=cons, minor=2)
mov rax, PVAR(2)
;; Finished: Get VarParam(name=cons, minor=2)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(cons, 2)

;; Finished: Evaluating rhs for [ Set VarParam(name=cons, minor=2) with Box(VarParam(cons, 2)) ], value is expected in rax

mov PVAR(2), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=cons, minor=2) with Box(VarParam(cons, 2))

;; Finished: Item 2 in Seq statement #26


;; Starting: Item 3 in Seq statement #26
;; Starting: Set VarParam(name=map, minor=3) with Box(VarParam(map, 3))
;; Starting: Evaluating rhs for [ Set VarParam(name=map, minor=3) with Box(VarParam(map, 3)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(map, 3)
;; Starting: Get VarParam(name=map, minor=3)
mov rax, PVAR(3)
;; Finished: Get VarParam(name=map, minor=3)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(map, 3)

;; Finished: Evaluating rhs for [ Set VarParam(name=map, minor=3) with Box(VarParam(map, 3)) ], value is expected in rax

mov PVAR(3), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=map, minor=3) with Box(VarParam(map, 3))

;; Finished: Item 3 in Seq statement #26


;; Starting: Item 4 in Seq statement #26
;; Starting: Set VarParam(name=car, minor=4) with Box(VarParam(car, 4))
;; Starting: Evaluating rhs for [ Set VarParam(name=car, minor=4) with Box(VarParam(car, 4)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(car, 4)
;; Starting: Get VarParam(name=car, minor=4)
mov rax, PVAR(4)
;; Finished: Get VarParam(name=car, minor=4)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(car, 4)

;; Finished: Evaluating rhs for [ Set VarParam(name=car, minor=4) with Box(VarParam(car, 4)) ], value is expected in rax

mov PVAR(4), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=car, minor=4) with Box(VarParam(car, 4))

;; Finished: Item 4 in Seq statement #26


;; Starting: Item 5 in Seq statement #26
;; Starting: Set VarParam(name=cdr, minor=5) with Box(VarParam(cdr, 5))
;; Starting: Evaluating rhs for [ Set VarParam(name=cdr, minor=5) with Box(VarParam(cdr, 5)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(cdr, 5)
;; Starting: Get VarParam(name=cdr, minor=5)
mov rax, PVAR(5)
;; Finished: Get VarParam(name=cdr, minor=5)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(cdr, 5)

;; Finished: Evaluating rhs for [ Set VarParam(name=cdr, minor=5) with Box(VarParam(cdr, 5)) ], value is expected in rax

mov PVAR(5), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=cdr, minor=5) with Box(VarParam(cdr, 5))

;; Finished: Item 5 in Seq statement #26


;; Starting: Item 6 in Seq statement #26

;; Finished: Item 6 in Seq statement #26

;; Finished: Seq statement #26: (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(apply, 1) Box(VarParam(apply, 1)))  (set! VarParam(cons, 2) Box(VarParam(cons, 2)))  (set! VarParam(map, 3) Box(VarParam(map, 3)))  (set! VarParam(car, 4) Box(VarParam(car, 4)))  (set! VarParam(cdr, 5) Box(VarParam(cdr, 5)))  (lambda (f obj . lists) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(obj, 1) Box(VarParam(obj, 1)))  (set! VarParam(lists, 2) Box(VarParam(lists, 2)))  ((lambda (fold) (begin (set! VarParam(fold, 0) Box(VarParam(fold, 0)))  BoxSet(VarParam(fold, 0), (lambda (obj lists) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(car, 2, 4)) VarParam(lists, 1))) VarParam(obj, 0) (BoxGet(VarBound(fold, 0, 0)) (BoxGet(VarBound(apply, 2, 1)) BoxGet(VarBound(f, 1, 0))  (BoxGet(VarBound(cons, 2, 2)) VarParam(obj, 0)  (BoxGet(VarBound(map, 2, 3)) BoxGet(VarBound(car, 2, 4))  VarParam(lists, 1))))  (BoxGet(VarBound(map, 2, 3)) BoxGet(VarBound(cdr, 2, 5))  VarParam(lists, 1))))))  (BoxGet(VarParam(fold, 0)) BoxGet(VarBound(obj, 0, 1))  BoxGet(VarBound(lists, 0, 2))))) whatever))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont25:

;; Finished: Creating CLOSURE of LambdaSimple#25 -> (lambda (null? apply cons map car cdr) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(apply, 1) Box(VarParam(apply, 1)))  (set! VarParam(cons, 2) Box(VarParam(cons, 2)))  (set! VarParam(map, 3) Box(VarParam(map, 3)))  (set! VarParam(car, 4) Box(VarParam(car, 4)))  (set! VarParam(cdr, 5) Box(VarParam(cdr, 5)))  (lambda (f obj . lists) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(obj, 1) Box(VarParam(obj, 1)))  (set! VarParam(lists, 2) Box(VarParam(lists, 2)))  ((lambda (fold) (begin (set! VarParam(fold, 0) Box(VarParam(fold, 0)))  BoxSet(VarParam(fold, 0), (lambda (obj lists) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(car, 2, 4)) VarParam(lists, 1))) VarParam(obj, 0) (BoxGet(VarBound(fold, 0, 0)) (BoxGet(VarBound(apply, 2, 1)) BoxGet(VarBound(f, 1, 0))  (BoxGet(VarBound(cons, 2, 2)) VarParam(obj, 0)  (BoxGet(VarBound(map, 2, 3)) BoxGet(VarBound(car, 2, 4))  VarParam(lists, 1))))  (BoxGet(VarBound(map, 2, 3)) BoxGet(VarBound(cdr, 2, 5))  VarParam(lists, 1))))))  (BoxGet(VarParam(fold, 0)) BoxGet(VarBound(obj, 0, 1))  BoxGet(VarBound(lists, 0, 2))))) whatever)))))

;; Finished: Evaluating proc to apply (in Applic #24)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic24
; int3
ContinueApplic24:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #24
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#24 of: ((lambda (null? apply cons map car cdr) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(apply, 1) Box(VarParam(apply, 1)))  (set! VarParam(cons, 2) Box(VarParam(cons, 2)))  (set! VarParam(map, 3) Box(VarParam(map, 3)))  (set! VarParam(car, 4) Box(VarParam(car, 4)))  (set! VarParam(cdr, 5) Box(VarParam(cdr, 5)))  (lambda (f obj . lists) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(obj, 1) Box(VarParam(obj, 1)))  (set! VarParam(lists, 2) Box(VarParam(lists, 2)))  ((lambda (fold) (begin (set! VarParam(fold, 0) Box(VarParam(fold, 0)))  BoxSet(VarParam(fold, 0), (lambda (obj lists) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(car, 2, 4)) VarParam(lists, 1))) VarParam(obj, 0) (BoxGet(VarBound(fold, 0, 0)) (BoxGet(VarBound(apply, 2, 1)) BoxGet(VarBound(f, 1, 0))  (BoxGet(VarBound(cons, 2, 2)) VarParam(obj, 0)  (BoxGet(VarBound(map, 2, 3)) BoxGet(VarBound(car, 2, 4))  VarParam(lists, 1))))  (BoxGet(VarBound(map, 2, 3)) BoxGet(VarBound(cdr, 2, 5))  VarParam(lists, 1))))))  (BoxGet(VarParam(fold, 0)) BoxGet(VarBound(obj, 0, 1))  BoxGet(VarBound(lists, 0, 2))))) whatever))))) VarFree(null?)  VarFree(apply)  VarFree(cons)  VarFree(map)  VarFree(car)  VarFree(cdr))

mov qword [fvar_tbl+8*6], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar fold-left to ((lambda (null? apply cons map car cdr) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(apply, 1) Box(VarParam(apply, 1)))  (set! VarParam(cons, 2) Box(VarParam(cons, 2)))  (set! VarParam(map, 3) Box(VarParam(map, 3)))  (set! VarParam(car, 4) Box(VarParam(car, 4)))  (set! VarParam(cdr, 5) Box(VarParam(cdr, 5)))  (lambda (f obj . lists) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(obj, 1) Box(VarParam(obj, 1)))  (set! VarParam(lists, 2) Box(VarParam(lists, 2)))  ((lambda (fold) (begin (set! VarParam(fold, 0) Box(VarParam(fold, 0)))  BoxSet(VarParam(fold, 0), (lambda (obj lists) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(car, 2, 4)) VarParam(lists, 1))) VarParam(obj, 0) (BoxGet(VarBound(fold, 0, 0)) (BoxGet(VarBound(apply, 2, 1)) BoxGet(VarBound(f, 1, 0))  (BoxGet(VarBound(cons, 2, 2)) VarParam(obj, 0)  (BoxGet(VarBound(map, 2, 3)) BoxGet(VarBound(car, 2, 4))  VarParam(lists, 1))))  (BoxGet(VarBound(map, 2, 3)) BoxGet(VarBound(cdr, 2, 5))  VarParam(lists, 1))))))  (BoxGet(VarParam(fold, 0)) BoxGet(VarBound(obj, 0, 1))  BoxGet(VarBound(lists, 0, 2))))) whatever))))) VarFree(null?)  VarFree(apply)  VarFree(cons)  VarFree(map)  VarFree(car)  VarFree(cdr))

	call write_sob_if_not_void

;; Starting: Set fvar fold-right to ((lambda (null? cons car cdr apply map append) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(cons, 1) Box(VarParam(cons, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  (set! VarParam(apply, 4) Box(VarParam(apply, 4)))  (set! VarParam(map, 5) Box(VarParam(map, 5)))  (set! VarParam(append, 6) Box(VarParam(append, 6)))  (lambda (f obj . lists) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(obj, 1) Box(VarParam(obj, 1)))  (set! VarParam(lists, 2) Box(VarParam(lists, 2)))  ((lambda (fold) (begin (set! VarParam(fold, 0) Box(VarParam(fold, 0)))  BoxSet(VarParam(fold, 0), (lambda (f obj lists) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(car, 2, 2)) VarParam(lists, 2))) VarParam(obj, 1) ((lambda (car-lists res) (BoxGet(VarBound(apply, 3, 4)) VarBound(f, 0, 0)  (BoxGet(VarBound(append, 3, 6)) VarParam(car-lists, 0)  (BoxGet(VarBound(cons, 3, 1)) VarParam(res, 1)  ())))) (BoxGet(VarBound(map, 2, 5)) BoxGet(VarBound(car, 2, 2))  VarParam(lists, 2))  (BoxGet(VarBound(fold, 0, 0)) VarParam(f, 0)  VarParam(obj, 1)  (BoxGet(VarBound(map, 2, 5)) BoxGet(VarBound(cdr, 2, 3))  VarParam(lists, 2)))))))  (BoxGet(VarParam(fold, 0)) BoxGet(VarBound(f, 0, 0))  BoxGet(VarBound(obj, 0, 1))  BoxGet(VarBound(lists, 0, 2))))) whatever))))) VarFree(null?)  VarFree(cons)  VarFree(car)  VarFree(cdr)  VarFree(apply)  VarFree(map)  (lambda (lst x) (begin (set! VarParam(lst, 0) Box(VarParam(lst, 0)))  (set! VarParam(x, 1) Box(VarParam(x, 1)))  (if (VarFree(null?) BoxGet(VarParam(lst, 0))) BoxGet(VarParam(x, 1)) (VarFree(cons) (VarFree(car) BoxGet(VarParam(lst, 0)))  (VarFree(append) (VarFree(cdr) BoxGet(VarParam(lst, 0)))  BoxGet(VarParam(x, 1))))))))
;; Starting: Perform Applic#27 of: ((lambda (null? cons car cdr apply map append) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(cons, 1) Box(VarParam(cons, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  (set! VarParam(apply, 4) Box(VarParam(apply, 4)))  (set! VarParam(map, 5) Box(VarParam(map, 5)))  (set! VarParam(append, 6) Box(VarParam(append, 6)))  (lambda (f obj . lists) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(obj, 1) Box(VarParam(obj, 1)))  (set! VarParam(lists, 2) Box(VarParam(lists, 2)))  ((lambda (fold) (begin (set! VarParam(fold, 0) Box(VarParam(fold, 0)))  BoxSet(VarParam(fold, 0), (lambda (f obj lists) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(car, 2, 2)) VarParam(lists, 2))) VarParam(obj, 1) ((lambda (car-lists res) (BoxGet(VarBound(apply, 3, 4)) VarBound(f, 0, 0)  (BoxGet(VarBound(append, 3, 6)) VarParam(car-lists, 0)  (BoxGet(VarBound(cons, 3, 1)) VarParam(res, 1)  ())))) (BoxGet(VarBound(map, 2, 5)) BoxGet(VarBound(car, 2, 2))  VarParam(lists, 2))  (BoxGet(VarBound(fold, 0, 0)) VarParam(f, 0)  VarParam(obj, 1)  (BoxGet(VarBound(map, 2, 5)) BoxGet(VarBound(cdr, 2, 3))  VarParam(lists, 2)))))))  (BoxGet(VarParam(fold, 0)) BoxGet(VarBound(f, 0, 0))  BoxGet(VarBound(obj, 0, 1))  BoxGet(VarBound(lists, 0, 2))))) whatever))))) VarFree(null?)  VarFree(cons)  VarFree(car)  VarFree(cdr)  VarFree(apply)  VarFree(map)  (lambda (lst x) (begin (set! VarParam(lst, 0) Box(VarParam(lst, 0)))  (set! VarParam(x, 1) Box(VarParam(x, 1)))  (if (VarFree(null?) BoxGet(VarParam(lst, 0))) BoxGet(VarParam(x, 1)) (VarFree(cons) (VarFree(car) BoxGet(VarParam(lst, 0)))  (VarFree(append) (VarFree(cdr) BoxGet(VarParam(lst, 0)))  BoxGet(VarParam(x, 1))))))))
;; Starting: Argument 6 of Applic statement #27
;; Starting: Creating CLOSURE of LambdaSimple#28 -> (lambda (lst x) (begin (set! VarParam(lst, 0) Box(VarParam(lst, 0)))  (set! VarParam(x, 1) Box(VarParam(x, 1)))  (if (VarFree(null?) BoxGet(VarParam(lst, 0))) BoxGet(VarParam(x, 1)) (VarFree(cons) (VarFree(car) BoxGet(VarParam(lst, 0)))  (VarFree(append) (VarFree(cdr) BoxGet(VarParam(lst, 0)))  BoxGet(VarParam(x, 1)))))))
push rbx
; Env Extend Code Section For Closure#28
mov rbx, 0 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend28
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End28

LClosureEnvExtend28:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, -1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 0
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop28:
  jz LClosureEnvExtend_LoopEnd28
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop28

LClosureEnvExtend_LoopEnd28:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd28
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop28:
  jz LClosureEnvExtend_ParamsLoopEnd28

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop28

LClosureEnvExtend_ParamsLoopEnd28:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End28:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode28)
pop rbx
jmp LClosureCont28
LClosureCode28:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #29: (begin (set! VarParam(lst, 0) Box(VarParam(lst, 0)))  (set! VarParam(x, 1) Box(VarParam(x, 1)))  (if (VarFree(null?) BoxGet(VarParam(lst, 0))) BoxGet(VarParam(x, 1)) (VarFree(cons) (VarFree(car) BoxGet(VarParam(lst, 0)))  (VarFree(append) (VarFree(cdr) BoxGet(VarParam(lst, 0)))  BoxGet(VarParam(x, 1))))))
;; Starting: Item 0 in Seq statement #29
;; Starting: Set VarParam(name=lst, minor=0) with Box(VarParam(lst, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=lst, minor=0) with Box(VarParam(lst, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(lst, 0)
;; Starting: Get VarParam(name=lst, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=lst, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(lst, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=lst, minor=0) with Box(VarParam(lst, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=lst, minor=0) with Box(VarParam(lst, 0))

;; Finished: Item 0 in Seq statement #29


;; Starting: Item 1 in Seq statement #29
;; Starting: Set VarParam(name=x, minor=1) with Box(VarParam(x, 1))
;; Starting: Evaluating rhs for [ Set VarParam(name=x, minor=1) with Box(VarParam(x, 1)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(x, 1)
;; Starting: Get VarParam(name=x, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=x, minor=1)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(x, 1)

;; Finished: Evaluating rhs for [ Set VarParam(name=x, minor=1) with Box(VarParam(x, 1)) ], value is expected in rax

mov PVAR(1), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=x, minor=1) with Box(VarParam(x, 1))

;; Finished: Item 1 in Seq statement #29


;; Starting: Item 2 in Seq statement #29
;; Starting: If statement (#30): (if (VarFree(null?) BoxGet(VarParam(lst, 0))) BoxGet(VarParam(x, 1)) (VarFree(cons) (VarFree(car) BoxGet(VarParam(lst, 0)))  (VarFree(append) (VarFree(cdr) BoxGet(VarParam(lst, 0)))  BoxGet(VarParam(x, 1)))))
Lif30:
;; Starting: Perform Applic#31 of: (VarFree(null?) BoxGet(VarParam(lst, 0)))
;; Starting: Argument 0 of Applic statement #31
;; Starting: BoxGet of VarParam(lst, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(lst, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=lst, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=lst, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(lst, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(lst, 0)

;; Finished: Argument 0 of Applic statement #31

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #31)
mov rax, qword [fvar_tbl+8*1]	; mov fvar null? to rax
;; Finished: Evaluating proc to apply (in Applic #31)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic31
; int3
ContinueApplic31:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #31
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#31 of: (VarFree(null?) BoxGet(VarParam(lst, 0)))

cmp rax, SOB_FALSE_ADDRESS
je Lelse30
;; Starting: BoxGet of VarParam(x, 1)
;; Starting: Evaluating val for [ BoxGet of VarParam(x, 1) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=x, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=x, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarParam(x, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(x, 1)

jmp LendIf30
Lelse30:
;; Starting: Perform Applic#32 of: (VarFree(cons) (VarFree(car) BoxGet(VarParam(lst, 0)))  (VarFree(append) (VarFree(cdr) BoxGet(VarParam(lst, 0)))  BoxGet(VarParam(x, 1))))
;; Starting: Argument 1 of Applic statement #32
;; Starting: Perform Applic#34 of: (VarFree(append) (VarFree(cdr) BoxGet(VarParam(lst, 0)))  BoxGet(VarParam(x, 1)))
;; Starting: Argument 1 of Applic statement #34
;; Starting: BoxGet of VarParam(x, 1)
;; Starting: Evaluating val for [ BoxGet of VarParam(x, 1) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=x, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=x, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarParam(x, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(x, 1)

;; Finished: Argument 1 of Applic statement #34

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #34
;; Starting: Perform Applic#35 of: (VarFree(cdr) BoxGet(VarParam(lst, 0)))
;; Starting: Argument 0 of Applic statement #35
;; Starting: BoxGet of VarParam(lst, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(lst, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=lst, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=lst, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(lst, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(lst, 0)

;; Finished: Argument 0 of Applic statement #35

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #35)
mov rax, qword [fvar_tbl+8*3]	; mov fvar cdr to rax
;; Finished: Evaluating proc to apply (in Applic #35)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic35
; int3
ContinueApplic35:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #35
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#35 of: (VarFree(cdr) BoxGet(VarParam(lst, 0)))

;; Finished: Argument 0 of Applic statement #34

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #34)
mov rax, qword [fvar_tbl+8*8]	; mov fvar append to rax
;; Finished: Evaluating proc to apply (in Applic #34)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic34
; int3
ContinueApplic34:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #34
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#34 of: (VarFree(append) (VarFree(cdr) BoxGet(VarParam(lst, 0)))  BoxGet(VarParam(x, 1)))

;; Finished: Argument 1 of Applic statement #32

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #32
;; Starting: Perform Applic#33 of: (VarFree(car) BoxGet(VarParam(lst, 0)))
;; Starting: Argument 0 of Applic statement #33
;; Starting: BoxGet of VarParam(lst, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(lst, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=lst, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=lst, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(lst, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(lst, 0)

;; Finished: Argument 0 of Applic statement #33

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #33)
mov rax, qword [fvar_tbl+8*2]	; mov fvar car to rax
;; Finished: Evaluating proc to apply (in Applic #33)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic33
; int3
ContinueApplic33:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #33
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#33 of: (VarFree(car) BoxGet(VarParam(lst, 0)))

;; Finished: Argument 0 of Applic statement #32

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #32)
mov rax, qword [fvar_tbl+8*4]	; mov fvar cons to rax
;; Finished: Evaluating proc to apply (in Applic #32)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic32
; int3
ContinueApplic32:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #32
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#32 of: (VarFree(cons) (VarFree(car) BoxGet(VarParam(lst, 0)))  (VarFree(append) (VarFree(cdr) BoxGet(VarParam(lst, 0)))  BoxGet(VarParam(x, 1))))

LendIf30:
;; Finished: If statement (#30): (if (VarFree(null?) BoxGet(VarParam(lst, 0))) BoxGet(VarParam(x, 1)) (VarFree(cons) (VarFree(car) BoxGet(VarParam(lst, 0)))  (VarFree(append) (VarFree(cdr) BoxGet(VarParam(lst, 0)))  BoxGet(VarParam(x, 1)))))

;; Finished: Item 2 in Seq statement #29

;; Finished: Seq statement #29: (begin (set! VarParam(lst, 0) Box(VarParam(lst, 0)))  (set! VarParam(x, 1) Box(VarParam(x, 1)))  (if (VarFree(null?) BoxGet(VarParam(lst, 0))) BoxGet(VarParam(x, 1)) (VarFree(cons) (VarFree(car) BoxGet(VarParam(lst, 0)))  (VarFree(append) (VarFree(cdr) BoxGet(VarParam(lst, 0)))  BoxGet(VarParam(x, 1))))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont28:

;; Finished: Creating CLOSURE of LambdaSimple#28 -> (lambda (lst x) (begin (set! VarParam(lst, 0) Box(VarParam(lst, 0)))  (set! VarParam(x, 1) Box(VarParam(x, 1)))  (if (VarFree(null?) BoxGet(VarParam(lst, 0))) BoxGet(VarParam(x, 1)) (VarFree(cons) (VarFree(car) BoxGet(VarParam(lst, 0)))  (VarFree(append) (VarFree(cdr) BoxGet(VarParam(lst, 0)))  BoxGet(VarParam(x, 1)))))))

;; Finished: Argument 6 of Applic statement #27

push rax ; Push argument to stack;; Starting: Argument 5 of Applic statement #27
mov rax, qword [fvar_tbl+8*0]	; mov fvar map to rax
;; Finished: Argument 5 of Applic statement #27

push rax ; Push argument to stack;; Starting: Argument 4 of Applic statement #27
mov rax, qword [fvar_tbl+8*5]	; mov fvar apply to rax
;; Finished: Argument 4 of Applic statement #27

push rax ; Push argument to stack;; Starting: Argument 3 of Applic statement #27
mov rax, qword [fvar_tbl+8*3]	; mov fvar cdr to rax
;; Finished: Argument 3 of Applic statement #27

push rax ; Push argument to stack;; Starting: Argument 2 of Applic statement #27
mov rax, qword [fvar_tbl+8*2]	; mov fvar car to rax
;; Finished: Argument 2 of Applic statement #27

push rax ; Push argument to stack;; Starting: Argument 1 of Applic statement #27
mov rax, qword [fvar_tbl+8*4]	; mov fvar cons to rax
;; Finished: Argument 1 of Applic statement #27

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #27
mov rax, qword [fvar_tbl+8*1]	; mov fvar null? to rax
;; Finished: Argument 0 of Applic statement #27

push rax ; Push argument to stack
push qword 7 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #27)
;; Starting: Creating CLOSURE of LambdaSimple#36 -> (lambda (null? cons car cdr apply map append) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(cons, 1) Box(VarParam(cons, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  (set! VarParam(apply, 4) Box(VarParam(apply, 4)))  (set! VarParam(map, 5) Box(VarParam(map, 5)))  (set! VarParam(append, 6) Box(VarParam(append, 6)))  (lambda (f obj . lists) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(obj, 1) Box(VarParam(obj, 1)))  (set! VarParam(lists, 2) Box(VarParam(lists, 2)))  ((lambda (fold) (begin (set! VarParam(fold, 0) Box(VarParam(fold, 0)))  BoxSet(VarParam(fold, 0), (lambda (f obj lists) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(car, 2, 2)) VarParam(lists, 2))) VarParam(obj, 1) ((lambda (car-lists res) (BoxGet(VarBound(apply, 3, 4)) VarBound(f, 0, 0)  (BoxGet(VarBound(append, 3, 6)) VarParam(car-lists, 0)  (BoxGet(VarBound(cons, 3, 1)) VarParam(res, 1)  ())))) (BoxGet(VarBound(map, 2, 5)) BoxGet(VarBound(car, 2, 2))  VarParam(lists, 2))  (BoxGet(VarBound(fold, 0, 0)) VarParam(f, 0)  VarParam(obj, 1)  (BoxGet(VarBound(map, 2, 5)) BoxGet(VarBound(cdr, 2, 3))  VarParam(lists, 2)))))))  (BoxGet(VarParam(fold, 0)) BoxGet(VarBound(f, 0, 0))  BoxGet(VarBound(obj, 0, 1))  BoxGet(VarBound(lists, 0, 2))))) whatever)))))
push rbx
; Env Extend Code Section For Closure#36
mov rbx, 1 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend36
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End36

LClosureEnvExtend36:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 0
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 8
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop36:
  jz LClosureEnvExtend_LoopEnd36
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop36

LClosureEnvExtend_LoopEnd36:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd36
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop36:
  jz LClosureEnvExtend_ParamsLoopEnd36

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop36

LClosureEnvExtend_ParamsLoopEnd36:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End36:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode36)
pop rbx
jmp LClosureCont36
LClosureCode36:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #37: (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(cons, 1) Box(VarParam(cons, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  (set! VarParam(apply, 4) Box(VarParam(apply, 4)))  (set! VarParam(map, 5) Box(VarParam(map, 5)))  (set! VarParam(append, 6) Box(VarParam(append, 6)))  (lambda (f obj . lists) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(obj, 1) Box(VarParam(obj, 1)))  (set! VarParam(lists, 2) Box(VarParam(lists, 2)))  ((lambda (fold) (begin (set! VarParam(fold, 0) Box(VarParam(fold, 0)))  BoxSet(VarParam(fold, 0), (lambda (f obj lists) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(car, 2, 2)) VarParam(lists, 2))) VarParam(obj, 1) ((lambda (car-lists res) (BoxGet(VarBound(apply, 3, 4)) VarBound(f, 0, 0)  (BoxGet(VarBound(append, 3, 6)) VarParam(car-lists, 0)  (BoxGet(VarBound(cons, 3, 1)) VarParam(res, 1)  ())))) (BoxGet(VarBound(map, 2, 5)) BoxGet(VarBound(car, 2, 2))  VarParam(lists, 2))  (BoxGet(VarBound(fold, 0, 0)) VarParam(f, 0)  VarParam(obj, 1)  (BoxGet(VarBound(map, 2, 5)) BoxGet(VarBound(cdr, 2, 3))  VarParam(lists, 2)))))))  (BoxGet(VarParam(fold, 0)) BoxGet(VarBound(f, 0, 0))  BoxGet(VarBound(obj, 0, 1))  BoxGet(VarBound(lists, 0, 2))))) whatever))))
;; Starting: Item 0 in Seq statement #37
;; Starting: Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(null?, 0)
;; Starting: Get VarParam(name=null?, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=null?, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(null?, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0))

;; Finished: Item 0 in Seq statement #37


;; Starting: Item 1 in Seq statement #37
;; Starting: Set VarParam(name=cons, minor=1) with Box(VarParam(cons, 1))
;; Starting: Evaluating rhs for [ Set VarParam(name=cons, minor=1) with Box(VarParam(cons, 1)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(cons, 1)
;; Starting: Get VarParam(name=cons, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=cons, minor=1)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(cons, 1)

;; Finished: Evaluating rhs for [ Set VarParam(name=cons, minor=1) with Box(VarParam(cons, 1)) ], value is expected in rax

mov PVAR(1), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=cons, minor=1) with Box(VarParam(cons, 1))

;; Finished: Item 1 in Seq statement #37


;; Starting: Item 2 in Seq statement #37
;; Starting: Set VarParam(name=car, minor=2) with Box(VarParam(car, 2))
;; Starting: Evaluating rhs for [ Set VarParam(name=car, minor=2) with Box(VarParam(car, 2)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(car, 2)
;; Starting: Get VarParam(name=car, minor=2)
mov rax, PVAR(2)
;; Finished: Get VarParam(name=car, minor=2)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(car, 2)

;; Finished: Evaluating rhs for [ Set VarParam(name=car, minor=2) with Box(VarParam(car, 2)) ], value is expected in rax

mov PVAR(2), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=car, minor=2) with Box(VarParam(car, 2))

;; Finished: Item 2 in Seq statement #37


;; Starting: Item 3 in Seq statement #37
;; Starting: Set VarParam(name=cdr, minor=3) with Box(VarParam(cdr, 3))
;; Starting: Evaluating rhs for [ Set VarParam(name=cdr, minor=3) with Box(VarParam(cdr, 3)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(cdr, 3)
;; Starting: Get VarParam(name=cdr, minor=3)
mov rax, PVAR(3)
;; Finished: Get VarParam(name=cdr, minor=3)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(cdr, 3)

;; Finished: Evaluating rhs for [ Set VarParam(name=cdr, minor=3) with Box(VarParam(cdr, 3)) ], value is expected in rax

mov PVAR(3), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=cdr, minor=3) with Box(VarParam(cdr, 3))

;; Finished: Item 3 in Seq statement #37


;; Starting: Item 4 in Seq statement #37
;; Starting: Set VarParam(name=apply, minor=4) with Box(VarParam(apply, 4))
;; Starting: Evaluating rhs for [ Set VarParam(name=apply, minor=4) with Box(VarParam(apply, 4)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(apply, 4)
;; Starting: Get VarParam(name=apply, minor=4)
mov rax, PVAR(4)
;; Finished: Get VarParam(name=apply, minor=4)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(apply, 4)

;; Finished: Evaluating rhs for [ Set VarParam(name=apply, minor=4) with Box(VarParam(apply, 4)) ], value is expected in rax

mov PVAR(4), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=apply, minor=4) with Box(VarParam(apply, 4))

;; Finished: Item 4 in Seq statement #37


;; Starting: Item 5 in Seq statement #37
;; Starting: Set VarParam(name=map, minor=5) with Box(VarParam(map, 5))
;; Starting: Evaluating rhs for [ Set VarParam(name=map, minor=5) with Box(VarParam(map, 5)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(map, 5)
;; Starting: Get VarParam(name=map, minor=5)
mov rax, PVAR(5)
;; Finished: Get VarParam(name=map, minor=5)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(map, 5)

;; Finished: Evaluating rhs for [ Set VarParam(name=map, minor=5) with Box(VarParam(map, 5)) ], value is expected in rax

mov PVAR(5), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=map, minor=5) with Box(VarParam(map, 5))

;; Finished: Item 5 in Seq statement #37


;; Starting: Item 6 in Seq statement #37
;; Starting: Set VarParam(name=append, minor=6) with Box(VarParam(append, 6))
;; Starting: Evaluating rhs for [ Set VarParam(name=append, minor=6) with Box(VarParam(append, 6)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(append, 6)
;; Starting: Get VarParam(name=append, minor=6)
mov rax, PVAR(6)
;; Finished: Get VarParam(name=append, minor=6)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(append, 6)

;; Finished: Evaluating rhs for [ Set VarParam(name=append, minor=6) with Box(VarParam(append, 6)) ], value is expected in rax

mov PVAR(6), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=append, minor=6) with Box(VarParam(append, 6))

;; Finished: Item 6 in Seq statement #37


;; Starting: Item 7 in Seq statement #37

;; Finished: Item 7 in Seq statement #37

;; Finished: Seq statement #37: (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(cons, 1) Box(VarParam(cons, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  (set! VarParam(apply, 4) Box(VarParam(apply, 4)))  (set! VarParam(map, 5) Box(VarParam(map, 5)))  (set! VarParam(append, 6) Box(VarParam(append, 6)))  (lambda (f obj . lists) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(obj, 1) Box(VarParam(obj, 1)))  (set! VarParam(lists, 2) Box(VarParam(lists, 2)))  ((lambda (fold) (begin (set! VarParam(fold, 0) Box(VarParam(fold, 0)))  BoxSet(VarParam(fold, 0), (lambda (f obj lists) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(car, 2, 2)) VarParam(lists, 2))) VarParam(obj, 1) ((lambda (car-lists res) (BoxGet(VarBound(apply, 3, 4)) VarBound(f, 0, 0)  (BoxGet(VarBound(append, 3, 6)) VarParam(car-lists, 0)  (BoxGet(VarBound(cons, 3, 1)) VarParam(res, 1)  ())))) (BoxGet(VarBound(map, 2, 5)) BoxGet(VarBound(car, 2, 2))  VarParam(lists, 2))  (BoxGet(VarBound(fold, 0, 0)) VarParam(f, 0)  VarParam(obj, 1)  (BoxGet(VarBound(map, 2, 5)) BoxGet(VarBound(cdr, 2, 3))  VarParam(lists, 2)))))))  (BoxGet(VarParam(fold, 0)) BoxGet(VarBound(f, 0, 0))  BoxGet(VarBound(obj, 0, 1))  BoxGet(VarBound(lists, 0, 2))))) whatever))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont36:

;; Finished: Creating CLOSURE of LambdaSimple#36 -> (lambda (null? cons car cdr apply map append) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(cons, 1) Box(VarParam(cons, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  (set! VarParam(apply, 4) Box(VarParam(apply, 4)))  (set! VarParam(map, 5) Box(VarParam(map, 5)))  (set! VarParam(append, 6) Box(VarParam(append, 6)))  (lambda (f obj . lists) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(obj, 1) Box(VarParam(obj, 1)))  (set! VarParam(lists, 2) Box(VarParam(lists, 2)))  ((lambda (fold) (begin (set! VarParam(fold, 0) Box(VarParam(fold, 0)))  BoxSet(VarParam(fold, 0), (lambda (f obj lists) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(car, 2, 2)) VarParam(lists, 2))) VarParam(obj, 1) ((lambda (car-lists res) (BoxGet(VarBound(apply, 3, 4)) VarBound(f, 0, 0)  (BoxGet(VarBound(append, 3, 6)) VarParam(car-lists, 0)  (BoxGet(VarBound(cons, 3, 1)) VarParam(res, 1)  ())))) (BoxGet(VarBound(map, 2, 5)) BoxGet(VarBound(car, 2, 2))  VarParam(lists, 2))  (BoxGet(VarBound(fold, 0, 0)) VarParam(f, 0)  VarParam(obj, 1)  (BoxGet(VarBound(map, 2, 5)) BoxGet(VarBound(cdr, 2, 3))  VarParam(lists, 2)))))))  (BoxGet(VarParam(fold, 0)) BoxGet(VarBound(f, 0, 0))  BoxGet(VarBound(obj, 0, 1))  BoxGet(VarBound(lists, 0, 2))))) whatever)))))

;; Finished: Evaluating proc to apply (in Applic #27)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic27
; int3
ContinueApplic27:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #27
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#27 of: ((lambda (null? cons car cdr apply map append) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(cons, 1) Box(VarParam(cons, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  (set! VarParam(apply, 4) Box(VarParam(apply, 4)))  (set! VarParam(map, 5) Box(VarParam(map, 5)))  (set! VarParam(append, 6) Box(VarParam(append, 6)))  (lambda (f obj . lists) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(obj, 1) Box(VarParam(obj, 1)))  (set! VarParam(lists, 2) Box(VarParam(lists, 2)))  ((lambda (fold) (begin (set! VarParam(fold, 0) Box(VarParam(fold, 0)))  BoxSet(VarParam(fold, 0), (lambda (f obj lists) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(car, 2, 2)) VarParam(lists, 2))) VarParam(obj, 1) ((lambda (car-lists res) (BoxGet(VarBound(apply, 3, 4)) VarBound(f, 0, 0)  (BoxGet(VarBound(append, 3, 6)) VarParam(car-lists, 0)  (BoxGet(VarBound(cons, 3, 1)) VarParam(res, 1)  ())))) (BoxGet(VarBound(map, 2, 5)) BoxGet(VarBound(car, 2, 2))  VarParam(lists, 2))  (BoxGet(VarBound(fold, 0, 0)) VarParam(f, 0)  VarParam(obj, 1)  (BoxGet(VarBound(map, 2, 5)) BoxGet(VarBound(cdr, 2, 3))  VarParam(lists, 2)))))))  (BoxGet(VarParam(fold, 0)) BoxGet(VarBound(f, 0, 0))  BoxGet(VarBound(obj, 0, 1))  BoxGet(VarBound(lists, 0, 2))))) whatever))))) VarFree(null?)  VarFree(cons)  VarFree(car)  VarFree(cdr)  VarFree(apply)  VarFree(map)  (lambda (lst x) (begin (set! VarParam(lst, 0) Box(VarParam(lst, 0)))  (set! VarParam(x, 1) Box(VarParam(x, 1)))  (if (VarFree(null?) BoxGet(VarParam(lst, 0))) BoxGet(VarParam(x, 1)) (VarFree(cons) (VarFree(car) BoxGet(VarParam(lst, 0)))  (VarFree(append) (VarFree(cdr) BoxGet(VarParam(lst, 0)))  BoxGet(VarParam(x, 1))))))))

mov qword [fvar_tbl+8*7], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar fold-right to ((lambda (null? cons car cdr apply map append) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(cons, 1) Box(VarParam(cons, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  (set! VarParam(apply, 4) Box(VarParam(apply, 4)))  (set! VarParam(map, 5) Box(VarParam(map, 5)))  (set! VarParam(append, 6) Box(VarParam(append, 6)))  (lambda (f obj . lists) (begin (set! VarParam(f, 0) Box(VarParam(f, 0)))  (set! VarParam(obj, 1) Box(VarParam(obj, 1)))  (set! VarParam(lists, 2) Box(VarParam(lists, 2)))  ((lambda (fold) (begin (set! VarParam(fold, 0) Box(VarParam(fold, 0)))  BoxSet(VarParam(fold, 0), (lambda (f obj lists) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(car, 2, 2)) VarParam(lists, 2))) VarParam(obj, 1) ((lambda (car-lists res) (BoxGet(VarBound(apply, 3, 4)) VarBound(f, 0, 0)  (BoxGet(VarBound(append, 3, 6)) VarParam(car-lists, 0)  (BoxGet(VarBound(cons, 3, 1)) VarParam(res, 1)  ())))) (BoxGet(VarBound(map, 2, 5)) BoxGet(VarBound(car, 2, 2))  VarParam(lists, 2))  (BoxGet(VarBound(fold, 0, 0)) VarParam(f, 0)  VarParam(obj, 1)  (BoxGet(VarBound(map, 2, 5)) BoxGet(VarBound(cdr, 2, 3))  VarParam(lists, 2)))))))  (BoxGet(VarParam(fold, 0)) BoxGet(VarBound(f, 0, 0))  BoxGet(VarBound(obj, 0, 1))  BoxGet(VarBound(lists, 0, 2))))) whatever))))) VarFree(null?)  VarFree(cons)  VarFree(car)  VarFree(cdr)  VarFree(apply)  VarFree(map)  (lambda (lst x) (begin (set! VarParam(lst, 0) Box(VarParam(lst, 0)))  (set! VarParam(x, 1) Box(VarParam(x, 1)))  (if (VarFree(null?) BoxGet(VarParam(lst, 0))) BoxGet(VarParam(x, 1)) (VarFree(cons) (VarFree(car) BoxGet(VarParam(lst, 0)))  (VarFree(append) (VarFree(cdr) BoxGet(VarParam(lst, 0)))  BoxGet(VarParam(x, 1))))))))

	call write_sob_if_not_void

;; Starting: Set fvar cons* to ((lambda (null? cons car cdr) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(cons, 1) Box(VarParam(cons, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  (lambda p (begin (set! VarParam(p, 0) Box(VarParam(p, 0)))  ((lambda (cons-list) (begin (set! VarParam(cons-list, 0) Box(VarParam(cons-list, 0)))  BoxSet(VarParam(cons-list, 0), (lambda (p) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0)) (BoxGet(VarBound(cons, 2, 1)) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))  (BoxGet(VarBound(cons-list, 0, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0)))))))  (BoxGet(VarParam(cons-list, 0)) BoxGet(VarBound(p, 0, 0))))) whatever))))) VarFree(null?)  VarFree(cons)  VarFree(car)  VarFree(cdr))
;; Starting: Perform Applic#38 of: ((lambda (null? cons car cdr) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(cons, 1) Box(VarParam(cons, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  (lambda p (begin (set! VarParam(p, 0) Box(VarParam(p, 0)))  ((lambda (cons-list) (begin (set! VarParam(cons-list, 0) Box(VarParam(cons-list, 0)))  BoxSet(VarParam(cons-list, 0), (lambda (p) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0)) (BoxGet(VarBound(cons, 2, 1)) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))  (BoxGet(VarBound(cons-list, 0, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0)))))))  (BoxGet(VarParam(cons-list, 0)) BoxGet(VarBound(p, 0, 0))))) whatever))))) VarFree(null?)  VarFree(cons)  VarFree(car)  VarFree(cdr))
;; Starting: Argument 3 of Applic statement #38
mov rax, qword [fvar_tbl+8*3]	; mov fvar cdr to rax
;; Finished: Argument 3 of Applic statement #38

push rax ; Push argument to stack;; Starting: Argument 2 of Applic statement #38
mov rax, qword [fvar_tbl+8*2]	; mov fvar car to rax
;; Finished: Argument 2 of Applic statement #38

push rax ; Push argument to stack;; Starting: Argument 1 of Applic statement #38
mov rax, qword [fvar_tbl+8*4]	; mov fvar cons to rax
;; Finished: Argument 1 of Applic statement #38

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #38
mov rax, qword [fvar_tbl+8*1]	; mov fvar null? to rax
;; Finished: Argument 0 of Applic statement #38

push rax ; Push argument to stack
push qword 4 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #38)
;; Starting: Creating CLOSURE of LambdaSimple#39 -> (lambda (null? cons car cdr) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(cons, 1) Box(VarParam(cons, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  (lambda p (begin (set! VarParam(p, 0) Box(VarParam(p, 0)))  ((lambda (cons-list) (begin (set! VarParam(cons-list, 0) Box(VarParam(cons-list, 0)))  BoxSet(VarParam(cons-list, 0), (lambda (p) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0)) (BoxGet(VarBound(cons, 2, 1)) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))  (BoxGet(VarBound(cons-list, 0, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0)))))))  (BoxGet(VarParam(cons-list, 0)) BoxGet(VarBound(p, 0, 0))))) whatever)))))
push rbx
; Env Extend Code Section For Closure#39
mov rbx, 0 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend39
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End39

LClosureEnvExtend39:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, -1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 0
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop39:
  jz LClosureEnvExtend_LoopEnd39
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop39

LClosureEnvExtend_LoopEnd39:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd39
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop39:
  jz LClosureEnvExtend_ParamsLoopEnd39

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop39

LClosureEnvExtend_ParamsLoopEnd39:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End39:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode39)
pop rbx
jmp LClosureCont39
LClosureCode39:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #40: (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(cons, 1) Box(VarParam(cons, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  (lambda p (begin (set! VarParam(p, 0) Box(VarParam(p, 0)))  ((lambda (cons-list) (begin (set! VarParam(cons-list, 0) Box(VarParam(cons-list, 0)))  BoxSet(VarParam(cons-list, 0), (lambda (p) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0)) (BoxGet(VarBound(cons, 2, 1)) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))  (BoxGet(VarBound(cons-list, 0, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0)))))))  (BoxGet(VarParam(cons-list, 0)) BoxGet(VarBound(p, 0, 0))))) whatever))))
;; Starting: Item 0 in Seq statement #40
;; Starting: Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(null?, 0)
;; Starting: Get VarParam(name=null?, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=null?, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(null?, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0))

;; Finished: Item 0 in Seq statement #40


;; Starting: Item 1 in Seq statement #40
;; Starting: Set VarParam(name=cons, minor=1) with Box(VarParam(cons, 1))
;; Starting: Evaluating rhs for [ Set VarParam(name=cons, minor=1) with Box(VarParam(cons, 1)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(cons, 1)
;; Starting: Get VarParam(name=cons, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=cons, minor=1)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(cons, 1)

;; Finished: Evaluating rhs for [ Set VarParam(name=cons, minor=1) with Box(VarParam(cons, 1)) ], value is expected in rax

mov PVAR(1), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=cons, minor=1) with Box(VarParam(cons, 1))

;; Finished: Item 1 in Seq statement #40


;; Starting: Item 2 in Seq statement #40
;; Starting: Set VarParam(name=car, minor=2) with Box(VarParam(car, 2))
;; Starting: Evaluating rhs for [ Set VarParam(name=car, minor=2) with Box(VarParam(car, 2)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(car, 2)
;; Starting: Get VarParam(name=car, minor=2)
mov rax, PVAR(2)
;; Finished: Get VarParam(name=car, minor=2)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(car, 2)

;; Finished: Evaluating rhs for [ Set VarParam(name=car, minor=2) with Box(VarParam(car, 2)) ], value is expected in rax

mov PVAR(2), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=car, minor=2) with Box(VarParam(car, 2))

;; Finished: Item 2 in Seq statement #40


;; Starting: Item 3 in Seq statement #40
;; Starting: Set VarParam(name=cdr, minor=3) with Box(VarParam(cdr, 3))
;; Starting: Evaluating rhs for [ Set VarParam(name=cdr, minor=3) with Box(VarParam(cdr, 3)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(cdr, 3)
;; Starting: Get VarParam(name=cdr, minor=3)
mov rax, PVAR(3)
;; Finished: Get VarParam(name=cdr, minor=3)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(cdr, 3)

;; Finished: Evaluating rhs for [ Set VarParam(name=cdr, minor=3) with Box(VarParam(cdr, 3)) ], value is expected in rax

mov PVAR(3), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=cdr, minor=3) with Box(VarParam(cdr, 3))

;; Finished: Item 3 in Seq statement #40


;; Starting: Item 4 in Seq statement #40

;; Finished: Item 4 in Seq statement #40

;; Finished: Seq statement #40: (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(cons, 1) Box(VarParam(cons, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  (lambda p (begin (set! VarParam(p, 0) Box(VarParam(p, 0)))  ((lambda (cons-list) (begin (set! VarParam(cons-list, 0) Box(VarParam(cons-list, 0)))  BoxSet(VarParam(cons-list, 0), (lambda (p) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0)) (BoxGet(VarBound(cons, 2, 1)) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))  (BoxGet(VarBound(cons-list, 0, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0)))))))  (BoxGet(VarParam(cons-list, 0)) BoxGet(VarBound(p, 0, 0))))) whatever))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont39:

;; Finished: Creating CLOSURE of LambdaSimple#39 -> (lambda (null? cons car cdr) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(cons, 1) Box(VarParam(cons, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  (lambda p (begin (set! VarParam(p, 0) Box(VarParam(p, 0)))  ((lambda (cons-list) (begin (set! VarParam(cons-list, 0) Box(VarParam(cons-list, 0)))  BoxSet(VarParam(cons-list, 0), (lambda (p) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0)) (BoxGet(VarBound(cons, 2, 1)) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))  (BoxGet(VarBound(cons-list, 0, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0)))))))  (BoxGet(VarParam(cons-list, 0)) BoxGet(VarBound(p, 0, 0))))) whatever)))))

;; Finished: Evaluating proc to apply (in Applic #38)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic38
; int3
ContinueApplic38:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #38
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#38 of: ((lambda (null? cons car cdr) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(cons, 1) Box(VarParam(cons, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  (lambda p (begin (set! VarParam(p, 0) Box(VarParam(p, 0)))  ((lambda (cons-list) (begin (set! VarParam(cons-list, 0) Box(VarParam(cons-list, 0)))  BoxSet(VarParam(cons-list, 0), (lambda (p) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0)) (BoxGet(VarBound(cons, 2, 1)) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))  (BoxGet(VarBound(cons-list, 0, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0)))))))  (BoxGet(VarParam(cons-list, 0)) BoxGet(VarBound(p, 0, 0))))) whatever))))) VarFree(null?)  VarFree(cons)  VarFree(car)  VarFree(cdr))

mov qword [fvar_tbl+8*9], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar cons* to ((lambda (null? cons car cdr) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(cons, 1) Box(VarParam(cons, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  (lambda p (begin (set! VarParam(p, 0) Box(VarParam(p, 0)))  ((lambda (cons-list) (begin (set! VarParam(cons-list, 0) Box(VarParam(cons-list, 0)))  BoxSet(VarParam(cons-list, 0), (lambda (p) (if (BoxGet(VarBound(null?, 2, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0))) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0)) (BoxGet(VarBound(cons, 2, 1)) (BoxGet(VarBound(car, 2, 2)) VarParam(p, 0))  (BoxGet(VarBound(cons-list, 0, 0)) (BoxGet(VarBound(cdr, 2, 3)) VarParam(p, 0)))))))  (BoxGet(VarParam(cons-list, 0)) BoxGet(VarBound(p, 0, 0))))) whatever))))) VarFree(null?)  VarFree(cons)  VarFree(car)  VarFree(cdr))

	call write_sob_if_not_void

;; Starting: Set fvar append to ((lambda (null? fold-right cons) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(fold-right, 1) Box(VarParam(fold-right, 1)))  (set! VarParam(cons, 2) Box(VarParam(cons, 2)))  (lambda args (begin (set! VarParam(args, 0) Box(VarParam(args, 0)))  (BoxGet(VarBound(fold-right, 0, 1)) (lambda (e a) (begin (set! VarParam(e, 0) Box(VarParam(e, 0)))  (set! VarParam(a, 1) Box(VarParam(a, 1)))  (if (BoxGet(VarBound(null?, 1, 0)) BoxGet(VarParam(a, 1))) BoxGet(VarParam(e, 0)) (BoxGet(VarBound(fold-right, 1, 1)) BoxGet(VarBound(cons, 1, 2))  BoxGet(VarParam(a, 1))  BoxGet(VarParam(e, 0))))))  ()  BoxGet(VarParam(args, 0))))))) VarFree(null?)  VarFree(fold-right)  VarFree(cons))
;; Starting: Perform Applic#41 of: ((lambda (null? fold-right cons) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(fold-right, 1) Box(VarParam(fold-right, 1)))  (set! VarParam(cons, 2) Box(VarParam(cons, 2)))  (lambda args (begin (set! VarParam(args, 0) Box(VarParam(args, 0)))  (BoxGet(VarBound(fold-right, 0, 1)) (lambda (e a) (begin (set! VarParam(e, 0) Box(VarParam(e, 0)))  (set! VarParam(a, 1) Box(VarParam(a, 1)))  (if (BoxGet(VarBound(null?, 1, 0)) BoxGet(VarParam(a, 1))) BoxGet(VarParam(e, 0)) (BoxGet(VarBound(fold-right, 1, 1)) BoxGet(VarBound(cons, 1, 2))  BoxGet(VarParam(a, 1))  BoxGet(VarParam(e, 0))))))  ()  BoxGet(VarParam(args, 0))))))) VarFree(null?)  VarFree(fold-right)  VarFree(cons))
;; Starting: Argument 2 of Applic statement #41
mov rax, qword [fvar_tbl+8*4]	; mov fvar cons to rax
;; Finished: Argument 2 of Applic statement #41

push rax ; Push argument to stack;; Starting: Argument 1 of Applic statement #41
mov rax, qword [fvar_tbl+8*7]	; mov fvar fold-right to rax
;; Finished: Argument 1 of Applic statement #41

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #41
mov rax, qword [fvar_tbl+8*1]	; mov fvar null? to rax
;; Finished: Argument 0 of Applic statement #41

push rax ; Push argument to stack
push qword 3 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #41)
;; Starting: Creating CLOSURE of LambdaSimple#42 -> (lambda (null? fold-right cons) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(fold-right, 1) Box(VarParam(fold-right, 1)))  (set! VarParam(cons, 2) Box(VarParam(cons, 2)))  (lambda args (begin (set! VarParam(args, 0) Box(VarParam(args, 0)))  (BoxGet(VarBound(fold-right, 0, 1)) (lambda (e a) (begin (set! VarParam(e, 0) Box(VarParam(e, 0)))  (set! VarParam(a, 1) Box(VarParam(a, 1)))  (if (BoxGet(VarBound(null?, 1, 0)) BoxGet(VarParam(a, 1))) BoxGet(VarParam(e, 0)) (BoxGet(VarBound(fold-right, 1, 1)) BoxGet(VarBound(cons, 1, 2))  BoxGet(VarParam(a, 1))  BoxGet(VarParam(e, 0))))))  ()  BoxGet(VarParam(args, 0)))))))
push rbx
; Env Extend Code Section For Closure#42
mov rbx, 0 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend42
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End42

LClosureEnvExtend42:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, -1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 0
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop42:
  jz LClosureEnvExtend_LoopEnd42
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop42

LClosureEnvExtend_LoopEnd42:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd42
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop42:
  jz LClosureEnvExtend_ParamsLoopEnd42

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop42

LClosureEnvExtend_ParamsLoopEnd42:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End42:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode42)
pop rbx
jmp LClosureCont42
LClosureCode42:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #43: (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(fold-right, 1) Box(VarParam(fold-right, 1)))  (set! VarParam(cons, 2) Box(VarParam(cons, 2)))  (lambda args (begin (set! VarParam(args, 0) Box(VarParam(args, 0)))  (BoxGet(VarBound(fold-right, 0, 1)) (lambda (e a) (begin (set! VarParam(e, 0) Box(VarParam(e, 0)))  (set! VarParam(a, 1) Box(VarParam(a, 1)))  (if (BoxGet(VarBound(null?, 1, 0)) BoxGet(VarParam(a, 1))) BoxGet(VarParam(e, 0)) (BoxGet(VarBound(fold-right, 1, 1)) BoxGet(VarBound(cons, 1, 2))  BoxGet(VarParam(a, 1))  BoxGet(VarParam(e, 0))))))  ()  BoxGet(VarParam(args, 0))))))
;; Starting: Item 0 in Seq statement #43
;; Starting: Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(null?, 0)
;; Starting: Get VarParam(name=null?, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=null?, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(null?, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0))

;; Finished: Item 0 in Seq statement #43


;; Starting: Item 1 in Seq statement #43
;; Starting: Set VarParam(name=fold-right, minor=1) with Box(VarParam(fold-right, 1))
;; Starting: Evaluating rhs for [ Set VarParam(name=fold-right, minor=1) with Box(VarParam(fold-right, 1)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(fold-right, 1)
;; Starting: Get VarParam(name=fold-right, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=fold-right, minor=1)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(fold-right, 1)

;; Finished: Evaluating rhs for [ Set VarParam(name=fold-right, minor=1) with Box(VarParam(fold-right, 1)) ], value is expected in rax

mov PVAR(1), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=fold-right, minor=1) with Box(VarParam(fold-right, 1))

;; Finished: Item 1 in Seq statement #43


;; Starting: Item 2 in Seq statement #43
;; Starting: Set VarParam(name=cons, minor=2) with Box(VarParam(cons, 2))
;; Starting: Evaluating rhs for [ Set VarParam(name=cons, minor=2) with Box(VarParam(cons, 2)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(cons, 2)
;; Starting: Get VarParam(name=cons, minor=2)
mov rax, PVAR(2)
;; Finished: Get VarParam(name=cons, minor=2)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(cons, 2)

;; Finished: Evaluating rhs for [ Set VarParam(name=cons, minor=2) with Box(VarParam(cons, 2)) ], value is expected in rax

mov PVAR(2), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=cons, minor=2) with Box(VarParam(cons, 2))

;; Finished: Item 2 in Seq statement #43


;; Starting: Item 3 in Seq statement #43

;; Finished: Item 3 in Seq statement #43

;; Finished: Seq statement #43: (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(fold-right, 1) Box(VarParam(fold-right, 1)))  (set! VarParam(cons, 2) Box(VarParam(cons, 2)))  (lambda args (begin (set! VarParam(args, 0) Box(VarParam(args, 0)))  (BoxGet(VarBound(fold-right, 0, 1)) (lambda (e a) (begin (set! VarParam(e, 0) Box(VarParam(e, 0)))  (set! VarParam(a, 1) Box(VarParam(a, 1)))  (if (BoxGet(VarBound(null?, 1, 0)) BoxGet(VarParam(a, 1))) BoxGet(VarParam(e, 0)) (BoxGet(VarBound(fold-right, 1, 1)) BoxGet(VarBound(cons, 1, 2))  BoxGet(VarParam(a, 1))  BoxGet(VarParam(e, 0))))))  ()  BoxGet(VarParam(args, 0))))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont42:

;; Finished: Creating CLOSURE of LambdaSimple#42 -> (lambda (null? fold-right cons) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(fold-right, 1) Box(VarParam(fold-right, 1)))  (set! VarParam(cons, 2) Box(VarParam(cons, 2)))  (lambda args (begin (set! VarParam(args, 0) Box(VarParam(args, 0)))  (BoxGet(VarBound(fold-right, 0, 1)) (lambda (e a) (begin (set! VarParam(e, 0) Box(VarParam(e, 0)))  (set! VarParam(a, 1) Box(VarParam(a, 1)))  (if (BoxGet(VarBound(null?, 1, 0)) BoxGet(VarParam(a, 1))) BoxGet(VarParam(e, 0)) (BoxGet(VarBound(fold-right, 1, 1)) BoxGet(VarBound(cons, 1, 2))  BoxGet(VarParam(a, 1))  BoxGet(VarParam(e, 0))))))  ()  BoxGet(VarParam(args, 0)))))))

;; Finished: Evaluating proc to apply (in Applic #41)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic41
; int3
ContinueApplic41:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #41
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#41 of: ((lambda (null? fold-right cons) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(fold-right, 1) Box(VarParam(fold-right, 1)))  (set! VarParam(cons, 2) Box(VarParam(cons, 2)))  (lambda args (begin (set! VarParam(args, 0) Box(VarParam(args, 0)))  (BoxGet(VarBound(fold-right, 0, 1)) (lambda (e a) (begin (set! VarParam(e, 0) Box(VarParam(e, 0)))  (set! VarParam(a, 1) Box(VarParam(a, 1)))  (if (BoxGet(VarBound(null?, 1, 0)) BoxGet(VarParam(a, 1))) BoxGet(VarParam(e, 0)) (BoxGet(VarBound(fold-right, 1, 1)) BoxGet(VarBound(cons, 1, 2))  BoxGet(VarParam(a, 1))  BoxGet(VarParam(e, 0))))))  ()  BoxGet(VarParam(args, 0))))))) VarFree(null?)  VarFree(fold-right)  VarFree(cons))

mov qword [fvar_tbl+8*8], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar append to ((lambda (null? fold-right cons) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(fold-right, 1) Box(VarParam(fold-right, 1)))  (set! VarParam(cons, 2) Box(VarParam(cons, 2)))  (lambda args (begin (set! VarParam(args, 0) Box(VarParam(args, 0)))  (BoxGet(VarBound(fold-right, 0, 1)) (lambda (e a) (begin (set! VarParam(e, 0) Box(VarParam(e, 0)))  (set! VarParam(a, 1) Box(VarParam(a, 1)))  (if (BoxGet(VarBound(null?, 1, 0)) BoxGet(VarParam(a, 1))) BoxGet(VarParam(e, 0)) (BoxGet(VarBound(fold-right, 1, 1)) BoxGet(VarBound(cons, 1, 2))  BoxGet(VarParam(a, 1))  BoxGet(VarParam(e, 0))))))  ()  BoxGet(VarParam(args, 0))))))) VarFree(null?)  VarFree(fold-right)  VarFree(cons))

	call write_sob_if_not_void

;; Starting: Set fvar list to (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  BoxGet(VarParam(x, 0))))

mov qword [fvar_tbl+8*10], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar list to (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  BoxGet(VarParam(x, 0))))

	call write_sob_if_not_void

;; Starting: Set fvar list? to ((lambda (null? pair? cdr) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(pair?, 1) Box(VarParam(pair?, 1)))  (set! VarParam(cdr, 2) Box(VarParam(cdr, 2)))  ((lambda (list?-loop) (begin (set! VarParam(list?-loop, 0) Box(VarParam(list?-loop, 0)))  BoxSet(VarParam(list?-loop, 0), (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f))))  BoxGet(VarParam(list?-loop, 0)))) whatever))) VarFree(null?)  VarFree(pair?)  VarFree(cdr))
;; Starting: Perform Applic#44 of: ((lambda (null? pair? cdr) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(pair?, 1) Box(VarParam(pair?, 1)))  (set! VarParam(cdr, 2) Box(VarParam(cdr, 2)))  ((lambda (list?-loop) (begin (set! VarParam(list?-loop, 0) Box(VarParam(list?-loop, 0)))  BoxSet(VarParam(list?-loop, 0), (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f))))  BoxGet(VarParam(list?-loop, 0)))) whatever))) VarFree(null?)  VarFree(pair?)  VarFree(cdr))
;; Starting: Argument 2 of Applic statement #44
mov rax, qword [fvar_tbl+8*3]	; mov fvar cdr to rax
;; Finished: Argument 2 of Applic statement #44

push rax ; Push argument to stack;; Starting: Argument 1 of Applic statement #44
mov rax, qword [fvar_tbl+8*12]	; mov fvar pair? to rax
;; Finished: Argument 1 of Applic statement #44

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #44
mov rax, qword [fvar_tbl+8*1]	; mov fvar null? to rax
;; Finished: Argument 0 of Applic statement #44

push rax ; Push argument to stack
push qword 3 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #44)
;; Starting: Creating CLOSURE of LambdaSimple#45 -> (lambda (null? pair? cdr) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(pair?, 1) Box(VarParam(pair?, 1)))  (set! VarParam(cdr, 2) Box(VarParam(cdr, 2)))  ((lambda (list?-loop) (begin (set! VarParam(list?-loop, 0) Box(VarParam(list?-loop, 0)))  BoxSet(VarParam(list?-loop, 0), (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f))))  BoxGet(VarParam(list?-loop, 0)))) whatever)))
push rbx
; Env Extend Code Section For Closure#45
mov rbx, 0 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend45
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End45

LClosureEnvExtend45:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, -1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 0
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop45:
  jz LClosureEnvExtend_LoopEnd45
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop45

LClosureEnvExtend_LoopEnd45:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd45
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop45:
  jz LClosureEnvExtend_ParamsLoopEnd45

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop45

LClosureEnvExtend_ParamsLoopEnd45:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End45:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode45)
pop rbx
jmp LClosureCont45
LClosureCode45:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #46: (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(pair?, 1) Box(VarParam(pair?, 1)))  (set! VarParam(cdr, 2) Box(VarParam(cdr, 2)))  ((lambda (list?-loop) (begin (set! VarParam(list?-loop, 0) Box(VarParam(list?-loop, 0)))  BoxSet(VarParam(list?-loop, 0), (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f))))  BoxGet(VarParam(list?-loop, 0)))) whatever))
;; Starting: Item 0 in Seq statement #46
;; Starting: Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(null?, 0)
;; Starting: Get VarParam(name=null?, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=null?, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(null?, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0))

;; Finished: Item 0 in Seq statement #46


;; Starting: Item 1 in Seq statement #46
;; Starting: Set VarParam(name=pair?, minor=1) with Box(VarParam(pair?, 1))
;; Starting: Evaluating rhs for [ Set VarParam(name=pair?, minor=1) with Box(VarParam(pair?, 1)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(pair?, 1)
;; Starting: Get VarParam(name=pair?, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=pair?, minor=1)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(pair?, 1)

;; Finished: Evaluating rhs for [ Set VarParam(name=pair?, minor=1) with Box(VarParam(pair?, 1)) ], value is expected in rax

mov PVAR(1), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=pair?, minor=1) with Box(VarParam(pair?, 1))

;; Finished: Item 1 in Seq statement #46


;; Starting: Item 2 in Seq statement #46
;; Starting: Set VarParam(name=cdr, minor=2) with Box(VarParam(cdr, 2))
;; Starting: Evaluating rhs for [ Set VarParam(name=cdr, minor=2) with Box(VarParam(cdr, 2)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(cdr, 2)
;; Starting: Get VarParam(name=cdr, minor=2)
mov rax, PVAR(2)
;; Finished: Get VarParam(name=cdr, minor=2)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(cdr, 2)

;; Finished: Evaluating rhs for [ Set VarParam(name=cdr, minor=2) with Box(VarParam(cdr, 2)) ], value is expected in rax

mov PVAR(2), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=cdr, minor=2) with Box(VarParam(cdr, 2))

;; Finished: Item 2 in Seq statement #46


;; Starting: Item 3 in Seq statement #46
;; Starting: Perform Applic#47 of: ((lambda (list?-loop) (begin (set! VarParam(list?-loop, 0) Box(VarParam(list?-loop, 0)))  BoxSet(VarParam(list?-loop, 0), (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f))))  BoxGet(VarParam(list?-loop, 0)))) whatever)
;; Starting: Argument 0 of Applic statement #47
mov rax, const_tbl+23	; mov const whatever to rax
;; Finished: Argument 0 of Applic statement #47

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #47)
;; Starting: Creating CLOSURE of LambdaSimple#48 -> (lambda (list?-loop) (begin (set! VarParam(list?-loop, 0) Box(VarParam(list?-loop, 0)))  BoxSet(VarParam(list?-loop, 0), (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f))))  BoxGet(VarParam(list?-loop, 0))))
push rbx
; Env Extend Code Section For Closure#48
mov rbx, 1 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend48
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End48

LClosureEnvExtend48:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 0
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 8
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop48:
  jz LClosureEnvExtend_LoopEnd48
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop48

LClosureEnvExtend_LoopEnd48:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd48
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop48:
  jz LClosureEnvExtend_ParamsLoopEnd48

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop48

LClosureEnvExtend_ParamsLoopEnd48:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End48:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode48)
pop rbx
jmp LClosureCont48
LClosureCode48:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #49: (begin (set! VarParam(list?-loop, 0) Box(VarParam(list?-loop, 0)))  BoxSet(VarParam(list?-loop, 0), (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f))))  BoxGet(VarParam(list?-loop, 0)))
;; Starting: Item 0 in Seq statement #49
;; Starting: Set VarParam(name=list?-loop, minor=0) with Box(VarParam(list?-loop, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=list?-loop, minor=0) with Box(VarParam(list?-loop, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(list?-loop, 0)
;; Starting: Get VarParam(name=list?-loop, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=list?-loop, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(list?-loop, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=list?-loop, minor=0) with Box(VarParam(list?-loop, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=list?-loop, minor=0) with Box(VarParam(list?-loop, 0))

;; Finished: Item 0 in Seq statement #49


;; Starting: Item 1 in Seq statement #49
;; Starting: BoxSet of VarParam(list?-loop, 0) with (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f)))
;; Starting: Evaluating rhs for [ BoxSet of VarParam(list?-loop, 0) with (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f))) ], the VALUE is expected in rax
;; Starting: Creating CLOSURE of LambdaSimple#50 -> (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f)))
push rbx
; Env Extend Code Section For Closure#50
mov rbx, 2 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend50
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End50

LClosureEnvExtend50:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 16
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop50:
  jz LClosureEnvExtend_LoopEnd50
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop50

LClosureEnvExtend_LoopEnd50:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd50
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop50:
  jz LClosureEnvExtend_ParamsLoopEnd50

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop50

LClosureEnvExtend_ParamsLoopEnd50:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End50:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode50)
pop rbx
jmp LClosureCont50
LClosureCode50:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Or statement (#51): (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f))
Lor51: 
;; Starting: Item 0 in Or statement #51
;; Starting: Perform Applic#52 of: (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))
;; Starting: Argument 0 of Applic statement #52
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Argument 0 of Applic statement #52

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #52)
;; Starting: BoxGet of VarBound(null?, 1, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(null?, 1, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=null?, major=1, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=null?, major=1, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(null?, 1, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(null?, 1, 0)

;; Finished: Evaluating proc to apply (in Applic #52)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic52
; int3
ContinueApplic52:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #52
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#52 of: (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))

;; Finished: Item 0 in Or statement #51
cmp rax, SOB_FALSE_ADDRESS 
jne LendOr51;; Starting: Item 1 in Or statement #51
;; Starting: If statement (#53): (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f)
Lif53:
;; Starting: Perform Applic#54 of: (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0))
;; Starting: Argument 0 of Applic statement #54
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Argument 0 of Applic statement #54

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #54)
;; Starting: BoxGet of VarBound(pair?, 1, 1)
;; Starting: Evaluating val for [ BoxGet of VarBound(pair?, 1, 1) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=pair?, major=1, minor=1)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
;; Finished: Get VarBound(name=pair?, major=1, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarBound(pair?, 1, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(pair?, 1, 1)

;; Finished: Evaluating proc to apply (in Applic #54)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic54
; int3
ContinueApplic54:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #54
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#54 of: (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0))

cmp rax, SOB_FALSE_ADDRESS
je Lelse53
;; Starting: Perform Applic#55 of: (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0)))
;; Starting: Argument 0 of Applic statement #55
;; Starting: Perform Applic#56 of: (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))
;; Starting: Argument 0 of Applic statement #56
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Argument 0 of Applic statement #56

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #56)
;; Starting: BoxGet of VarBound(cdr, 1, 2)
;; Starting: Evaluating val for [ BoxGet of VarBound(cdr, 1, 2) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=cdr, major=1, minor=2)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]
;; Finished: Get VarBound(name=cdr, major=1, minor=2)

;; Finished: Evaluating val for [ BoxGet of VarBound(cdr, 1, 2) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(cdr, 1, 2)

;; Finished: Evaluating proc to apply (in Applic #56)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic56
; int3
ContinueApplic56:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #56
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#56 of: (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))

;; Finished: Argument 0 of Applic statement #55

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #55)
mov rax, qword [fvar_tbl+8*11]	; mov fvar list? to rax
;; Finished: Evaluating proc to apply (in Applic #55)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic55
; int3
ContinueApplic55:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #55
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#55 of: (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0)))

jmp LendIf53
Lelse53:
mov rax, const_tbl+2	; mov const #f to rax
LendIf53:
;; Finished: If statement (#53): (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f)

;; Finished: Item 1 in Or statement #51
 
LendOr51:
;; Finished: Or statement (#51): (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont50:

;; Finished: Creating CLOSURE of LambdaSimple#50 -> (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f)))

;; Finished: Evaluating rhs for [ BoxSet of VarParam(list?-loop, 0) with (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f))) ], the VALUE is expected in rax

; Save the value of rhs
push rax
;; Starting: Evaluating var for [ BoxSet of VarParam(list?-loop, 0) with (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f))) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=list?-loop, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=list?-loop, minor=0)

;; Finished: Evaluating var for [ BoxSet of VarParam(list?-loop, 0) with (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f))) ], the VALUE is expected in rax

; in RAX there is a address of a box, put the value we saved on stack earlier (from rhs) inside it
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;; Finished: BoxSet of VarParam(list?-loop, 0) with (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f)))

;; Finished: Item 1 in Seq statement #49


;; Starting: Item 2 in Seq statement #49
;; Starting: BoxGet of VarParam(list?-loop, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(list?-loop, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=list?-loop, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=list?-loop, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(list?-loop, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(list?-loop, 0)

;; Finished: Item 2 in Seq statement #49

;; Finished: Seq statement #49: (begin (set! VarParam(list?-loop, 0) Box(VarParam(list?-loop, 0)))  BoxSet(VarParam(list?-loop, 0), (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f))))  BoxGet(VarParam(list?-loop, 0)))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont48:

;; Finished: Creating CLOSURE of LambdaSimple#48 -> (lambda (list?-loop) (begin (set! VarParam(list?-loop, 0) Box(VarParam(list?-loop, 0)))  BoxSet(VarParam(list?-loop, 0), (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f))))  BoxGet(VarParam(list?-loop, 0))))

;; Finished: Evaluating proc to apply (in Applic #47)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic47
; int3
ContinueApplic47:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #47
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#47 of: ((lambda (list?-loop) (begin (set! VarParam(list?-loop, 0) Box(VarParam(list?-loop, 0)))  BoxSet(VarParam(list?-loop, 0), (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f))))  BoxGet(VarParam(list?-loop, 0)))) whatever)

;; Finished: Item 3 in Seq statement #46

;; Finished: Seq statement #46: (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(pair?, 1) Box(VarParam(pair?, 1)))  (set! VarParam(cdr, 2) Box(VarParam(cdr, 2)))  ((lambda (list?-loop) (begin (set! VarParam(list?-loop, 0) Box(VarParam(list?-loop, 0)))  BoxSet(VarParam(list?-loop, 0), (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f))))  BoxGet(VarParam(list?-loop, 0)))) whatever))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont45:

;; Finished: Creating CLOSURE of LambdaSimple#45 -> (lambda (null? pair? cdr) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(pair?, 1) Box(VarParam(pair?, 1)))  (set! VarParam(cdr, 2) Box(VarParam(cdr, 2)))  ((lambda (list?-loop) (begin (set! VarParam(list?-loop, 0) Box(VarParam(list?-loop, 0)))  BoxSet(VarParam(list?-loop, 0), (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f))))  BoxGet(VarParam(list?-loop, 0)))) whatever)))

;; Finished: Evaluating proc to apply (in Applic #44)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic44
; int3
ContinueApplic44:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #44
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#44 of: ((lambda (null? pair? cdr) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(pair?, 1) Box(VarParam(pair?, 1)))  (set! VarParam(cdr, 2) Box(VarParam(cdr, 2)))  ((lambda (list?-loop) (begin (set! VarParam(list?-loop, 0) Box(VarParam(list?-loop, 0)))  BoxSet(VarParam(list?-loop, 0), (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f))))  BoxGet(VarParam(list?-loop, 0)))) whatever))) VarFree(null?)  VarFree(pair?)  VarFree(cdr))

mov qword [fvar_tbl+8*11], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar list? to ((lambda (null? pair? cdr) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(pair?, 1) Box(VarParam(pair?, 1)))  (set! VarParam(cdr, 2) Box(VarParam(cdr, 2)))  ((lambda (list?-loop) (begin (set! VarParam(list?-loop, 0) Box(VarParam(list?-loop, 0)))  BoxSet(VarParam(list?-loop, 0), (lambda (x) (or (BoxGet(VarBound(null?, 1, 0)) VarParam(x, 0))  (if (BoxGet(VarBound(pair?, 1, 1)) VarParam(x, 0)) (VarFree(list?) (BoxGet(VarBound(cdr, 1, 2)) VarParam(x, 0))) #f))))  BoxGet(VarParam(list?-loop, 0)))) whatever))) VarFree(null?)  VarFree(pair?)  VarFree(cdr))

	call write_sob_if_not_void

;; Starting: Set fvar make-string to ((lambda (null? car make-string) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(car, 1) Box(VarParam(car, 1)))  (set! VarParam(make-string, 2) Box(VarParam(make-string, 2)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 0, 0)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(make-string, 0, 2)) BoxGet(VarParam(x, 0))  #\nul) (BoxGet(VarBound(make-string, 0, 2)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(car, 0, 1)) BoxGet(VarParam(y, 1))))))))) VarFree(null?)  VarFree(car)  VarFree(make-string))
;; Starting: Perform Applic#57 of: ((lambda (null? car make-string) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(car, 1) Box(VarParam(car, 1)))  (set! VarParam(make-string, 2) Box(VarParam(make-string, 2)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 0, 0)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(make-string, 0, 2)) BoxGet(VarParam(x, 0))  #\nul) (BoxGet(VarBound(make-string, 0, 2)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(car, 0, 1)) BoxGet(VarParam(y, 1))))))))) VarFree(null?)  VarFree(car)  VarFree(make-string))
;; Starting: Argument 2 of Applic statement #57
mov rax, qword [fvar_tbl+8*13]	; mov fvar make-string to rax
;; Finished: Argument 2 of Applic statement #57

push rax ; Push argument to stack;; Starting: Argument 1 of Applic statement #57
mov rax, qword [fvar_tbl+8*2]	; mov fvar car to rax
;; Finished: Argument 1 of Applic statement #57

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #57
mov rax, qword [fvar_tbl+8*1]	; mov fvar null? to rax
;; Finished: Argument 0 of Applic statement #57

push rax ; Push argument to stack
push qword 3 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #57)
;; Starting: Creating CLOSURE of LambdaSimple#58 -> (lambda (null? car make-string) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(car, 1) Box(VarParam(car, 1)))  (set! VarParam(make-string, 2) Box(VarParam(make-string, 2)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 0, 0)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(make-string, 0, 2)) BoxGet(VarParam(x, 0))  #\nul) (BoxGet(VarBound(make-string, 0, 2)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(car, 0, 1)) BoxGet(VarParam(y, 1)))))))))
push rbx
; Env Extend Code Section For Closure#58
mov rbx, 0 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend58
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End58

LClosureEnvExtend58:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, -1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 0
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop58:
  jz LClosureEnvExtend_LoopEnd58
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop58

LClosureEnvExtend_LoopEnd58:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd58
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop58:
  jz LClosureEnvExtend_ParamsLoopEnd58

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop58

LClosureEnvExtend_ParamsLoopEnd58:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End58:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode58)
pop rbx
jmp LClosureCont58
LClosureCode58:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #59: (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(car, 1) Box(VarParam(car, 1)))  (set! VarParam(make-string, 2) Box(VarParam(make-string, 2)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 0, 0)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(make-string, 0, 2)) BoxGet(VarParam(x, 0))  #\nul) (BoxGet(VarBound(make-string, 0, 2)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(car, 0, 1)) BoxGet(VarParam(y, 1))))))))
;; Starting: Item 0 in Seq statement #59
;; Starting: Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(null?, 0)
;; Starting: Get VarParam(name=null?, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=null?, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(null?, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0))

;; Finished: Item 0 in Seq statement #59


;; Starting: Item 1 in Seq statement #59
;; Starting: Set VarParam(name=car, minor=1) with Box(VarParam(car, 1))
;; Starting: Evaluating rhs for [ Set VarParam(name=car, minor=1) with Box(VarParam(car, 1)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(car, 1)
;; Starting: Get VarParam(name=car, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=car, minor=1)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(car, 1)

;; Finished: Evaluating rhs for [ Set VarParam(name=car, minor=1) with Box(VarParam(car, 1)) ], value is expected in rax

mov PVAR(1), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=car, minor=1) with Box(VarParam(car, 1))

;; Finished: Item 1 in Seq statement #59


;; Starting: Item 2 in Seq statement #59
;; Starting: Set VarParam(name=make-string, minor=2) with Box(VarParam(make-string, 2))
;; Starting: Evaluating rhs for [ Set VarParam(name=make-string, minor=2) with Box(VarParam(make-string, 2)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(make-string, 2)
;; Starting: Get VarParam(name=make-string, minor=2)
mov rax, PVAR(2)
;; Finished: Get VarParam(name=make-string, minor=2)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(make-string, 2)

;; Finished: Evaluating rhs for [ Set VarParam(name=make-string, minor=2) with Box(VarParam(make-string, 2)) ], value is expected in rax

mov PVAR(2), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=make-string, minor=2) with Box(VarParam(make-string, 2))

;; Finished: Item 2 in Seq statement #59


;; Starting: Item 3 in Seq statement #59

;; Finished: Item 3 in Seq statement #59

;; Finished: Seq statement #59: (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(car, 1) Box(VarParam(car, 1)))  (set! VarParam(make-string, 2) Box(VarParam(make-string, 2)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 0, 0)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(make-string, 0, 2)) BoxGet(VarParam(x, 0))  #\nul) (BoxGet(VarBound(make-string, 0, 2)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(car, 0, 1)) BoxGet(VarParam(y, 1))))))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont58:

;; Finished: Creating CLOSURE of LambdaSimple#58 -> (lambda (null? car make-string) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(car, 1) Box(VarParam(car, 1)))  (set! VarParam(make-string, 2) Box(VarParam(make-string, 2)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 0, 0)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(make-string, 0, 2)) BoxGet(VarParam(x, 0))  #\nul) (BoxGet(VarBound(make-string, 0, 2)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(car, 0, 1)) BoxGet(VarParam(y, 1)))))))))

;; Finished: Evaluating proc to apply (in Applic #57)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic57
; int3
ContinueApplic57:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #57
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#57 of: ((lambda (null? car make-string) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(car, 1) Box(VarParam(car, 1)))  (set! VarParam(make-string, 2) Box(VarParam(make-string, 2)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 0, 0)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(make-string, 0, 2)) BoxGet(VarParam(x, 0))  #\nul) (BoxGet(VarBound(make-string, 0, 2)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(car, 0, 1)) BoxGet(VarParam(y, 1))))))))) VarFree(null?)  VarFree(car)  VarFree(make-string))

mov qword [fvar_tbl+8*13], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar make-string to ((lambda (null? car make-string) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(car, 1) Box(VarParam(car, 1)))  (set! VarParam(make-string, 2) Box(VarParam(make-string, 2)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 0, 0)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(make-string, 0, 2)) BoxGet(VarParam(x, 0))  #\nul) (BoxGet(VarBound(make-string, 0, 2)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(car, 0, 1)) BoxGet(VarParam(y, 1))))))))) VarFree(null?)  VarFree(car)  VarFree(make-string))

	call write_sob_if_not_void

;; Starting: Set fvar not to (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if BoxGet(VarParam(x, 0)) #f #t)))
;; Starting: Creating CLOSURE of LambdaSimple#60 -> (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if BoxGet(VarParam(x, 0)) #f #t)))
push rbx
; Env Extend Code Section For Closure#60
mov rbx, 0 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend60
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End60

LClosureEnvExtend60:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, -1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 0
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop60:
  jz LClosureEnvExtend_LoopEnd60
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop60

LClosureEnvExtend_LoopEnd60:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd60
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop60:
  jz LClosureEnvExtend_ParamsLoopEnd60

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop60

LClosureEnvExtend_ParamsLoopEnd60:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End60:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode60)
pop rbx
jmp LClosureCont60
LClosureCode60:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #61: (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if BoxGet(VarParam(x, 0)) #f #t))
;; Starting: Item 0 in Seq statement #61
;; Starting: Set VarParam(name=x, minor=0) with Box(VarParam(x, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=x, minor=0) with Box(VarParam(x, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(x, 0)
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(x, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=x, minor=0) with Box(VarParam(x, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=x, minor=0) with Box(VarParam(x, 0))

;; Finished: Item 0 in Seq statement #61


;; Starting: Item 1 in Seq statement #61
;; Starting: If statement (#62): (if BoxGet(VarParam(x, 0)) #f #t)
Lif62:
;; Starting: BoxGet of VarParam(x, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(x, 0)

cmp rax, SOB_FALSE_ADDRESS
je Lelse62
mov rax, const_tbl+2	; mov const #f to rax
jmp LendIf62
Lelse62:
mov rax, const_tbl+4	; mov const #t to rax
LendIf62:
;; Finished: If statement (#62): (if BoxGet(VarParam(x, 0)) #f #t)

;; Finished: Item 1 in Seq statement #61

;; Finished: Seq statement #61: (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if BoxGet(VarParam(x, 0)) #f #t))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont60:

;; Finished: Creating CLOSURE of LambdaSimple#60 -> (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if BoxGet(VarParam(x, 0)) #f #t)))

mov qword [fvar_tbl+8*14], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar not to (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if BoxGet(VarParam(x, 0)) #f #t)))

	call write_sob_if_not_void

;; Starting: Perform Applic#63 of: ((lambda (flonum? rational? exact->inexact fold-left map _+ _* _/ _= _< car cdr null?) (begin (set! VarParam(flonum?, 0) Box(VarParam(flonum?, 0)))  (set! VarParam(rational?, 1) Box(VarParam(rational?, 1)))  (set! VarParam(exact->inexact, 2) Box(VarParam(exact->inexact, 2)))  (set! VarParam(fold-left, 3) Box(VarParam(fold-left, 3)))  (set! VarParam(map, 4) Box(VarParam(map, 4)))  (set! VarParam(_+, 5) Box(VarParam(_+, 5)))  (set! VarParam(_*, 6) Box(VarParam(_*, 6)))  (set! VarParam(_/, 7) Box(VarParam(_/, 7)))  (set! VarParam(_=, 8) Box(VarParam(_=, 8)))  (set! VarParam(_<, 9) Box(VarParam(_<, 9)))  (set! VarParam(car, 10) Box(VarParam(car, 10)))  (set! VarParam(cdr, 11) Box(VarParam(cdr, 11)))  (set! VarParam(null?, 12) Box(VarParam(null?, 12)))  ((lambda (^numeric-op-dispatcher) (begin (set! VarParam(^numeric-op-dispatcher, 0) Box(VarParam(^numeric-op-dispatcher, 0)))  ((lambda (normalize) (begin (set! VarParam(normalize, 0) Box(VarParam(normalize, 0)))  (set! VarFree(+) (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(*) (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(/) ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7))))))) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) BoxGet(VarParam(x, 0)) ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0)))))))))  ((lambda (^comparator) (begin (set! VarParam(^comparator, 0) Box(VarParam(^comparator, 0)))  (set! VarFree(=) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8)))))  (set! VarFree(<) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 2, 3)) (lambda (a b) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(b, 1) Box(VarParam(b, 1)))  (if BoxGet(VarParam(a, 0)) BoxGet(VarParam(b, 1)) #f)))  #t  (BoxGet(VarBound(map, 2, 4)) (lambda (y) (begin (set! VarParam(y, 0) Box(VarParam(y, 0)))  (BoxGet(VarBound(op, 1, 0)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 0)))))  BoxGet(VarParam(ys, 1))))))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1)))) (if (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1))) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1)))))))))))) VarFree(flonum?)  VarFree(rational?)  VarFree(exact->inexact)  VarFree(fold-left)  VarFree(map)  VarFree(+)  VarFree(*)  VarFree(/)  VarFree(=)  VarFree(<)  VarFree(car)  VarFree(cdr)  VarFree(null?))
;; Starting: Argument 12 of Applic statement #63
mov rax, qword [fvar_tbl+8*1]	; mov fvar null? to rax
;; Finished: Argument 12 of Applic statement #63

push rax ; Push argument to stack;; Starting: Argument 11 of Applic statement #63
mov rax, qword [fvar_tbl+8*3]	; mov fvar cdr to rax
;; Finished: Argument 11 of Applic statement #63

push rax ; Push argument to stack;; Starting: Argument 10 of Applic statement #63
mov rax, qword [fvar_tbl+8*2]	; mov fvar car to rax
;; Finished: Argument 10 of Applic statement #63

push rax ; Push argument to stack;; Starting: Argument 9 of Applic statement #63
mov rax, qword [fvar_tbl+8*22]	; mov fvar < to rax
;; Finished: Argument 9 of Applic statement #63

push rax ; Push argument to stack;; Starting: Argument 8 of Applic statement #63
mov rax, qword [fvar_tbl+8*21]	; mov fvar = to rax
;; Finished: Argument 8 of Applic statement #63

push rax ; Push argument to stack;; Starting: Argument 7 of Applic statement #63
mov rax, qword [fvar_tbl+8*17]	; mov fvar / to rax
;; Finished: Argument 7 of Applic statement #63

push rax ; Push argument to stack;; Starting: Argument 6 of Applic statement #63
mov rax, qword [fvar_tbl+8*16]	; mov fvar * to rax
;; Finished: Argument 6 of Applic statement #63

push rax ; Push argument to stack;; Starting: Argument 5 of Applic statement #63
mov rax, qword [fvar_tbl+8*15]	; mov fvar + to rax
Debug1:
;; Finished: Argument 5 of Applic statement #63

push rax ; Push argument to stack;; Starting: Argument 4 of Applic statement #63
mov rax, qword [fvar_tbl+8*0]	; mov fvar map to rax
;; Finished: Argument 4 of Applic statement #63

push rax ; Push argument to stack;; Starting: Argument 3 of Applic statement #63
mov rax, qword [fvar_tbl+8*6]	; mov fvar fold-left to rax
;; Finished: Argument 3 of Applic statement #63

push rax ; Push argument to stack;; Starting: Argument 2 of Applic statement #63
mov rax, qword [fvar_tbl+8*25]	; mov fvar exact->inexact to rax
;; Finished: Argument 2 of Applic statement #63

push rax ; Push argument to stack;; Starting: Argument 1 of Applic statement #63
mov rax, qword [fvar_tbl+8*24]	; mov fvar rational? to rax
;; Finished: Argument 1 of Applic statement #63

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #63
mov rax, qword [fvar_tbl+8*23]	; mov fvar flonum? to rax
;; Finished: Argument 0 of Applic statement #63

push rax ; Push argument to stack
push qword 13 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #63)
;; Starting: Creating CLOSURE of LambdaSimple#64 -> (lambda (flonum? rational? exact->inexact fold-left map _+ _* _/ _= _< car cdr null?) (begin (set! VarParam(flonum?, 0) Box(VarParam(flonum?, 0)))  (set! VarParam(rational?, 1) Box(VarParam(rational?, 1)))  (set! VarParam(exact->inexact, 2) Box(VarParam(exact->inexact, 2)))  (set! VarParam(fold-left, 3) Box(VarParam(fold-left, 3)))  (set! VarParam(map, 4) Box(VarParam(map, 4)))  (set! VarParam(_+, 5) Box(VarParam(_+, 5)))  (set! VarParam(_*, 6) Box(VarParam(_*, 6)))  (set! VarParam(_/, 7) Box(VarParam(_/, 7)))  (set! VarParam(_=, 8) Box(VarParam(_=, 8)))  (set! VarParam(_<, 9) Box(VarParam(_<, 9)))  (set! VarParam(car, 10) Box(VarParam(car, 10)))  (set! VarParam(cdr, 11) Box(VarParam(cdr, 11)))  (set! VarParam(null?, 12) Box(VarParam(null?, 12)))  ((lambda (^numeric-op-dispatcher) (begin (set! VarParam(^numeric-op-dispatcher, 0) Box(VarParam(^numeric-op-dispatcher, 0)))  ((lambda (normalize) (begin (set! VarParam(normalize, 0) Box(VarParam(normalize, 0)))  (set! VarFree(+) (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(*) (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(/) ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7))))))) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) BoxGet(VarParam(x, 0)) ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0)))))))))  ((lambda (^comparator) (begin (set! VarParam(^comparator, 0) Box(VarParam(^comparator, 0)))  (set! VarFree(=) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8)))))  (set! VarFree(<) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 2, 3)) (lambda (a b) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(b, 1) Box(VarParam(b, 1)))  (if BoxGet(VarParam(a, 0)) BoxGet(VarParam(b, 1)) #f)))  #t  (BoxGet(VarBound(map, 2, 4)) (lambda (y) (begin (set! VarParam(y, 0) Box(VarParam(y, 0)))  (BoxGet(VarBound(op, 1, 0)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 0)))))  BoxGet(VarParam(ys, 1))))))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1)))) (if (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1))) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))))))
push rbx
; Env Extend Code Section For Closure#64
mov rbx, 0 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend64
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End64

LClosureEnvExtend64:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, -1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 0
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop64:
  jz LClosureEnvExtend_LoopEnd64
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop64

LClosureEnvExtend_LoopEnd64:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd64
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop64:
  jz LClosureEnvExtend_ParamsLoopEnd64

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop64

LClosureEnvExtend_ParamsLoopEnd64:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End64:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode64)
pop rbx
jmp LClosureCont64
LClosureCode64:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #65: (begin (set! VarParam(flonum?, 0) Box(VarParam(flonum?, 0)))  (set! VarParam(rational?, 1) Box(VarParam(rational?, 1)))  (set! VarParam(exact->inexact, 2) Box(VarParam(exact->inexact, 2)))  (set! VarParam(fold-left, 3) Box(VarParam(fold-left, 3)))  (set! VarParam(map, 4) Box(VarParam(map, 4)))  (set! VarParam(_+, 5) Box(VarParam(_+, 5)))  (set! VarParam(_*, 6) Box(VarParam(_*, 6)))  (set! VarParam(_/, 7) Box(VarParam(_/, 7)))  (set! VarParam(_=, 8) Box(VarParam(_=, 8)))  (set! VarParam(_<, 9) Box(VarParam(_<, 9)))  (set! VarParam(car, 10) Box(VarParam(car, 10)))  (set! VarParam(cdr, 11) Box(VarParam(cdr, 11)))  (set! VarParam(null?, 12) Box(VarParam(null?, 12)))  ((lambda (^numeric-op-dispatcher) (begin (set! VarParam(^numeric-op-dispatcher, 0) Box(VarParam(^numeric-op-dispatcher, 0)))  ((lambda (normalize) (begin (set! VarParam(normalize, 0) Box(VarParam(normalize, 0)))  (set! VarFree(+) (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(*) (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(/) ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7))))))) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) BoxGet(VarParam(x, 0)) ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0)))))))))  ((lambda (^comparator) (begin (set! VarParam(^comparator, 0) Box(VarParam(^comparator, 0)))  (set! VarFree(=) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8)))))  (set! VarFree(<) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 2, 3)) (lambda (a b) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(b, 1) Box(VarParam(b, 1)))  (if BoxGet(VarParam(a, 0)) BoxGet(VarParam(b, 1)) #f)))  #t  (BoxGet(VarBound(map, 2, 4)) (lambda (y) (begin (set! VarParam(y, 0) Box(VarParam(y, 0)))  (BoxGet(VarBound(op, 1, 0)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 0)))))  BoxGet(VarParam(ys, 1))))))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1)))) (if (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1))) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1)))))))))))
;; Starting: Item 0 in Seq statement #65
;; Starting: Set VarParam(name=flonum?, minor=0) with Box(VarParam(flonum?, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=flonum?, minor=0) with Box(VarParam(flonum?, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(flonum?, 0)
;; Starting: Get VarParam(name=flonum?, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=flonum?, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(flonum?, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=flonum?, minor=0) with Box(VarParam(flonum?, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=flonum?, minor=0) with Box(VarParam(flonum?, 0))

;; Finished: Item 0 in Seq statement #65


;; Starting: Item 1 in Seq statement #65
;; Starting: Set VarParam(name=rational?, minor=1) with Box(VarParam(rational?, 1))
;; Starting: Evaluating rhs for [ Set VarParam(name=rational?, minor=1) with Box(VarParam(rational?, 1)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(rational?, 1)
;; Starting: Get VarParam(name=rational?, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=rational?, minor=1)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(rational?, 1)

;; Finished: Evaluating rhs for [ Set VarParam(name=rational?, minor=1) with Box(VarParam(rational?, 1)) ], value is expected in rax

mov PVAR(1), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=rational?, minor=1) with Box(VarParam(rational?, 1))

;; Finished: Item 1 in Seq statement #65


;; Starting: Item 2 in Seq statement #65
;; Starting: Set VarParam(name=exact->inexact, minor=2) with Box(VarParam(exact->inexact, 2))
;; Starting: Evaluating rhs for [ Set VarParam(name=exact->inexact, minor=2) with Box(VarParam(exact->inexact, 2)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(exact->inexact, 2)
;; Starting: Get VarParam(name=exact->inexact, minor=2)
mov rax, PVAR(2)
;; Finished: Get VarParam(name=exact->inexact, minor=2)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(exact->inexact, 2)

;; Finished: Evaluating rhs for [ Set VarParam(name=exact->inexact, minor=2) with Box(VarParam(exact->inexact, 2)) ], value is expected in rax

mov PVAR(2), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=exact->inexact, minor=2) with Box(VarParam(exact->inexact, 2))

;; Finished: Item 2 in Seq statement #65


;; Starting: Item 3 in Seq statement #65
;; Starting: Set VarParam(name=fold-left, minor=3) with Box(VarParam(fold-left, 3))
;; Starting: Evaluating rhs for [ Set VarParam(name=fold-left, minor=3) with Box(VarParam(fold-left, 3)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(fold-left, 3)
;; Starting: Get VarParam(name=fold-left, minor=3)
mov rax, PVAR(3)
;; Finished: Get VarParam(name=fold-left, minor=3)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(fold-left, 3)

;; Finished: Evaluating rhs for [ Set VarParam(name=fold-left, minor=3) with Box(VarParam(fold-left, 3)) ], value is expected in rax

mov PVAR(3), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=fold-left, minor=3) with Box(VarParam(fold-left, 3))

;; Finished: Item 3 in Seq statement #65


;; Starting: Item 4 in Seq statement #65
;; Starting: Set VarParam(name=map, minor=4) with Box(VarParam(map, 4))
;; Starting: Evaluating rhs for [ Set VarParam(name=map, minor=4) with Box(VarParam(map, 4)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(map, 4)
;; Starting: Get VarParam(name=map, minor=4)
mov rax, PVAR(4)
;; Finished: Get VarParam(name=map, minor=4)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(map, 4)

;; Finished: Evaluating rhs for [ Set VarParam(name=map, minor=4) with Box(VarParam(map, 4)) ], value is expected in rax

mov PVAR(4), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=map, minor=4) with Box(VarParam(map, 4))

;; Finished: Item 4 in Seq statement #65


;; Starting: Item 5 in Seq statement #65
;; Starting: Set VarParam(name=_+, minor=5) with Box(VarParam(_+, 5))
;; Starting: Evaluating rhs for [ Set VarParam(name=_+, minor=5) with Box(VarParam(_+, 5)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(_+, 5)
;; Starting: Get VarParam(name=_+, minor=5)
mov rax, PVAR(5)
;; Finished: Get VarParam(name=_+, minor=5)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(_+, 5)

;; Finished: Evaluating rhs for [ Set VarParam(name=_+, minor=5) with Box(VarParam(_+, 5)) ], value is expected in rax

mov PVAR(5), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=_+, minor=5) with Box(VarParam(_+, 5))

;; Finished: Item 5 in Seq statement #65


;; Starting: Item 6 in Seq statement #65
;; Starting: Set VarParam(name=_*, minor=6) with Box(VarParam(_*, 6))
;; Starting: Evaluating rhs for [ Set VarParam(name=_*, minor=6) with Box(VarParam(_*, 6)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(_*, 6)
;; Starting: Get VarParam(name=_*, minor=6)
mov rax, PVAR(6)
;; Finished: Get VarParam(name=_*, minor=6)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(_*, 6)

;; Finished: Evaluating rhs for [ Set VarParam(name=_*, minor=6) with Box(VarParam(_*, 6)) ], value is expected in rax

mov PVAR(6), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=_*, minor=6) with Box(VarParam(_*, 6))

;; Finished: Item 6 in Seq statement #65


;; Starting: Item 7 in Seq statement #65
;; Starting: Set VarParam(name=_/, minor=7) with Box(VarParam(_/, 7))
;; Starting: Evaluating rhs for [ Set VarParam(name=_/, minor=7) with Box(VarParam(_/, 7)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(_/, 7)
;; Starting: Get VarParam(name=_/, minor=7)
mov rax, PVAR(7)
;; Finished: Get VarParam(name=_/, minor=7)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(_/, 7)

;; Finished: Evaluating rhs for [ Set VarParam(name=_/, minor=7) with Box(VarParam(_/, 7)) ], value is expected in rax

mov PVAR(7), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=_/, minor=7) with Box(VarParam(_/, 7))

;; Finished: Item 7 in Seq statement #65


;; Starting: Item 8 in Seq statement #65
;; Starting: Set VarParam(name=_=, minor=8) with Box(VarParam(_=, 8))
;; Starting: Evaluating rhs for [ Set VarParam(name=_=, minor=8) with Box(VarParam(_=, 8)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(_=, 8)
;; Starting: Get VarParam(name=_=, minor=8)
mov rax, PVAR(8)
;; Finished: Get VarParam(name=_=, minor=8)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(_=, 8)

;; Finished: Evaluating rhs for [ Set VarParam(name=_=, minor=8) with Box(VarParam(_=, 8)) ], value is expected in rax

mov PVAR(8), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=_=, minor=8) with Box(VarParam(_=, 8))

;; Finished: Item 8 in Seq statement #65


;; Starting: Item 9 in Seq statement #65
;; Starting: Set VarParam(name=_<, minor=9) with Box(VarParam(_<, 9))
;; Starting: Evaluating rhs for [ Set VarParam(name=_<, minor=9) with Box(VarParam(_<, 9)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(_<, 9)
;; Starting: Get VarParam(name=_<, minor=9)
mov rax, PVAR(9)
;; Finished: Get VarParam(name=_<, minor=9)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(_<, 9)

;; Finished: Evaluating rhs for [ Set VarParam(name=_<, minor=9) with Box(VarParam(_<, 9)) ], value is expected in rax

mov PVAR(9), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=_<, minor=9) with Box(VarParam(_<, 9))

;; Finished: Item 9 in Seq statement #65


;; Starting: Item 10 in Seq statement #65
;; Starting: Set VarParam(name=car, minor=10) with Box(VarParam(car, 10))
;; Starting: Evaluating rhs for [ Set VarParam(name=car, minor=10) with Box(VarParam(car, 10)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(car, 10)
;; Starting: Get VarParam(name=car, minor=10)
mov rax, PVAR(10)
;; Finished: Get VarParam(name=car, minor=10)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(car, 10)

;; Finished: Evaluating rhs for [ Set VarParam(name=car, minor=10) with Box(VarParam(car, 10)) ], value is expected in rax

mov PVAR(10), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=car, minor=10) with Box(VarParam(car, 10))

;; Finished: Item 10 in Seq statement #65


;; Starting: Item 11 in Seq statement #65
;; Starting: Set VarParam(name=cdr, minor=11) with Box(VarParam(cdr, 11))
;; Starting: Evaluating rhs for [ Set VarParam(name=cdr, minor=11) with Box(VarParam(cdr, 11)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(cdr, 11)
;; Starting: Get VarParam(name=cdr, minor=11)
mov rax, PVAR(11)
;; Finished: Get VarParam(name=cdr, minor=11)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(cdr, 11)

;; Finished: Evaluating rhs for [ Set VarParam(name=cdr, minor=11) with Box(VarParam(cdr, 11)) ], value is expected in rax

mov PVAR(11), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=cdr, minor=11) with Box(VarParam(cdr, 11))

;; Finished: Item 11 in Seq statement #65


;; Starting: Item 12 in Seq statement #65
;; Starting: Set VarParam(name=null?, minor=12) with Box(VarParam(null?, 12))
;; Starting: Evaluating rhs for [ Set VarParam(name=null?, minor=12) with Box(VarParam(null?, 12)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(null?, 12)
;; Starting: Get VarParam(name=null?, minor=12)
mov rax, PVAR(12)
;; Finished: Get VarParam(name=null?, minor=12)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(null?, 12)

;; Finished: Evaluating rhs for [ Set VarParam(name=null?, minor=12) with Box(VarParam(null?, 12)) ], value is expected in rax

mov PVAR(12), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=null?, minor=12) with Box(VarParam(null?, 12))

;; Finished: Item 12 in Seq statement #65


;; Starting: Item 13 in Seq statement #65
;; Starting: Perform Applic#66 of: ((lambda (^numeric-op-dispatcher) (begin (set! VarParam(^numeric-op-dispatcher, 0) Box(VarParam(^numeric-op-dispatcher, 0)))  ((lambda (normalize) (begin (set! VarParam(normalize, 0) Box(VarParam(normalize, 0)))  (set! VarFree(+) (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(*) (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(/) ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7))))))) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) BoxGet(VarParam(x, 0)) ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0)))))))))  ((lambda (^comparator) (begin (set! VarParam(^comparator, 0) Box(VarParam(^comparator, 0)))  (set! VarFree(=) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8)))))  (set! VarFree(<) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 2, 3)) (lambda (a b) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(b, 1) Box(VarParam(b, 1)))  (if BoxGet(VarParam(a, 0)) BoxGet(VarParam(b, 1)) #f)))  #t  (BoxGet(VarBound(map, 2, 4)) (lambda (y) (begin (set! VarParam(y, 0) Box(VarParam(y, 0)))  (BoxGet(VarBound(op, 1, 0)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 0)))))  BoxGet(VarParam(ys, 1))))))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1)))) (if (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1))) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))))
;; Starting: Argument 0 of Applic statement #66
;; Starting: Creating CLOSURE of LambdaSimple#67 -> (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1)))) (if (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1))) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1)))))))))
push rbx
; Env Extend Code Section For Closure#67
mov rbx, 1 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend67
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End67

LClosureEnvExtend67:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 0
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 8
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop67:
  jz LClosureEnvExtend_LoopEnd67
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop67

LClosureEnvExtend_LoopEnd67:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd67
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop67:
  jz LClosureEnvExtend_ParamsLoopEnd67

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop67

LClosureEnvExtend_ParamsLoopEnd67:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End67:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode67)
pop rbx
jmp LClosureCont67
LClosureCode67:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #68: (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1)))) (if (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1))) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))
;; Starting: Item 0 in Seq statement #68
;; Starting: Set VarParam(name=op, minor=0) with Box(VarParam(op, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=op, minor=0) with Box(VarParam(op, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(op, 0)
;; Starting: Get VarParam(name=op, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=op, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(op, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=op, minor=0) with Box(VarParam(op, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=op, minor=0) with Box(VarParam(op, 0))

;; Finished: Item 0 in Seq statement #68


;; Starting: Item 1 in Seq statement #68
;; Starting: Creating CLOSURE of LambdaSimple#69 -> (lambda (x y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1)))) (if (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1))) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1)))))))
push rbx
; Env Extend Code Section For Closure#69
mov rbx, 2 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend69
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End69

LClosureEnvExtend69:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 16
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop69:
  jz LClosureEnvExtend_LoopEnd69
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop69

LClosureEnvExtend_LoopEnd69:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd69
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop69:
  jz LClosureEnvExtend_ParamsLoopEnd69

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop69

LClosureEnvExtend_ParamsLoopEnd69:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End69:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode69)
pop rbx
jmp LClosureCont69
LClosureCode69:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #70: (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1)))) (if (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1))) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))
;; Starting: Item 0 in Seq statement #70
;; Starting: Set VarParam(name=x, minor=0) with Box(VarParam(x, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=x, minor=0) with Box(VarParam(x, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(x, 0)
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(x, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=x, minor=0) with Box(VarParam(x, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=x, minor=0) with Box(VarParam(x, 0))

;; Finished: Item 0 in Seq statement #70


;; Starting: Item 1 in Seq statement #70
;; Starting: Set VarParam(name=y, minor=1) with Box(VarParam(y, 1))
;; Starting: Evaluating rhs for [ Set VarParam(name=y, minor=1) with Box(VarParam(y, 1)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(y, 1)
;; Starting: Get VarParam(name=y, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=y, minor=1)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(y, 1)

;; Finished: Evaluating rhs for [ Set VarParam(name=y, minor=1) with Box(VarParam(y, 1)) ], value is expected in rax

mov PVAR(1), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=y, minor=1) with Box(VarParam(y, 1))

;; Finished: Item 1 in Seq statement #70


;; Starting: Item 2 in Seq statement #70
;; Starting: If statement (#71): (if (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1)))) (if (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1))) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1)))))
Lif71:
;; Starting: If statement (#72): (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1))) #f)
Lif72:
;; Starting: Perform Applic#73 of: (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0)))
;; Starting: Argument 0 of Applic statement #73
;; Starting: BoxGet of VarParam(x, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(x, 0)

;; Finished: Argument 0 of Applic statement #73

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #73)
;; Starting: BoxGet of VarBound(flonum?, 1, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(flonum?, 1, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=flonum?, major=1, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=flonum?, major=1, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(flonum?, 1, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(flonum?, 1, 0)

;; Finished: Evaluating proc to apply (in Applic #73)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic73
; int3
ContinueApplic73:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #73
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#73 of: (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0)))

cmp rax, SOB_FALSE_ADDRESS
je Lelse72
;; Starting: Perform Applic#74 of: (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1)))
;; Starting: Argument 0 of Applic statement #74
;; Starting: BoxGet of VarParam(y, 1)
;; Starting: Evaluating val for [ BoxGet of VarParam(y, 1) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=y, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=y, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarParam(y, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(y, 1)

;; Finished: Argument 0 of Applic statement #74

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #74)
;; Starting: BoxGet of VarBound(rational?, 1, 1)
;; Starting: Evaluating val for [ BoxGet of VarBound(rational?, 1, 1) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=rational?, major=1, minor=1)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
;; Finished: Get VarBound(name=rational?, major=1, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarBound(rational?, 1, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(rational?, 1, 1)

;; Finished: Evaluating proc to apply (in Applic #74)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic74
; int3
ContinueApplic74:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #74
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#74 of: (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1)))

jmp LendIf72
Lelse72:
mov rax, const_tbl+2	; mov const #f to rax
LendIf72:
;; Finished: If statement (#72): (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1))) #f)

cmp rax, SOB_FALSE_ADDRESS
je Lelse71
;; Starting: Perform Applic#75 of: (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1))))
;; Starting: Argument 1 of Applic statement #75
;; Starting: Perform Applic#76 of: (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1)))
;; Starting: Argument 0 of Applic statement #76
;; Starting: BoxGet of VarParam(y, 1)
;; Starting: Evaluating val for [ BoxGet of VarParam(y, 1) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=y, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=y, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarParam(y, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(y, 1)

;; Finished: Argument 0 of Applic statement #76

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #76)
;; Starting: BoxGet of VarBound(exact->inexact, 1, 2)
;; Starting: Evaluating val for [ BoxGet of VarBound(exact->inexact, 1, 2) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=exact->inexact, major=1, minor=2)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]
;; Finished: Get VarBound(name=exact->inexact, major=1, minor=2)

;; Finished: Evaluating val for [ BoxGet of VarBound(exact->inexact, 1, 2) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(exact->inexact, 1, 2)

;; Finished: Evaluating proc to apply (in Applic #76)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic76
; int3
ContinueApplic76:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #76
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#76 of: (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1)))

;; Finished: Argument 1 of Applic statement #75

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #75
;; Starting: BoxGet of VarParam(x, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(x, 0)

;; Finished: Argument 0 of Applic statement #75

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #75)
;; Starting: BoxGet of VarBound(op, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(op, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=op, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=op, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(op, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(op, 0, 0)

;; Finished: Evaluating proc to apply (in Applic #75)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic75
; int3
ContinueApplic75:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #75
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#75 of: (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1))))

jmp LendIf71
Lelse71:
;; Starting: If statement (#77): (if (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1))) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))
Lif77:
;; Starting: If statement (#78): (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f)
Lif78:
;; Starting: Perform Applic#79 of: (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0)))
;; Starting: Argument 0 of Applic statement #79
;; Starting: BoxGet of VarParam(x, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(x, 0)

;; Finished: Argument 0 of Applic statement #79

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #79)
;; Starting: BoxGet of VarBound(rational?, 1, 1)
;; Starting: Evaluating val for [ BoxGet of VarBound(rational?, 1, 1) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=rational?, major=1, minor=1)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
;; Finished: Get VarBound(name=rational?, major=1, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarBound(rational?, 1, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(rational?, 1, 1)

;; Finished: Evaluating proc to apply (in Applic #79)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic79
; int3
ContinueApplic79:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #79
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#79 of: (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0)))

cmp rax, SOB_FALSE_ADDRESS
je Lelse78
;; Starting: Perform Applic#80 of: (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1)))
;; Starting: Argument 0 of Applic statement #80
;; Starting: BoxGet of VarParam(y, 1)
;; Starting: Evaluating val for [ BoxGet of VarParam(y, 1) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=y, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=y, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarParam(y, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(y, 1)

;; Finished: Argument 0 of Applic statement #80

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #80)
;; Starting: BoxGet of VarBound(flonum?, 1, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(flonum?, 1, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=flonum?, major=1, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=flonum?, major=1, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(flonum?, 1, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(flonum?, 1, 0)

;; Finished: Evaluating proc to apply (in Applic #80)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic80
; int3
ContinueApplic80:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #80
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#80 of: (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1)))

jmp LendIf78
Lelse78:
mov rax, const_tbl+2	; mov const #f to rax
LendIf78:
;; Finished: If statement (#78): (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f)

cmp rax, SOB_FALSE_ADDRESS
je Lelse77
;; Starting: Perform Applic#81 of: (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1)))
;; Starting: Argument 1 of Applic statement #81
;; Starting: BoxGet of VarParam(y, 1)
;; Starting: Evaluating val for [ BoxGet of VarParam(y, 1) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=y, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=y, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarParam(y, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(y, 1)

;; Finished: Argument 1 of Applic statement #81

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #81
;; Starting: Perform Applic#82 of: (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))
;; Starting: Argument 0 of Applic statement #82
;; Starting: BoxGet of VarParam(x, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(x, 0)

;; Finished: Argument 0 of Applic statement #82

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #82)
;; Starting: BoxGet of VarBound(exact->inexact, 1, 2)
;; Starting: Evaluating val for [ BoxGet of VarBound(exact->inexact, 1, 2) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=exact->inexact, major=1, minor=2)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]
;; Finished: Get VarBound(name=exact->inexact, major=1, minor=2)

;; Finished: Evaluating val for [ BoxGet of VarBound(exact->inexact, 1, 2) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(exact->inexact, 1, 2)

;; Finished: Evaluating proc to apply (in Applic #82)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic82
; int3
ContinueApplic82:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #82
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#82 of: (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))

;; Finished: Argument 0 of Applic statement #81

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #81)
;; Starting: BoxGet of VarBound(op, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(op, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=op, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=op, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(op, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(op, 0, 0)

;; Finished: Evaluating proc to apply (in Applic #81)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic81
; int3
ContinueApplic81:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #81
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#81 of: (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1)))

jmp LendIf77
Lelse77:
;; Starting: Perform Applic#83 of: (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1)))
;; Starting: Argument 1 of Applic statement #83
;; Starting: BoxGet of VarParam(y, 1)
;; Starting: Evaluating val for [ BoxGet of VarParam(y, 1) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=y, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=y, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarParam(y, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(y, 1)

;; Finished: Argument 1 of Applic statement #83

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #83
;; Starting: BoxGet of VarParam(x, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(x, 0)

;; Finished: Argument 0 of Applic statement #83

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #83)
;; Starting: BoxGet of VarBound(op, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(op, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=op, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=op, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(op, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(op, 0, 0)

;; Finished: Evaluating proc to apply (in Applic #83)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic83
; int3
ContinueApplic83:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #83
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#83 of: (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1)))

LendIf77:
;; Finished: If statement (#77): (if (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1))) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))

LendIf71:
;; Finished: If statement (#71): (if (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1)))) (if (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1))) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1)))))

;; Finished: Item 2 in Seq statement #70

;; Finished: Seq statement #70: (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1)))) (if (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1))) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont69:

;; Finished: Creating CLOSURE of LambdaSimple#69 -> (lambda (x y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1)))) (if (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1))) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1)))))))

;; Finished: Item 1 in Seq statement #68

;; Finished: Seq statement #68: (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1)))) (if (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1))) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont67:

;; Finished: Creating CLOSURE of LambdaSimple#67 -> (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1)))) (if (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1))) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1)))))))))

;; Finished: Argument 0 of Applic statement #66

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #66)
;; Starting: Creating CLOSURE of LambdaSimple#84 -> (lambda (^numeric-op-dispatcher) (begin (set! VarParam(^numeric-op-dispatcher, 0) Box(VarParam(^numeric-op-dispatcher, 0)))  ((lambda (normalize) (begin (set! VarParam(normalize, 0) Box(VarParam(normalize, 0)))  (set! VarFree(+) (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(*) (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(/) ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7))))))) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) BoxGet(VarParam(x, 0)) ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0)))))))))  ((lambda (^comparator) (begin (set! VarParam(^comparator, 0) Box(VarParam(^comparator, 0)))  (set! VarFree(=) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8)))))  (set! VarFree(<) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 2, 3)) (lambda (a b) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(b, 1) Box(VarParam(b, 1)))  (if BoxGet(VarParam(a, 0)) BoxGet(VarParam(b, 1)) #f)))  #t  (BoxGet(VarBound(map, 2, 4)) (lambda (y) (begin (set! VarParam(y, 0) Box(VarParam(y, 0)))  (BoxGet(VarBound(op, 1, 0)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 0)))))  BoxGet(VarParam(ys, 1)))))))))))
push rbx
; Env Extend Code Section For Closure#84
mov rbx, 3 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend84
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End84

LClosureEnvExtend84:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 2
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 24
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop84:
  jz LClosureEnvExtend_LoopEnd84
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop84

LClosureEnvExtend_LoopEnd84:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd84
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop84:
  jz LClosureEnvExtend_ParamsLoopEnd84

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop84

LClosureEnvExtend_ParamsLoopEnd84:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End84:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode84)
pop rbx
jmp LClosureCont84
LClosureCode84:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #85: (begin (set! VarParam(^numeric-op-dispatcher, 0) Box(VarParam(^numeric-op-dispatcher, 0)))  ((lambda (normalize) (begin (set! VarParam(normalize, 0) Box(VarParam(normalize, 0)))  (set! VarFree(+) (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(*) (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(/) ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7))))))) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) BoxGet(VarParam(x, 0)) ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0)))))))))  ((lambda (^comparator) (begin (set! VarParam(^comparator, 0) Box(VarParam(^comparator, 0)))  (set! VarFree(=) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8)))))  (set! VarFree(<) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 2, 3)) (lambda (a b) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(b, 1) Box(VarParam(b, 1)))  (if BoxGet(VarParam(a, 0)) BoxGet(VarParam(b, 1)) #f)))  #t  (BoxGet(VarBound(map, 2, 4)) (lambda (y) (begin (set! VarParam(y, 0) Box(VarParam(y, 0)))  (BoxGet(VarBound(op, 1, 0)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 0)))))  BoxGet(VarParam(ys, 1))))))))))
;; Starting: Item 0 in Seq statement #85
;; Starting: Set VarParam(name=^numeric-op-dispatcher, minor=0) with Box(VarParam(^numeric-op-dispatcher, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=^numeric-op-dispatcher, minor=0) with Box(VarParam(^numeric-op-dispatcher, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(^numeric-op-dispatcher, 0)
;; Starting: Get VarParam(name=^numeric-op-dispatcher, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=^numeric-op-dispatcher, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(^numeric-op-dispatcher, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=^numeric-op-dispatcher, minor=0) with Box(VarParam(^numeric-op-dispatcher, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=^numeric-op-dispatcher, minor=0) with Box(VarParam(^numeric-op-dispatcher, 0))

;; Finished: Item 0 in Seq statement #85


;; Starting: Item 1 in Seq statement #85
;; Starting: Perform Applic#86 of: ((lambda (normalize) (begin (set! VarParam(normalize, 0) Box(VarParam(normalize, 0)))  (set! VarFree(+) (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(*) (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(/) ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7))))))) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) BoxGet(VarParam(x, 0)) ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0)))))))))
;; Starting: Argument 0 of Applic statement #86
;; Starting: Creating CLOSURE of LambdaSimple#87 -> (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) BoxGet(VarParam(x, 0)) ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0))))))))
push rbx
; Env Extend Code Section For Closure#87
mov rbx, 4 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend87
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End87

LClosureEnvExtend87:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 3
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 32
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop87:
  jz LClosureEnvExtend_LoopEnd87
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop87

LClosureEnvExtend_LoopEnd87:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd87
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop87:
  jz LClosureEnvExtend_ParamsLoopEnd87

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop87

LClosureEnvExtend_ParamsLoopEnd87:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End87:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode87)
pop rbx
jmp LClosureCont87
LClosureCode87:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #88: (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) BoxGet(VarParam(x, 0)) ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0)))))))
;; Starting: Item 0 in Seq statement #88
;; Starting: Set VarParam(name=x, minor=0) with Box(VarParam(x, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=x, minor=0) with Box(VarParam(x, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(x, 0)
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(x, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=x, minor=0) with Box(VarParam(x, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=x, minor=0) with Box(VarParam(x, 0))

;; Finished: Item 0 in Seq statement #88


;; Starting: Item 1 in Seq statement #88
;; Starting: If statement (#89): (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) BoxGet(VarParam(x, 0)) ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0))))))
Lif89:
;; Starting: Perform Applic#90 of: (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0)))
;; Starting: Argument 0 of Applic statement #90
;; Starting: BoxGet of VarParam(x, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(x, 0)

;; Finished: Argument 0 of Applic statement #90

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #90)
;; Starting: BoxGet of VarBound(flonum?, 1, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(flonum?, 1, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=flonum?, major=1, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=flonum?, major=1, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(flonum?, 1, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(flonum?, 1, 0)

;; Finished: Evaluating proc to apply (in Applic #90)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic90
; int3
ContinueApplic90:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #90
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#90 of: (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0)))

cmp rax, SOB_FALSE_ADDRESS
je Lelse89
;; Starting: BoxGet of VarParam(x, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(x, 0)

jmp LendIf89
Lelse89:
;; Starting: Perform Applic#91 of: ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0)))))
;; Starting: Argument 0 of Applic statement #91
;; Starting: Perform Applic#92 of: (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0))))
;; Starting: Argument 1 of Applic statement #92
;; Starting: Perform Applic#94 of: (VarFree(denominator) BoxGet(VarParam(x, 0)))
;; Starting: Argument 0 of Applic statement #94
;; Starting: BoxGet of VarParam(x, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(x, 0)

;; Finished: Argument 0 of Applic statement #94

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #94)
mov rax, qword [fvar_tbl+8*19]	; mov fvar denominator to rax
;; Finished: Evaluating proc to apply (in Applic #94)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic94
; int3
ContinueApplic94:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #94
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#94 of: (VarFree(denominator) BoxGet(VarParam(x, 0)))

;; Finished: Argument 1 of Applic statement #92

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #92
;; Starting: Perform Applic#93 of: (VarFree(numerator) BoxGet(VarParam(x, 0)))
;; Starting: Argument 0 of Applic statement #93
;; Starting: BoxGet of VarParam(x, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(x, 0)

;; Finished: Argument 0 of Applic statement #93

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #93)
mov rax, qword [fvar_tbl+8*18]	; mov fvar numerator to rax
;; Finished: Evaluating proc to apply (in Applic #93)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic93
; int3
ContinueApplic93:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #93
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#93 of: (VarFree(numerator) BoxGet(VarParam(x, 0)))

;; Finished: Argument 0 of Applic statement #92

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #92)
mov rax, qword [fvar_tbl+8*20]	; mov fvar gcd to rax
;; Finished: Evaluating proc to apply (in Applic #92)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic92
; int3
ContinueApplic92:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #92
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#92 of: (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0))))

;; Finished: Argument 0 of Applic statement #91

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #91)
;; Starting: Creating CLOSURE of LambdaSimple#95 -> (lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0))))))
push rbx
; Env Extend Code Section For Closure#95
mov rbx, 5 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend95
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End95

LClosureEnvExtend95:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 4
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 40
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop95:
  jz LClosureEnvExtend_LoopEnd95
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop95

LClosureEnvExtend_LoopEnd95:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd95
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop95:
  jz LClosureEnvExtend_ParamsLoopEnd95

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop95

LClosureEnvExtend_ParamsLoopEnd95:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End95:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode95)
pop rbx
jmp LClosureCont95
LClosureCode95:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #96: (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))
;; Starting: Item 0 in Seq statement #96
;; Starting: Set VarParam(name=n, minor=0) with Box(VarParam(n, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=n, minor=0) with Box(VarParam(n, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(n, 0)
;; Starting: Get VarParam(name=n, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=n, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(n, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=n, minor=0) with Box(VarParam(n, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=n, minor=0) with Box(VarParam(n, 0))

;; Finished: Item 0 in Seq statement #96


;; Starting: Item 1 in Seq statement #96
;; Starting: Perform Applic#97 of: (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0))))
;; Starting: Argument 1 of Applic statement #97
;; Starting: Perform Applic#100 of: (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))
;; Starting: Argument 1 of Applic statement #100
;; Starting: BoxGet of VarParam(n, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(n, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=n, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=n, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(n, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(n, 0)

;; Finished: Argument 1 of Applic statement #100

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #100
;; Starting: Perform Applic#101 of: (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))
;; Starting: Argument 0 of Applic statement #101
;; Starting: BoxGet of VarBound(x, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(x, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=x, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=x, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(x, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(x, 0, 0)

;; Finished: Argument 0 of Applic statement #101

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #101)
mov rax, qword [fvar_tbl+8*19]	; mov fvar denominator to rax
;; Finished: Evaluating proc to apply (in Applic #101)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic101
; int3
ContinueApplic101:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #101
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#101 of: (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))

;; Finished: Argument 0 of Applic statement #100

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #100)
;; Starting: BoxGet of VarBound(_/, 2, 7)
;; Starting: Evaluating val for [ BoxGet of VarBound(_/, 2, 7) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=_/, major=2, minor=7)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 7]
;; Finished: Get VarBound(name=_/, major=2, minor=7)

;; Finished: Evaluating val for [ BoxGet of VarBound(_/, 2, 7) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(_/, 2, 7)

;; Finished: Evaluating proc to apply (in Applic #100)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic100
; int3
ContinueApplic100:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #100
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#100 of: (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))

;; Finished: Argument 1 of Applic statement #97

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #97
;; Starting: Perform Applic#98 of: (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))
;; Starting: Argument 1 of Applic statement #98
;; Starting: BoxGet of VarParam(n, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(n, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=n, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=n, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(n, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(n, 0)

;; Finished: Argument 1 of Applic statement #98

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #98
;; Starting: Perform Applic#99 of: (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))
;; Starting: Argument 0 of Applic statement #99
;; Starting: BoxGet of VarBound(x, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(x, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=x, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=x, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(x, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(x, 0, 0)

;; Finished: Argument 0 of Applic statement #99

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #99)
mov rax, qword [fvar_tbl+8*18]	; mov fvar numerator to rax
;; Finished: Evaluating proc to apply (in Applic #99)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic99
; int3
ContinueApplic99:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #99
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#99 of: (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))

;; Finished: Argument 0 of Applic statement #98

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #98)
;; Starting: BoxGet of VarBound(_/, 2, 7)
;; Starting: Evaluating val for [ BoxGet of VarBound(_/, 2, 7) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=_/, major=2, minor=7)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 7]
;; Finished: Get VarBound(name=_/, major=2, minor=7)

;; Finished: Evaluating val for [ BoxGet of VarBound(_/, 2, 7) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(_/, 2, 7)

;; Finished: Evaluating proc to apply (in Applic #98)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic98
; int3
ContinueApplic98:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #98
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#98 of: (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))

;; Finished: Argument 0 of Applic statement #97

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #97)
;; Starting: BoxGet of VarBound(_/, 2, 7)
;; Starting: Evaluating val for [ BoxGet of VarBound(_/, 2, 7) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=_/, major=2, minor=7)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 7]
;; Finished: Get VarBound(name=_/, major=2, minor=7)

;; Finished: Evaluating val for [ BoxGet of VarBound(_/, 2, 7) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(_/, 2, 7)

;; Finished: Evaluating proc to apply (in Applic #97)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic97
; int3
ContinueApplic97:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #97
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#97 of: (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0))))

;; Finished: Item 1 in Seq statement #96

;; Finished: Seq statement #96: (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont95:

;; Finished: Creating CLOSURE of LambdaSimple#95 -> (lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0))))))

;; Finished: Evaluating proc to apply (in Applic #91)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic91
; int3
ContinueApplic91:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #91
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#91 of: ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0)))))

LendIf89:
;; Finished: If statement (#89): (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) BoxGet(VarParam(x, 0)) ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0))))))

;; Finished: Item 1 in Seq statement #88

;; Finished: Seq statement #88: (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) BoxGet(VarParam(x, 0)) ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0)))))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont87:

;; Finished: Creating CLOSURE of LambdaSimple#87 -> (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) BoxGet(VarParam(x, 0)) ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0))))))))

;; Finished: Argument 0 of Applic statement #86

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #86)
;; Starting: Creating CLOSURE of LambdaSimple#102 -> (lambda (normalize) (begin (set! VarParam(normalize, 0) Box(VarParam(normalize, 0)))  (set! VarFree(+) (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(*) (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(/) ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7)))))))
push rbx
; Env Extend Code Section For Closure#102
mov rbx, 6 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend102
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End102

LClosureEnvExtend102:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 5
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 48
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop102:
  jz LClosureEnvExtend_LoopEnd102
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop102

LClosureEnvExtend_LoopEnd102:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd102
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop102:
  jz LClosureEnvExtend_ParamsLoopEnd102

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop102

LClosureEnvExtend_ParamsLoopEnd102:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End102:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode102)
pop rbx
jmp LClosureCont102
LClosureCode102:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #103: (begin (set! VarParam(normalize, 0) Box(VarParam(normalize, 0)))  (set! VarFree(+) (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(*) (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(/) ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7))))))
;; Starting: Item 0 in Seq statement #103
;; Starting: Set VarParam(name=normalize, minor=0) with Box(VarParam(normalize, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=normalize, minor=0) with Box(VarParam(normalize, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(normalize, 0)
;; Starting: Get VarParam(name=normalize, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=normalize, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(normalize, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=normalize, minor=0) with Box(VarParam(normalize, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=normalize, minor=0) with Box(VarParam(normalize, 0))

;; Finished: Item 0 in Seq statement #103


;; Starting: Item 1 in Seq statement #103
;; Starting: Set fvar + to (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0))))))

;;; BUG - WE END UP WITH #void in rax, and we put void in the location of + in the fvar table
mov qword [fvar_tbl+8*15], rax 
Debug2:
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar + to (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0))))))

;; Finished: Item 1 in Seq statement #103


;; Starting: Item 2 in Seq statement #103
;; Starting: Set fvar * to (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0))))))

mov qword [fvar_tbl+8*16], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar * to (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0))))))

;; Finished: Item 2 in Seq statement #103


;; Starting: Item 3 in Seq statement #103
;; Starting: Set fvar / to ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7))))
;; Starting: Perform Applic#104 of: ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7))))
;; Starting: Argument 0 of Applic statement #104
;; Starting: Perform Applic#105 of: (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7)))
;; Starting: Argument 0 of Applic statement #105
;; Starting: BoxGet of VarBound(_/, 1, 7)
;; Starting: Evaluating val for [ BoxGet of VarBound(_/, 1, 7) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=_/, major=1, minor=7)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 7]
;; Finished: Get VarBound(name=_/, major=1, minor=7)

;; Finished: Evaluating val for [ BoxGet of VarBound(_/, 1, 7) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(_/, 1, 7)

;; Finished: Argument 0 of Applic statement #105

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #105)
;; Starting: BoxGet of VarBound(^numeric-op-dispatcher, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(^numeric-op-dispatcher, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=^numeric-op-dispatcher, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=^numeric-op-dispatcher, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(^numeric-op-dispatcher, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(^numeric-op-dispatcher, 0, 0)

;; Finished: Evaluating proc to apply (in Applic #105)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic105
; int3
ContinueApplic105:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #105
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#105 of: (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7)))

;; Finished: Argument 0 of Applic statement #104

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #104)
;; Starting: Creating CLOSURE of LambdaSimple#106 -> (lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1)))))))))
push rbx
; Env Extend Code Section For Closure#106
mov rbx, 7 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend106
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End106

LClosureEnvExtend106:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 6
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 56
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop106:
  jz LClosureEnvExtend_LoopEnd106
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop106

LClosureEnvExtend_LoopEnd106:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd106
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop106:
  jz LClosureEnvExtend_ParamsLoopEnd106

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop106

LClosureEnvExtend_ParamsLoopEnd106:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End106:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode106)
pop rbx
jmp LClosureCont106
LClosureCode106:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #107: (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))
;; Starting: Item 0 in Seq statement #107
;; Starting: Set VarParam(name=/, minor=0) with Box(VarParam(/, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=/, minor=0) with Box(VarParam(/, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(/, 0)
;; Starting: Get VarParam(name=/, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=/, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(/, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=/, minor=0) with Box(VarParam(/, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=/, minor=0) with Box(VarParam(/, 0))

;; Finished: Item 0 in Seq statement #107


;; Starting: Item 1 in Seq statement #107

;; Finished: Item 1 in Seq statement #107

;; Finished: Seq statement #107: (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont106:

;; Finished: Creating CLOSURE of LambdaSimple#106 -> (lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1)))))))))

;; Finished: Evaluating proc to apply (in Applic #104)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic104
; int3
ContinueApplic104:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #104
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#104 of: ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7))))

mov qword [fvar_tbl+8*17], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar / to ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7))))

;; Finished: Item 3 in Seq statement #103

;; Finished: Seq statement #103: (begin (set! VarParam(normalize, 0) Box(VarParam(normalize, 0)))  (set! VarFree(+) (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(*) (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(/) ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7))))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont102:

;; Finished: Creating CLOSURE of LambdaSimple#102 -> (lambda (normalize) (begin (set! VarParam(normalize, 0) Box(VarParam(normalize, 0)))  (set! VarFree(+) (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(*) (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(/) ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7)))))))

;; Finished: Evaluating proc to apply (in Applic #86)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic86
; int3
ContinueApplic86:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #86
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#86 of: ((lambda (normalize) (begin (set! VarParam(normalize, 0) Box(VarParam(normalize, 0)))  (set! VarFree(+) (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(*) (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(/) ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7))))))) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) BoxGet(VarParam(x, 0)) ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0)))))))))

;; Finished: Item 1 in Seq statement #85


;; Starting: Item 2 in Seq statement #85
;; Starting: Perform Applic#108 of: ((lambda (^comparator) (begin (set! VarParam(^comparator, 0) Box(VarParam(^comparator, 0)))  (set! VarFree(=) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8)))))  (set! VarFree(<) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 2, 3)) (lambda (a b) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(b, 1) Box(VarParam(b, 1)))  (if BoxGet(VarParam(a, 0)) BoxGet(VarParam(b, 1)) #f)))  #t  (BoxGet(VarBound(map, 2, 4)) (lambda (y) (begin (set! VarParam(y, 0) Box(VarParam(y, 0)))  (BoxGet(VarBound(op, 1, 0)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 0)))))  BoxGet(VarParam(ys, 1)))))))))
;; Starting: Argument 0 of Applic statement #108
;; Starting: Creating CLOSURE of LambdaSimple#109 -> (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 2, 3)) (lambda (a b) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(b, 1) Box(VarParam(b, 1)))  (if BoxGet(VarParam(a, 0)) BoxGet(VarParam(b, 1)) #f)))  #t  (BoxGet(VarBound(map, 2, 4)) (lambda (y) (begin (set! VarParam(y, 0) Box(VarParam(y, 0)))  (BoxGet(VarBound(op, 1, 0)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 0)))))  BoxGet(VarParam(ys, 1))))))))
push rbx
; Env Extend Code Section For Closure#109
mov rbx, 8 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend109
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End109

LClosureEnvExtend109:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 7
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 64
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop109:
  jz LClosureEnvExtend_LoopEnd109
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop109

LClosureEnvExtend_LoopEnd109:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd109
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop109:
  jz LClosureEnvExtend_ParamsLoopEnd109

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop109

LClosureEnvExtend_ParamsLoopEnd109:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End109:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode109)
pop rbx
jmp LClosureCont109
LClosureCode109:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #110: (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 2, 3)) (lambda (a b) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(b, 1) Box(VarParam(b, 1)))  (if BoxGet(VarParam(a, 0)) BoxGet(VarParam(b, 1)) #f)))  #t  (BoxGet(VarBound(map, 2, 4)) (lambda (y) (begin (set! VarParam(y, 0) Box(VarParam(y, 0)))  (BoxGet(VarBound(op, 1, 0)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 0)))))  BoxGet(VarParam(ys, 1)))))))
;; Starting: Item 0 in Seq statement #110
;; Starting: Set VarParam(name=op, minor=0) with Box(VarParam(op, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=op, minor=0) with Box(VarParam(op, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(op, 0)
;; Starting: Get VarParam(name=op, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=op, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(op, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=op, minor=0) with Box(VarParam(op, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=op, minor=0) with Box(VarParam(op, 0))

;; Finished: Item 0 in Seq statement #110


;; Starting: Item 1 in Seq statement #110

;; Finished: Item 1 in Seq statement #110

;; Finished: Seq statement #110: (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 2, 3)) (lambda (a b) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(b, 1) Box(VarParam(b, 1)))  (if BoxGet(VarParam(a, 0)) BoxGet(VarParam(b, 1)) #f)))  #t  (BoxGet(VarBound(map, 2, 4)) (lambda (y) (begin (set! VarParam(y, 0) Box(VarParam(y, 0)))  (BoxGet(VarBound(op, 1, 0)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 0)))))  BoxGet(VarParam(ys, 1)))))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont109:

;; Finished: Creating CLOSURE of LambdaSimple#109 -> (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 2, 3)) (lambda (a b) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(b, 1) Box(VarParam(b, 1)))  (if BoxGet(VarParam(a, 0)) BoxGet(VarParam(b, 1)) #f)))  #t  (BoxGet(VarBound(map, 2, 4)) (lambda (y) (begin (set! VarParam(y, 0) Box(VarParam(y, 0)))  (BoxGet(VarBound(op, 1, 0)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 0)))))  BoxGet(VarParam(ys, 1))))))))

;; Finished: Argument 0 of Applic statement #108

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #108)
;; Starting: Creating CLOSURE of LambdaSimple#111 -> (lambda (^comparator) (begin (set! VarParam(^comparator, 0) Box(VarParam(^comparator, 0)))  (set! VarFree(=) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8)))))  (set! VarFree(<) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9)))))))
push rbx
; Env Extend Code Section For Closure#111
mov rbx, 9 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend111
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End111

LClosureEnvExtend111:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 8
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 72
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop111:
  jz LClosureEnvExtend_LoopEnd111
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop111

LClosureEnvExtend_LoopEnd111:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd111
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop111:
  jz LClosureEnvExtend_ParamsLoopEnd111

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop111

LClosureEnvExtend_ParamsLoopEnd111:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End111:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode111)
pop rbx
jmp LClosureCont111
LClosureCode111:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #112: (begin (set! VarParam(^comparator, 0) Box(VarParam(^comparator, 0)))  (set! VarFree(=) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8)))))  (set! VarFree(<) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9))))))
;; Starting: Item 0 in Seq statement #112
;; Starting: Set VarParam(name=^comparator, minor=0) with Box(VarParam(^comparator, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=^comparator, minor=0) with Box(VarParam(^comparator, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(^comparator, 0)
;; Starting: Get VarParam(name=^comparator, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=^comparator, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(^comparator, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=^comparator, minor=0) with Box(VarParam(^comparator, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=^comparator, minor=0) with Box(VarParam(^comparator, 0))

;; Finished: Item 0 in Seq statement #112


;; Starting: Item 1 in Seq statement #112
;; Starting: Set fvar = to (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8))))
;; Starting: Perform Applic#113 of: (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8))))
;; Starting: Argument 0 of Applic statement #113
;; Starting: Perform Applic#114 of: (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8)))
;; Starting: Argument 0 of Applic statement #114
;; Starting: BoxGet of VarBound(_=, 1, 8)
;; Starting: Evaluating val for [ BoxGet of VarBound(_=, 1, 8) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=_=, major=1, minor=8)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 8]
;; Finished: Get VarBound(name=_=, major=1, minor=8)

;; Finished: Evaluating val for [ BoxGet of VarBound(_=, 1, 8) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(_=, 1, 8)

;; Finished: Argument 0 of Applic statement #114

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #114)
;; Starting: BoxGet of VarBound(^numeric-op-dispatcher, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(^numeric-op-dispatcher, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=^numeric-op-dispatcher, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=^numeric-op-dispatcher, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(^numeric-op-dispatcher, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(^numeric-op-dispatcher, 0, 0)

;; Finished: Evaluating proc to apply (in Applic #114)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic114
; int3
ContinueApplic114:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #114
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#114 of: (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8)))

;; Finished: Argument 0 of Applic statement #113

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #113)
;; Starting: BoxGet of VarParam(^comparator, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(^comparator, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=^comparator, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=^comparator, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(^comparator, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(^comparator, 0)

;; Finished: Evaluating proc to apply (in Applic #113)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic113
; int3
ContinueApplic113:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #113
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#113 of: (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8))))

mov qword [fvar_tbl+8*21], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar = to (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8))))

;; Finished: Item 1 in Seq statement #112


;; Starting: Item 2 in Seq statement #112
;; Starting: Set fvar < to (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9))))
;; Starting: Perform Applic#115 of: (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9))))
;; Starting: Argument 0 of Applic statement #115
;; Starting: Perform Applic#116 of: (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9)))
;; Starting: Argument 0 of Applic statement #116
;; Starting: BoxGet of VarBound(_<, 1, 9)
;; Starting: Evaluating val for [ BoxGet of VarBound(_<, 1, 9) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=_<, major=1, minor=9)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 9]
;; Finished: Get VarBound(name=_<, major=1, minor=9)

;; Finished: Evaluating val for [ BoxGet of VarBound(_<, 1, 9) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(_<, 1, 9)

;; Finished: Argument 0 of Applic statement #116

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #116)
;; Starting: BoxGet of VarBound(^numeric-op-dispatcher, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(^numeric-op-dispatcher, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=^numeric-op-dispatcher, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=^numeric-op-dispatcher, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(^numeric-op-dispatcher, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(^numeric-op-dispatcher, 0, 0)

;; Finished: Evaluating proc to apply (in Applic #116)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic116
; int3
ContinueApplic116:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #116
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#116 of: (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9)))

;; Finished: Argument 0 of Applic statement #115

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #115)
;; Starting: BoxGet of VarParam(^comparator, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(^comparator, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=^comparator, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=^comparator, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(^comparator, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(^comparator, 0)

;; Finished: Evaluating proc to apply (in Applic #115)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic115
; int3
ContinueApplic115:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #115
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#115 of: (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9))))

mov qword [fvar_tbl+8*22], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar < to (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9))))

;; Finished: Item 2 in Seq statement #112

;; Finished: Seq statement #112: (begin (set! VarParam(^comparator, 0) Box(VarParam(^comparator, 0)))  (set! VarFree(=) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8)))))  (set! VarFree(<) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9))))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont111:

;; Finished: Creating CLOSURE of LambdaSimple#111 -> (lambda (^comparator) (begin (set! VarParam(^comparator, 0) Box(VarParam(^comparator, 0)))  (set! VarFree(=) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8)))))  (set! VarFree(<) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9)))))))

;; Finished: Evaluating proc to apply (in Applic #108)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic108
; int3
ContinueApplic108:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #108
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#108 of: ((lambda (^comparator) (begin (set! VarParam(^comparator, 0) Box(VarParam(^comparator, 0)))  (set! VarFree(=) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8)))))  (set! VarFree(<) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 2, 3)) (lambda (a b) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(b, 1) Box(VarParam(b, 1)))  (if BoxGet(VarParam(a, 0)) BoxGet(VarParam(b, 1)) #f)))  #t  (BoxGet(VarBound(map, 2, 4)) (lambda (y) (begin (set! VarParam(y, 0) Box(VarParam(y, 0)))  (BoxGet(VarBound(op, 1, 0)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 0)))))  BoxGet(VarParam(ys, 1)))))))))

;; Finished: Item 2 in Seq statement #85

;; Finished: Seq statement #85: (begin (set! VarParam(^numeric-op-dispatcher, 0) Box(VarParam(^numeric-op-dispatcher, 0)))  ((lambda (normalize) (begin (set! VarParam(normalize, 0) Box(VarParam(normalize, 0)))  (set! VarFree(+) (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(*) (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(/) ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7))))))) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) BoxGet(VarParam(x, 0)) ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0)))))))))  ((lambda (^comparator) (begin (set! VarParam(^comparator, 0) Box(VarParam(^comparator, 0)))  (set! VarFree(=) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8)))))  (set! VarFree(<) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 2, 3)) (lambda (a b) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(b, 1) Box(VarParam(b, 1)))  (if BoxGet(VarParam(a, 0)) BoxGet(VarParam(b, 1)) #f)))  #t  (BoxGet(VarBound(map, 2, 4)) (lambda (y) (begin (set! VarParam(y, 0) Box(VarParam(y, 0)))  (BoxGet(VarBound(op, 1, 0)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 0)))))  BoxGet(VarParam(ys, 1))))))))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont84:

;; Finished: Creating CLOSURE of LambdaSimple#84 -> (lambda (^numeric-op-dispatcher) (begin (set! VarParam(^numeric-op-dispatcher, 0) Box(VarParam(^numeric-op-dispatcher, 0)))  ((lambda (normalize) (begin (set! VarParam(normalize, 0) Box(VarParam(normalize, 0)))  (set! VarFree(+) (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(*) (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(/) ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7))))))) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) BoxGet(VarParam(x, 0)) ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0)))))))))  ((lambda (^comparator) (begin (set! VarParam(^comparator, 0) Box(VarParam(^comparator, 0)))  (set! VarFree(=) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8)))))  (set! VarFree(<) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 2, 3)) (lambda (a b) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(b, 1) Box(VarParam(b, 1)))  (if BoxGet(VarParam(a, 0)) BoxGet(VarParam(b, 1)) #f)))  #t  (BoxGet(VarBound(map, 2, 4)) (lambda (y) (begin (set! VarParam(y, 0) Box(VarParam(y, 0)))  (BoxGet(VarBound(op, 1, 0)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 0)))))  BoxGet(VarParam(ys, 1)))))))))))

;; Finished: Evaluating proc to apply (in Applic #66)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic66
; int3
ContinueApplic66:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #66
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#66 of: ((lambda (^numeric-op-dispatcher) (begin (set! VarParam(^numeric-op-dispatcher, 0) Box(VarParam(^numeric-op-dispatcher, 0)))  ((lambda (normalize) (begin (set! VarParam(normalize, 0) Box(VarParam(normalize, 0)))  (set! VarFree(+) (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(*) (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(/) ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7))))))) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) BoxGet(VarParam(x, 0)) ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0)))))))))  ((lambda (^comparator) (begin (set! VarParam(^comparator, 0) Box(VarParam(^comparator, 0)))  (set! VarFree(=) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8)))))  (set! VarFree(<) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 2, 3)) (lambda (a b) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(b, 1) Box(VarParam(b, 1)))  (if BoxGet(VarParam(a, 0)) BoxGet(VarParam(b, 1)) #f)))  #t  (BoxGet(VarBound(map, 2, 4)) (lambda (y) (begin (set! VarParam(y, 0) Box(VarParam(y, 0)))  (BoxGet(VarBound(op, 1, 0)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 0)))))  BoxGet(VarParam(ys, 1))))))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1)))) (if (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1))) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))))

;; Finished: Item 13 in Seq statement #65

;; Finished: Seq statement #65: (begin (set! VarParam(flonum?, 0) Box(VarParam(flonum?, 0)))  (set! VarParam(rational?, 1) Box(VarParam(rational?, 1)))  (set! VarParam(exact->inexact, 2) Box(VarParam(exact->inexact, 2)))  (set! VarParam(fold-left, 3) Box(VarParam(fold-left, 3)))  (set! VarParam(map, 4) Box(VarParam(map, 4)))  (set! VarParam(_+, 5) Box(VarParam(_+, 5)))  (set! VarParam(_*, 6) Box(VarParam(_*, 6)))  (set! VarParam(_/, 7) Box(VarParam(_/, 7)))  (set! VarParam(_=, 8) Box(VarParam(_=, 8)))  (set! VarParam(_<, 9) Box(VarParam(_<, 9)))  (set! VarParam(car, 10) Box(VarParam(car, 10)))  (set! VarParam(cdr, 11) Box(VarParam(cdr, 11)))  (set! VarParam(null?, 12) Box(VarParam(null?, 12)))  ((lambda (^numeric-op-dispatcher) (begin (set! VarParam(^numeric-op-dispatcher, 0) Box(VarParam(^numeric-op-dispatcher, 0)))  ((lambda (normalize) (begin (set! VarParam(normalize, 0) Box(VarParam(normalize, 0)))  (set! VarFree(+) (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(*) (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(/) ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7))))))) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) BoxGet(VarParam(x, 0)) ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0)))))))))  ((lambda (^comparator) (begin (set! VarParam(^comparator, 0) Box(VarParam(^comparator, 0)))  (set! VarFree(=) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8)))))  (set! VarFree(<) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 2, 3)) (lambda (a b) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(b, 1) Box(VarParam(b, 1)))  (if BoxGet(VarParam(a, 0)) BoxGet(VarParam(b, 1)) #f)))  #t  (BoxGet(VarBound(map, 2, 4)) (lambda (y) (begin (set! VarParam(y, 0) Box(VarParam(y, 0)))  (BoxGet(VarBound(op, 1, 0)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 0)))))  BoxGet(VarParam(ys, 1))))))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1)))) (if (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1))) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1)))))))))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont64:

;; Finished: Creating CLOSURE of LambdaSimple#64 -> (lambda (flonum? rational? exact->inexact fold-left map _+ _* _/ _= _< car cdr null?) (begin (set! VarParam(flonum?, 0) Box(VarParam(flonum?, 0)))  (set! VarParam(rational?, 1) Box(VarParam(rational?, 1)))  (set! VarParam(exact->inexact, 2) Box(VarParam(exact->inexact, 2)))  (set! VarParam(fold-left, 3) Box(VarParam(fold-left, 3)))  (set! VarParam(map, 4) Box(VarParam(map, 4)))  (set! VarParam(_+, 5) Box(VarParam(_+, 5)))  (set! VarParam(_*, 6) Box(VarParam(_*, 6)))  (set! VarParam(_/, 7) Box(VarParam(_/, 7)))  (set! VarParam(_=, 8) Box(VarParam(_=, 8)))  (set! VarParam(_<, 9) Box(VarParam(_<, 9)))  (set! VarParam(car, 10) Box(VarParam(car, 10)))  (set! VarParam(cdr, 11) Box(VarParam(cdr, 11)))  (set! VarParam(null?, 12) Box(VarParam(null?, 12)))  ((lambda (^numeric-op-dispatcher) (begin (set! VarParam(^numeric-op-dispatcher, 0) Box(VarParam(^numeric-op-dispatcher, 0)))  ((lambda (normalize) (begin (set! VarParam(normalize, 0) Box(VarParam(normalize, 0)))  (set! VarFree(+) (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(*) (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(/) ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7))))))) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) BoxGet(VarParam(x, 0)) ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0)))))))))  ((lambda (^comparator) (begin (set! VarParam(^comparator, 0) Box(VarParam(^comparator, 0)))  (set! VarFree(=) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8)))))  (set! VarFree(<) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 2, 3)) (lambda (a b) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(b, 1) Box(VarParam(b, 1)))  (if BoxGet(VarParam(a, 0)) BoxGet(VarParam(b, 1)) #f)))  #t  (BoxGet(VarBound(map, 2, 4)) (lambda (y) (begin (set! VarParam(y, 0) Box(VarParam(y, 0)))  (BoxGet(VarBound(op, 1, 0)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 0)))))  BoxGet(VarParam(ys, 1))))))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1)))) (if (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1))) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))))))

;; Finished: Evaluating proc to apply (in Applic #63)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic63
; int3
ContinueApplic63:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #63
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#63 of: ((lambda (flonum? rational? exact->inexact fold-left map _+ _* _/ _= _< car cdr null?) (begin (set! VarParam(flonum?, 0) Box(VarParam(flonum?, 0)))  (set! VarParam(rational?, 1) Box(VarParam(rational?, 1)))  (set! VarParam(exact->inexact, 2) Box(VarParam(exact->inexact, 2)))  (set! VarParam(fold-left, 3) Box(VarParam(fold-left, 3)))  (set! VarParam(map, 4) Box(VarParam(map, 4)))  (set! VarParam(_+, 5) Box(VarParam(_+, 5)))  (set! VarParam(_*, 6) Box(VarParam(_*, 6)))  (set! VarParam(_/, 7) Box(VarParam(_/, 7)))  (set! VarParam(_=, 8) Box(VarParam(_=, 8)))  (set! VarParam(_<, 9) Box(VarParam(_<, 9)))  (set! VarParam(car, 10) Box(VarParam(car, 10)))  (set! VarParam(cdr, 11) Box(VarParam(cdr, 11)))  (set! VarParam(null?, 12) Box(VarParam(null?, 12)))  ((lambda (^numeric-op-dispatcher) (begin (set! VarParam(^numeric-op-dispatcher, 0) Box(VarParam(^numeric-op-dispatcher, 0)))  ((lambda (normalize) (begin (set! VarParam(normalize, 0) Box(VarParam(normalize, 0)))  (set! VarFree(+) (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_+, 2, 5)))  0/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(*) (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(normalize, 0, 0)) (BoxGet(VarBound(fold-left, 2, 3)) (BoxGet(VarBound(^numeric-op-dispatcher, 1, 0)) BoxGet(VarBound(_*, 2, 6)))  1/1  BoxGet(VarParam(x, 0)))))))  (set! VarFree(/) ((lambda (/) (begin (set! VarParam(/, 0) Box(VarParam(/, 0)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 3, 12)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(/, 0, 0)) 1/1  BoxGet(VarParam(x, 0))) (BoxGet(VarBound(normalize, 1, 0)) (BoxGet(VarBound(fold-left, 3, 3)) BoxGet(VarBound(/, 0, 0))  BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1))))))))) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_/, 1, 7))))))) (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) BoxGet(VarParam(x, 0)) ((lambda (n) (begin (set! VarParam(n, 0) Box(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (BoxGet(VarBound(_/, 2, 7)) (VarFree(numerator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))  (BoxGet(VarBound(_/, 2, 7)) (VarFree(denominator) BoxGet(VarBound(x, 0, 0)))  BoxGet(VarParam(n, 0)))))) (VarFree(gcd) (VarFree(numerator) BoxGet(VarParam(x, 0)))  (VarFree(denominator) BoxGet(VarParam(x, 0)))))))))  ((lambda (^comparator) (begin (set! VarParam(^comparator, 0) Box(VarParam(^comparator, 0)))  (set! VarFree(=) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_=, 1, 8)))))  (set! VarFree(<) (BoxGet(VarParam(^comparator, 0)) (BoxGet(VarBound(^numeric-op-dispatcher, 0, 0)) BoxGet(VarBound(_<, 1, 9))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 2, 3)) (lambda (a b) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(b, 1) Box(VarParam(b, 1)))  (if BoxGet(VarParam(a, 0)) BoxGet(VarParam(b, 1)) #f)))  #t  (BoxGet(VarBound(map, 2, 4)) (lambda (y) (begin (set! VarParam(y, 0) Box(VarParam(y, 0)))  (BoxGet(VarBound(op, 1, 0)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 0)))))  BoxGet(VarParam(ys, 1))))))))))) (lambda (op) (begin (set! VarParam(op, 0) Box(VarParam(op, 0)))  (lambda (x y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (if (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(y, 1)))) (if (if (BoxGet(VarBound(rational?, 1, 1)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(flonum?, 1, 0)) BoxGet(VarParam(y, 1))) #f) (BoxGet(VarBound(op, 0, 0)) (BoxGet(VarBound(exact->inexact, 1, 2)) BoxGet(VarParam(x, 0)))  BoxGet(VarParam(y, 1))) (BoxGet(VarBound(op, 0, 0)) BoxGet(VarParam(x, 0))  BoxGet(VarParam(y, 1)))))))))))) VarFree(flonum?)  VarFree(rational?)  VarFree(exact->inexact)  VarFree(fold-left)  VarFree(map)  VarFree(+)  VarFree(*)  VarFree(/)  VarFree(=)  VarFree(<)  VarFree(car)  VarFree(cdr)  VarFree(null?))

	call write_sob_if_not_void

;; Starting: Set fvar - to ((lambda (apply + null?) (begin (set! VarParam(apply, 0) Box(VarParam(apply, 0)))  (set! VarParam(+, 1) Box(VarParam(+, 1)))  (set! VarParam(null?, 2) Box(VarParam(null?, 2)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 0, 2)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(+, 0, 1)) 0/1  (VarFree(*) -1/1  BoxGet(VarParam(x, 0)))) (BoxGet(VarBound(+, 0, 1)) BoxGet(VarParam(x, 0))  (VarFree(*) -1/1  (BoxGet(VarBound(apply, 0, 0)) BoxGet(VarBound(+, 0, 1))  BoxGet(VarParam(y, 1)))))))))) VarFree(apply)  VarFree(+)  VarFree(null?))
;; Starting: Perform Applic#117 of: ((lambda (apply + null?) (begin (set! VarParam(apply, 0) Box(VarParam(apply, 0)))  (set! VarParam(+, 1) Box(VarParam(+, 1)))  (set! VarParam(null?, 2) Box(VarParam(null?, 2)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 0, 2)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(+, 0, 1)) 0/1  (VarFree(*) -1/1  BoxGet(VarParam(x, 0)))) (BoxGet(VarBound(+, 0, 1)) BoxGet(VarParam(x, 0))  (VarFree(*) -1/1  (BoxGet(VarBound(apply, 0, 0)) BoxGet(VarBound(+, 0, 1))  BoxGet(VarParam(y, 1)))))))))) VarFree(apply)  VarFree(+)  VarFree(null?))
;; Starting: Argument 2 of Applic statement #117
mov rax, qword [fvar_tbl+8*1]	; mov fvar null? to rax
;; Finished: Argument 2 of Applic statement #117

push rax ; Push argument to stack;; Starting: Argument 1 of Applic statement #117
mov rax, qword [fvar_tbl+8*15]	; mov fvar + to rax
Debug3:
;; Finished: Argument 1 of Applic statement #117

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #117
mov rax, qword [fvar_tbl+8*5]	; mov fvar apply to rax
;; Finished: Argument 0 of Applic statement #117

push rax ; Push argument to stack
push qword 3 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #117)
;; Starting: Creating CLOSURE of LambdaSimple#118 -> (lambda (apply + null?) (begin (set! VarParam(apply, 0) Box(VarParam(apply, 0)))  (set! VarParam(+, 1) Box(VarParam(+, 1)))  (set! VarParam(null?, 2) Box(VarParam(null?, 2)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 0, 2)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(+, 0, 1)) 0/1  (VarFree(*) -1/1  BoxGet(VarParam(x, 0)))) (BoxGet(VarBound(+, 0, 1)) BoxGet(VarParam(x, 0))  (VarFree(*) -1/1  (BoxGet(VarBound(apply, 0, 0)) BoxGet(VarBound(+, 0, 1))  BoxGet(VarParam(y, 1))))))))))
push rbx
; Env Extend Code Section For Closure#118
mov rbx, 0 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend118
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End118

LClosureEnvExtend118:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, -1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 0
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop118:
  jz LClosureEnvExtend_LoopEnd118
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop118

LClosureEnvExtend_LoopEnd118:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd118
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop118:
  jz LClosureEnvExtend_ParamsLoopEnd118

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop118

LClosureEnvExtend_ParamsLoopEnd118:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End118:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode118)
pop rbx
jmp LClosureCont118
LClosureCode118:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #119: (begin (set! VarParam(apply, 0) Box(VarParam(apply, 0)))  (set! VarParam(+, 1) Box(VarParam(+, 1)))  (set! VarParam(null?, 2) Box(VarParam(null?, 2)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 0, 2)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(+, 0, 1)) 0/1  (VarFree(*) -1/1  BoxGet(VarParam(x, 0)))) (BoxGet(VarBound(+, 0, 1)) BoxGet(VarParam(x, 0))  (VarFree(*) -1/1  (BoxGet(VarBound(apply, 0, 0)) BoxGet(VarBound(+, 0, 1))  BoxGet(VarParam(y, 1)))))))))
;; Starting: Item 0 in Seq statement #119
;; Starting: Set VarParam(name=apply, minor=0) with Box(VarParam(apply, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=apply, minor=0) with Box(VarParam(apply, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(apply, 0)
;; Starting: Get VarParam(name=apply, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=apply, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(apply, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=apply, minor=0) with Box(VarParam(apply, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=apply, minor=0) with Box(VarParam(apply, 0))

;; Finished: Item 0 in Seq statement #119


;; Starting: Item 1 in Seq statement #119
;; Starting: Set VarParam(name=+, minor=1) with Box(VarParam(+, 1))
;; Starting: Evaluating rhs for [ Set VarParam(name=+, minor=1) with Box(VarParam(+, 1)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(+, 1)
;; Starting: Get VarParam(name=+, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=+, minor=1)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(+, 1)

;; Finished: Evaluating rhs for [ Set VarParam(name=+, minor=1) with Box(VarParam(+, 1)) ], value is expected in rax

mov PVAR(1), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=+, minor=1) with Box(VarParam(+, 1))

;; Finished: Item 1 in Seq statement #119


;; Starting: Item 2 in Seq statement #119
;; Starting: Set VarParam(name=null?, minor=2) with Box(VarParam(null?, 2))
;; Starting: Evaluating rhs for [ Set VarParam(name=null?, minor=2) with Box(VarParam(null?, 2)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(null?, 2)
;; Starting: Get VarParam(name=null?, minor=2)
mov rax, PVAR(2)
;; Finished: Get VarParam(name=null?, minor=2)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(null?, 2)

;; Finished: Evaluating rhs for [ Set VarParam(name=null?, minor=2) with Box(VarParam(null?, 2)) ], value is expected in rax

mov PVAR(2), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=null?, minor=2) with Box(VarParam(null?, 2))

;; Finished: Item 2 in Seq statement #119


;; Starting: Item 3 in Seq statement #119

;; Finished: Item 3 in Seq statement #119

;; Finished: Seq statement #119: (begin (set! VarParam(apply, 0) Box(VarParam(apply, 0)))  (set! VarParam(+, 1) Box(VarParam(+, 1)))  (set! VarParam(null?, 2) Box(VarParam(null?, 2)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 0, 2)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(+, 0, 1)) 0/1  (VarFree(*) -1/1  BoxGet(VarParam(x, 0)))) (BoxGet(VarBound(+, 0, 1)) BoxGet(VarParam(x, 0))  (VarFree(*) -1/1  (BoxGet(VarBound(apply, 0, 0)) BoxGet(VarBound(+, 0, 1))  BoxGet(VarParam(y, 1)))))))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont118:

;; Finished: Creating CLOSURE of LambdaSimple#118 -> (lambda (apply + null?) (begin (set! VarParam(apply, 0) Box(VarParam(apply, 0)))  (set! VarParam(+, 1) Box(VarParam(+, 1)))  (set! VarParam(null?, 2) Box(VarParam(null?, 2)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 0, 2)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(+, 0, 1)) 0/1  (VarFree(*) -1/1  BoxGet(VarParam(x, 0)))) (BoxGet(VarBound(+, 0, 1)) BoxGet(VarParam(x, 0))  (VarFree(*) -1/1  (BoxGet(VarBound(apply, 0, 0)) BoxGet(VarBound(+, 0, 1))  BoxGet(VarParam(y, 1))))))))))

;; Finished: Evaluating proc to apply (in Applic #117)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic117
; int3
ContinueApplic117:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #117
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#117 of: ((lambda (apply + null?) (begin (set! VarParam(apply, 0) Box(VarParam(apply, 0)))  (set! VarParam(+, 1) Box(VarParam(+, 1)))  (set! VarParam(null?, 2) Box(VarParam(null?, 2)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 0, 2)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(+, 0, 1)) 0/1  (VarFree(*) -1/1  BoxGet(VarParam(x, 0)))) (BoxGet(VarBound(+, 0, 1)) BoxGet(VarParam(x, 0))  (VarFree(*) -1/1  (BoxGet(VarBound(apply, 0, 0)) BoxGet(VarBound(+, 0, 1))  BoxGet(VarParam(y, 1)))))))))) VarFree(apply)  VarFree(+)  VarFree(null?))

mov qword [fvar_tbl+8*26], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar - to ((lambda (apply + null?) (begin (set! VarParam(apply, 0) Box(VarParam(apply, 0)))  (set! VarParam(+, 1) Box(VarParam(+, 1)))  (set! VarParam(null?, 2) Box(VarParam(null?, 2)))  (lambda (x . y) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if (BoxGet(VarBound(null?, 0, 2)) BoxGet(VarParam(y, 1))) (BoxGet(VarBound(+, 0, 1)) 0/1  (VarFree(*) -1/1  BoxGet(VarParam(x, 0)))) (BoxGet(VarBound(+, 0, 1)) BoxGet(VarParam(x, 0))  (VarFree(*) -1/1  (BoxGet(VarBound(apply, 0, 0)) BoxGet(VarBound(+, 0, 1))  BoxGet(VarParam(y, 1)))))))))) VarFree(apply)  VarFree(+)  VarFree(null?))

	call write_sob_if_not_void

;; Starting: Set fvar > to ((lambda (null? not < = fold-left) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(not, 1) Box(VarParam(not, 1)))  (set! VarParam(<, 2) Box(VarParam(<, 2)))  (set! VarParam(=, 3) Box(VarParam(=, 3)))  (set! VarParam(fold-left, 4) Box(VarParam(fold-left, 4)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 0, 4)) (lambda (a y) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if BoxGet(VarParam(a, 0)) (BoxGet(VarBound(not, 1, 1)) (or (BoxGet(VarBound(<, 1, 2)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 1)))  (BoxGet(VarBound(=, 1, 3)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 1))))) #f)))  #t  BoxGet(VarParam(ys, 1))))))) VarFree(null?)  VarFree(not)  VarFree(<)  VarFree(=)  VarFree(fold-left))
;; Starting: Perform Applic#120 of: ((lambda (null? not < = fold-left) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(not, 1) Box(VarParam(not, 1)))  (set! VarParam(<, 2) Box(VarParam(<, 2)))  (set! VarParam(=, 3) Box(VarParam(=, 3)))  (set! VarParam(fold-left, 4) Box(VarParam(fold-left, 4)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 0, 4)) (lambda (a y) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if BoxGet(VarParam(a, 0)) (BoxGet(VarBound(not, 1, 1)) (or (BoxGet(VarBound(<, 1, 2)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 1)))  (BoxGet(VarBound(=, 1, 3)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 1))))) #f)))  #t  BoxGet(VarParam(ys, 1))))))) VarFree(null?)  VarFree(not)  VarFree(<)  VarFree(=)  VarFree(fold-left))
;; Starting: Argument 4 of Applic statement #120
mov rax, qword [fvar_tbl+8*6]	; mov fvar fold-left to rax
;; Finished: Argument 4 of Applic statement #120

push rax ; Push argument to stack;; Starting: Argument 3 of Applic statement #120
mov rax, qword [fvar_tbl+8*21]	; mov fvar = to rax
;; Finished: Argument 3 of Applic statement #120

push rax ; Push argument to stack;; Starting: Argument 2 of Applic statement #120
mov rax, qword [fvar_tbl+8*22]	; mov fvar < to rax
;; Finished: Argument 2 of Applic statement #120

push rax ; Push argument to stack;; Starting: Argument 1 of Applic statement #120
mov rax, qword [fvar_tbl+8*14]	; mov fvar not to rax
;; Finished: Argument 1 of Applic statement #120

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #120
mov rax, qword [fvar_tbl+8*1]	; mov fvar null? to rax
;; Finished: Argument 0 of Applic statement #120

push rax ; Push argument to stack
push qword 5 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #120)
;; Starting: Creating CLOSURE of LambdaSimple#121 -> (lambda (null? not < = fold-left) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(not, 1) Box(VarParam(not, 1)))  (set! VarParam(<, 2) Box(VarParam(<, 2)))  (set! VarParam(=, 3) Box(VarParam(=, 3)))  (set! VarParam(fold-left, 4) Box(VarParam(fold-left, 4)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 0, 4)) (lambda (a y) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if BoxGet(VarParam(a, 0)) (BoxGet(VarBound(not, 1, 1)) (or (BoxGet(VarBound(<, 1, 2)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 1)))  (BoxGet(VarBound(=, 1, 3)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 1))))) #f)))  #t  BoxGet(VarParam(ys, 1)))))))
push rbx
; Env Extend Code Section For Closure#121
mov rbx, 0 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend121
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End121

LClosureEnvExtend121:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, -1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 0
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop121:
  jz LClosureEnvExtend_LoopEnd121
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop121

LClosureEnvExtend_LoopEnd121:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd121
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop121:
  jz LClosureEnvExtend_ParamsLoopEnd121

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop121

LClosureEnvExtend_ParamsLoopEnd121:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End121:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode121)
pop rbx
jmp LClosureCont121
LClosureCode121:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #122: (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(not, 1) Box(VarParam(not, 1)))  (set! VarParam(<, 2) Box(VarParam(<, 2)))  (set! VarParam(=, 3) Box(VarParam(=, 3)))  (set! VarParam(fold-left, 4) Box(VarParam(fold-left, 4)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 0, 4)) (lambda (a y) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if BoxGet(VarParam(a, 0)) (BoxGet(VarBound(not, 1, 1)) (or (BoxGet(VarBound(<, 1, 2)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 1)))  (BoxGet(VarBound(=, 1, 3)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 1))))) #f)))  #t  BoxGet(VarParam(ys, 1))))))
;; Starting: Item 0 in Seq statement #122
;; Starting: Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(null?, 0)
;; Starting: Get VarParam(name=null?, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=null?, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(null?, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=null?, minor=0) with Box(VarParam(null?, 0))

;; Finished: Item 0 in Seq statement #122


;; Starting: Item 1 in Seq statement #122
;; Starting: Set VarParam(name=not, minor=1) with Box(VarParam(not, 1))
;; Starting: Evaluating rhs for [ Set VarParam(name=not, minor=1) with Box(VarParam(not, 1)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(not, 1)
;; Starting: Get VarParam(name=not, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=not, minor=1)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(not, 1)

;; Finished: Evaluating rhs for [ Set VarParam(name=not, minor=1) with Box(VarParam(not, 1)) ], value is expected in rax

mov PVAR(1), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=not, minor=1) with Box(VarParam(not, 1))

;; Finished: Item 1 in Seq statement #122


;; Starting: Item 2 in Seq statement #122
;; Starting: Set VarParam(name=<, minor=2) with Box(VarParam(<, 2))
;; Starting: Evaluating rhs for [ Set VarParam(name=<, minor=2) with Box(VarParam(<, 2)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(<, 2)
;; Starting: Get VarParam(name=<, minor=2)
mov rax, PVAR(2)
;; Finished: Get VarParam(name=<, minor=2)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(<, 2)

;; Finished: Evaluating rhs for [ Set VarParam(name=<, minor=2) with Box(VarParam(<, 2)) ], value is expected in rax

mov PVAR(2), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=<, minor=2) with Box(VarParam(<, 2))

;; Finished: Item 2 in Seq statement #122


;; Starting: Item 3 in Seq statement #122
;; Starting: Set VarParam(name==, minor=3) with Box(VarParam(=, 3))
;; Starting: Evaluating rhs for [ Set VarParam(name==, minor=3) with Box(VarParam(=, 3)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(=, 3)
;; Starting: Get VarParam(name==, minor=3)
mov rax, PVAR(3)
;; Finished: Get VarParam(name==, minor=3)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(=, 3)

;; Finished: Evaluating rhs for [ Set VarParam(name==, minor=3) with Box(VarParam(=, 3)) ], value is expected in rax

mov PVAR(3), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name==, minor=3) with Box(VarParam(=, 3))

;; Finished: Item 3 in Seq statement #122


;; Starting: Item 4 in Seq statement #122
;; Starting: Set VarParam(name=fold-left, minor=4) with Box(VarParam(fold-left, 4))
;; Starting: Evaluating rhs for [ Set VarParam(name=fold-left, minor=4) with Box(VarParam(fold-left, 4)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(fold-left, 4)
;; Starting: Get VarParam(name=fold-left, minor=4)
mov rax, PVAR(4)
;; Finished: Get VarParam(name=fold-left, minor=4)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(fold-left, 4)

;; Finished: Evaluating rhs for [ Set VarParam(name=fold-left, minor=4) with Box(VarParam(fold-left, 4)) ], value is expected in rax

mov PVAR(4), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=fold-left, minor=4) with Box(VarParam(fold-left, 4))

;; Finished: Item 4 in Seq statement #122


;; Starting: Item 5 in Seq statement #122

;; Finished: Item 5 in Seq statement #122

;; Finished: Seq statement #122: (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(not, 1) Box(VarParam(not, 1)))  (set! VarParam(<, 2) Box(VarParam(<, 2)))  (set! VarParam(=, 3) Box(VarParam(=, 3)))  (set! VarParam(fold-left, 4) Box(VarParam(fold-left, 4)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 0, 4)) (lambda (a y) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if BoxGet(VarParam(a, 0)) (BoxGet(VarBound(not, 1, 1)) (or (BoxGet(VarBound(<, 1, 2)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 1)))  (BoxGet(VarBound(=, 1, 3)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 1))))) #f)))  #t  BoxGet(VarParam(ys, 1))))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont121:

;; Finished: Creating CLOSURE of LambdaSimple#121 -> (lambda (null? not < = fold-left) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(not, 1) Box(VarParam(not, 1)))  (set! VarParam(<, 2) Box(VarParam(<, 2)))  (set! VarParam(=, 3) Box(VarParam(=, 3)))  (set! VarParam(fold-left, 4) Box(VarParam(fold-left, 4)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 0, 4)) (lambda (a y) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if BoxGet(VarParam(a, 0)) (BoxGet(VarBound(not, 1, 1)) (or (BoxGet(VarBound(<, 1, 2)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 1)))  (BoxGet(VarBound(=, 1, 3)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 1))))) #f)))  #t  BoxGet(VarParam(ys, 1)))))))

;; Finished: Evaluating proc to apply (in Applic #120)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic120
; int3
ContinueApplic120:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #120
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#120 of: ((lambda (null? not < = fold-left) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(not, 1) Box(VarParam(not, 1)))  (set! VarParam(<, 2) Box(VarParam(<, 2)))  (set! VarParam(=, 3) Box(VarParam(=, 3)))  (set! VarParam(fold-left, 4) Box(VarParam(fold-left, 4)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 0, 4)) (lambda (a y) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if BoxGet(VarParam(a, 0)) (BoxGet(VarBound(not, 1, 1)) (or (BoxGet(VarBound(<, 1, 2)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 1)))  (BoxGet(VarBound(=, 1, 3)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 1))))) #f)))  #t  BoxGet(VarParam(ys, 1))))))) VarFree(null?)  VarFree(not)  VarFree(<)  VarFree(=)  VarFree(fold-left))

mov qword [fvar_tbl+8*27], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar > to ((lambda (null? not < = fold-left) (begin (set! VarParam(null?, 0) Box(VarParam(null?, 0)))  (set! VarParam(not, 1) Box(VarParam(not, 1)))  (set! VarParam(<, 2) Box(VarParam(<, 2)))  (set! VarParam(=, 3) Box(VarParam(=, 3)))  (set! VarParam(fold-left, 4) Box(VarParam(fold-left, 4)))  (lambda (x . ys) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (set! VarParam(ys, 1) Box(VarParam(ys, 1)))  (BoxGet(VarBound(fold-left, 0, 4)) (lambda (a y) (begin (set! VarParam(a, 0) Box(VarParam(a, 0)))  (set! VarParam(y, 1) Box(VarParam(y, 1)))  (if BoxGet(VarParam(a, 0)) (BoxGet(VarBound(not, 1, 1)) (or (BoxGet(VarBound(<, 1, 2)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 1)))  (BoxGet(VarBound(=, 1, 3)) BoxGet(VarBound(x, 0, 0))  BoxGet(VarParam(y, 1))))) #f)))  #t  BoxGet(VarParam(ys, 1))))))) VarFree(null?)  VarFree(not)  VarFree(<)  VarFree(=)  VarFree(fold-left))

	call write_sob_if_not_void

;; Starting: Set fvar gcd to ((lambda (gcd null? car cdr) (begin (set! VarParam(gcd, 0) Box(VarParam(gcd, 0)))  (set! VarParam(null?, 1) Box(VarParam(null?, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  ((lambda (gcd-loop) (begin (set! VarParam(gcd-loop, 0) Box(VarParam(gcd-loop, 0)))  BoxSet(VarParam(gcd-loop, 0), (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))))))  (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(null?, 1, 1)) BoxGet(VarParam(x, 0))) 0/1 (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(car, 1, 2)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(cdr, 1, 3)) BoxGet(VarParam(x, 0))))))))) whatever))) VarFree(gcd)  VarFree(null?)  VarFree(car)  VarFree(cdr))
;; Starting: Perform Applic#123 of: ((lambda (gcd null? car cdr) (begin (set! VarParam(gcd, 0) Box(VarParam(gcd, 0)))  (set! VarParam(null?, 1) Box(VarParam(null?, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  ((lambda (gcd-loop) (begin (set! VarParam(gcd-loop, 0) Box(VarParam(gcd-loop, 0)))  BoxSet(VarParam(gcd-loop, 0), (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))))))  (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(null?, 1, 1)) BoxGet(VarParam(x, 0))) 0/1 (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(car, 1, 2)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(cdr, 1, 3)) BoxGet(VarParam(x, 0))))))))) whatever))) VarFree(gcd)  VarFree(null?)  VarFree(car)  VarFree(cdr))
;; Starting: Argument 3 of Applic statement #123
mov rax, qword [fvar_tbl+8*3]	; mov fvar cdr to rax
;; Finished: Argument 3 of Applic statement #123

push rax ; Push argument to stack;; Starting: Argument 2 of Applic statement #123
mov rax, qword [fvar_tbl+8*2]	; mov fvar car to rax
;; Finished: Argument 2 of Applic statement #123

push rax ; Push argument to stack;; Starting: Argument 1 of Applic statement #123
mov rax, qword [fvar_tbl+8*1]	; mov fvar null? to rax
;; Finished: Argument 1 of Applic statement #123

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #123
mov rax, qword [fvar_tbl+8*20]	; mov fvar gcd to rax
;; Finished: Argument 0 of Applic statement #123

push rax ; Push argument to stack
push qword 4 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #123)
;; Starting: Creating CLOSURE of LambdaSimple#124 -> (lambda (gcd null? car cdr) (begin (set! VarParam(gcd, 0) Box(VarParam(gcd, 0)))  (set! VarParam(null?, 1) Box(VarParam(null?, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  ((lambda (gcd-loop) (begin (set! VarParam(gcd-loop, 0) Box(VarParam(gcd-loop, 0)))  BoxSet(VarParam(gcd-loop, 0), (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))))))  (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(null?, 1, 1)) BoxGet(VarParam(x, 0))) 0/1 (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(car, 1, 2)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(cdr, 1, 3)) BoxGet(VarParam(x, 0))))))))) whatever)))
push rbx
; Env Extend Code Section For Closure#124
mov rbx, 0 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend124
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End124

LClosureEnvExtend124:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, -1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 0
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop124:
  jz LClosureEnvExtend_LoopEnd124
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop124

LClosureEnvExtend_LoopEnd124:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd124
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop124:
  jz LClosureEnvExtend_ParamsLoopEnd124

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop124

LClosureEnvExtend_ParamsLoopEnd124:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End124:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode124)
pop rbx
jmp LClosureCont124
LClosureCode124:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #125: (begin (set! VarParam(gcd, 0) Box(VarParam(gcd, 0)))  (set! VarParam(null?, 1) Box(VarParam(null?, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  ((lambda (gcd-loop) (begin (set! VarParam(gcd-loop, 0) Box(VarParam(gcd-loop, 0)))  BoxSet(VarParam(gcd-loop, 0), (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))))))  (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(null?, 1, 1)) BoxGet(VarParam(x, 0))) 0/1 (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(car, 1, 2)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(cdr, 1, 3)) BoxGet(VarParam(x, 0))))))))) whatever))
;; Starting: Item 0 in Seq statement #125
;; Starting: Set VarParam(name=gcd, minor=0) with Box(VarParam(gcd, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=gcd, minor=0) with Box(VarParam(gcd, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(gcd, 0)
;; Starting: Get VarParam(name=gcd, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=gcd, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(gcd, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=gcd, minor=0) with Box(VarParam(gcd, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=gcd, minor=0) with Box(VarParam(gcd, 0))

;; Finished: Item 0 in Seq statement #125


;; Starting: Item 1 in Seq statement #125
;; Starting: Set VarParam(name=null?, minor=1) with Box(VarParam(null?, 1))
;; Starting: Evaluating rhs for [ Set VarParam(name=null?, minor=1) with Box(VarParam(null?, 1)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(null?, 1)
;; Starting: Get VarParam(name=null?, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=null?, minor=1)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(null?, 1)

;; Finished: Evaluating rhs for [ Set VarParam(name=null?, minor=1) with Box(VarParam(null?, 1)) ], value is expected in rax

mov PVAR(1), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=null?, minor=1) with Box(VarParam(null?, 1))

;; Finished: Item 1 in Seq statement #125


;; Starting: Item 2 in Seq statement #125
;; Starting: Set VarParam(name=car, minor=2) with Box(VarParam(car, 2))
;; Starting: Evaluating rhs for [ Set VarParam(name=car, minor=2) with Box(VarParam(car, 2)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(car, 2)
;; Starting: Get VarParam(name=car, minor=2)
mov rax, PVAR(2)
;; Finished: Get VarParam(name=car, minor=2)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(car, 2)

;; Finished: Evaluating rhs for [ Set VarParam(name=car, minor=2) with Box(VarParam(car, 2)) ], value is expected in rax

mov PVAR(2), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=car, minor=2) with Box(VarParam(car, 2))

;; Finished: Item 2 in Seq statement #125


;; Starting: Item 3 in Seq statement #125
;; Starting: Set VarParam(name=cdr, minor=3) with Box(VarParam(cdr, 3))
;; Starting: Evaluating rhs for [ Set VarParam(name=cdr, minor=3) with Box(VarParam(cdr, 3)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(cdr, 3)
;; Starting: Get VarParam(name=cdr, minor=3)
mov rax, PVAR(3)
;; Finished: Get VarParam(name=cdr, minor=3)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(cdr, 3)

;; Finished: Evaluating rhs for [ Set VarParam(name=cdr, minor=3) with Box(VarParam(cdr, 3)) ], value is expected in rax

mov PVAR(3), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=cdr, minor=3) with Box(VarParam(cdr, 3))

;; Finished: Item 3 in Seq statement #125


;; Starting: Item 4 in Seq statement #125
;; Starting: Perform Applic#126 of: ((lambda (gcd-loop) (begin (set! VarParam(gcd-loop, 0) Box(VarParam(gcd-loop, 0)))  BoxSet(VarParam(gcd-loop, 0), (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))))))  (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(null?, 1, 1)) BoxGet(VarParam(x, 0))) 0/1 (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(car, 1, 2)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(cdr, 1, 3)) BoxGet(VarParam(x, 0))))))))) whatever)
;; Starting: Argument 0 of Applic statement #126
mov rax, const_tbl+23	; mov const whatever to rax
;; Finished: Argument 0 of Applic statement #126

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #126)
;; Starting: Creating CLOSURE of LambdaSimple#127 -> (lambda (gcd-loop) (begin (set! VarParam(gcd-loop, 0) Box(VarParam(gcd-loop, 0)))  BoxSet(VarParam(gcd-loop, 0), (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))))))  (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(null?, 1, 1)) BoxGet(VarParam(x, 0))) 0/1 (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(car, 1, 2)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(cdr, 1, 3)) BoxGet(VarParam(x, 0)))))))))
push rbx
; Env Extend Code Section For Closure#127
mov rbx, 1 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend127
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End127

LClosureEnvExtend127:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 0
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 8
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop127:
  jz LClosureEnvExtend_LoopEnd127
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop127

LClosureEnvExtend_LoopEnd127:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd127
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop127:
  jz LClosureEnvExtend_ParamsLoopEnd127

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop127

LClosureEnvExtend_ParamsLoopEnd127:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End127:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode127)
pop rbx
jmp LClosureCont127
LClosureCode127:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #128: (begin (set! VarParam(gcd-loop, 0) Box(VarParam(gcd-loop, 0)))  BoxSet(VarParam(gcd-loop, 0), (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))))))  (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(null?, 1, 1)) BoxGet(VarParam(x, 0))) 0/1 (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(car, 1, 2)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(cdr, 1, 3)) BoxGet(VarParam(x, 0))))))))
;; Starting: Item 0 in Seq statement #128
;; Starting: Set VarParam(name=gcd-loop, minor=0) with Box(VarParam(gcd-loop, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=gcd-loop, minor=0) with Box(VarParam(gcd-loop, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(gcd-loop, 0)
;; Starting: Get VarParam(name=gcd-loop, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=gcd-loop, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(gcd-loop, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=gcd-loop, minor=0) with Box(VarParam(gcd-loop, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=gcd-loop, minor=0) with Box(VarParam(gcd-loop, 0))

;; Finished: Item 0 in Seq statement #128


;; Starting: Item 1 in Seq statement #128
;; Starting: BoxSet of VarParam(gcd-loop, 0) with (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1)))))
;; Starting: Evaluating rhs for [ BoxSet of VarParam(gcd-loop, 0) with (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))))) ], the VALUE is expected in rax
;; Starting: Creating CLOSURE of LambdaSimple#129 -> (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1)))))
push rbx
; Env Extend Code Section For Closure#129
mov rbx, 2 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend129
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End129

LClosureEnvExtend129:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 16
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop129:
  jz LClosureEnvExtend_LoopEnd129
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop129

LClosureEnvExtend_LoopEnd129:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd129
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop129:
  jz LClosureEnvExtend_ParamsLoopEnd129

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop129

LClosureEnvExtend_ParamsLoopEnd129:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End129:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode129)
pop rbx
jmp LClosureCont129
LClosureCode129:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: If statement (#130): (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))))
Lif130:
;; Starting: Perform Applic#131 of: (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1))
;; Starting: Argument 0 of Applic statement #131
;; Starting: Get VarParam(name=ys, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=ys, minor=1)

;; Finished: Argument 0 of Applic statement #131

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #131)
;; Starting: BoxGet of VarBound(null?, 1, 1)
;; Starting: Evaluating val for [ BoxGet of VarBound(null?, 1, 1) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=null?, major=1, minor=1)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
;; Finished: Get VarBound(name=null?, major=1, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarBound(null?, 1, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(null?, 1, 1)

;; Finished: Evaluating proc to apply (in Applic #131)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic131
; int3
ContinueApplic131:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #131
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#131 of: (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1))

cmp rax, SOB_FALSE_ADDRESS
je Lelse130
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

jmp LendIf130
Lelse130:
;; Starting: Perform Applic#132 of: (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1)))
;; Starting: Argument 1 of Applic statement #132
;; Starting: Perform Applic#135 of: (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))
;; Starting: Argument 0 of Applic statement #135
;; Starting: Get VarParam(name=ys, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=ys, minor=1)

;; Finished: Argument 0 of Applic statement #135

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #135)
;; Starting: BoxGet of VarBound(cdr, 1, 3)
;; Starting: Evaluating val for [ BoxGet of VarBound(cdr, 1, 3) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=cdr, major=1, minor=3)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]
;; Finished: Get VarBound(name=cdr, major=1, minor=3)

;; Finished: Evaluating val for [ BoxGet of VarBound(cdr, 1, 3) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(cdr, 1, 3)

;; Finished: Evaluating proc to apply (in Applic #135)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic135
; int3
ContinueApplic135:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #135
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#135 of: (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))

;; Finished: Argument 1 of Applic statement #132

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #132
;; Starting: Perform Applic#133 of: (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))
;; Starting: Argument 1 of Applic statement #133
;; Starting: Perform Applic#134 of: (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1))
;; Starting: Argument 0 of Applic statement #134
;; Starting: Get VarParam(name=ys, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=ys, minor=1)

;; Finished: Argument 0 of Applic statement #134

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #134)
;; Starting: BoxGet of VarBound(car, 1, 2)
;; Starting: Evaluating val for [ BoxGet of VarBound(car, 1, 2) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=car, major=1, minor=2)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]
;; Finished: Get VarBound(name=car, major=1, minor=2)

;; Finished: Evaluating val for [ BoxGet of VarBound(car, 1, 2) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(car, 1, 2)

;; Finished: Evaluating proc to apply (in Applic #134)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic134
; int3
ContinueApplic134:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #134
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#134 of: (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1))

;; Finished: Argument 1 of Applic statement #133

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #133
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Argument 0 of Applic statement #133

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #133)
;; Starting: BoxGet of VarBound(gcd, 1, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(gcd, 1, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=gcd, major=1, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=gcd, major=1, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(gcd, 1, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(gcd, 1, 0)

;; Finished: Evaluating proc to apply (in Applic #133)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic133
; int3
ContinueApplic133:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #133
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#133 of: (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))

;; Finished: Argument 0 of Applic statement #132

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #132)
;; Starting: BoxGet of VarBound(gcd-loop, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(gcd-loop, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=gcd-loop, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=gcd-loop, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(gcd-loop, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(gcd-loop, 0, 0)

;; Finished: Evaluating proc to apply (in Applic #132)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic132
; int3
ContinueApplic132:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #132
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#132 of: (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1)))

LendIf130:
;; Finished: If statement (#130): (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont129:

;; Finished: Creating CLOSURE of LambdaSimple#129 -> (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1)))))

;; Finished: Evaluating rhs for [ BoxSet of VarParam(gcd-loop, 0) with (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))))) ], the VALUE is expected in rax

; Save the value of rhs
push rax
;; Starting: Evaluating var for [ BoxSet of VarParam(gcd-loop, 0) with (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))))) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=gcd-loop, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=gcd-loop, minor=0)

;; Finished: Evaluating var for [ BoxSet of VarParam(gcd-loop, 0) with (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))))) ], the VALUE is expected in rax

; in RAX there is a address of a box, put the value we saved on stack earlier (from rhs) inside it
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;; Finished: BoxSet of VarParam(gcd-loop, 0) with (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1)))))

;; Finished: Item 1 in Seq statement #128


;; Starting: Item 2 in Seq statement #128

;; Finished: Item 2 in Seq statement #128

;; Finished: Seq statement #128: (begin (set! VarParam(gcd-loop, 0) Box(VarParam(gcd-loop, 0)))  BoxSet(VarParam(gcd-loop, 0), (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))))))  (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(null?, 1, 1)) BoxGet(VarParam(x, 0))) 0/1 (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(car, 1, 2)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(cdr, 1, 3)) BoxGet(VarParam(x, 0))))))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont127:

;; Finished: Creating CLOSURE of LambdaSimple#127 -> (lambda (gcd-loop) (begin (set! VarParam(gcd-loop, 0) Box(VarParam(gcd-loop, 0)))  BoxSet(VarParam(gcd-loop, 0), (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))))))  (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(null?, 1, 1)) BoxGet(VarParam(x, 0))) 0/1 (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(car, 1, 2)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(cdr, 1, 3)) BoxGet(VarParam(x, 0)))))))))

;; Finished: Evaluating proc to apply (in Applic #126)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic126
; int3
ContinueApplic126:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #126
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#126 of: ((lambda (gcd-loop) (begin (set! VarParam(gcd-loop, 0) Box(VarParam(gcd-loop, 0)))  BoxSet(VarParam(gcd-loop, 0), (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))))))  (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(null?, 1, 1)) BoxGet(VarParam(x, 0))) 0/1 (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(car, 1, 2)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(cdr, 1, 3)) BoxGet(VarParam(x, 0))))))))) whatever)

;; Finished: Item 4 in Seq statement #125

;; Finished: Seq statement #125: (begin (set! VarParam(gcd, 0) Box(VarParam(gcd, 0)))  (set! VarParam(null?, 1) Box(VarParam(null?, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  ((lambda (gcd-loop) (begin (set! VarParam(gcd-loop, 0) Box(VarParam(gcd-loop, 0)))  BoxSet(VarParam(gcd-loop, 0), (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))))))  (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(null?, 1, 1)) BoxGet(VarParam(x, 0))) 0/1 (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(car, 1, 2)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(cdr, 1, 3)) BoxGet(VarParam(x, 0))))))))) whatever))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont124:

;; Finished: Creating CLOSURE of LambdaSimple#124 -> (lambda (gcd null? car cdr) (begin (set! VarParam(gcd, 0) Box(VarParam(gcd, 0)))  (set! VarParam(null?, 1) Box(VarParam(null?, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  ((lambda (gcd-loop) (begin (set! VarParam(gcd-loop, 0) Box(VarParam(gcd-loop, 0)))  BoxSet(VarParam(gcd-loop, 0), (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))))))  (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(null?, 1, 1)) BoxGet(VarParam(x, 0))) 0/1 (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(car, 1, 2)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(cdr, 1, 3)) BoxGet(VarParam(x, 0))))))))) whatever)))

;; Finished: Evaluating proc to apply (in Applic #123)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic123
; int3
ContinueApplic123:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #123
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#123 of: ((lambda (gcd null? car cdr) (begin (set! VarParam(gcd, 0) Box(VarParam(gcd, 0)))  (set! VarParam(null?, 1) Box(VarParam(null?, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  ((lambda (gcd-loop) (begin (set! VarParam(gcd-loop, 0) Box(VarParam(gcd-loop, 0)))  BoxSet(VarParam(gcd-loop, 0), (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))))))  (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(null?, 1, 1)) BoxGet(VarParam(x, 0))) 0/1 (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(car, 1, 2)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(cdr, 1, 3)) BoxGet(VarParam(x, 0))))))))) whatever))) VarFree(gcd)  VarFree(null?)  VarFree(car)  VarFree(cdr))

mov qword [fvar_tbl+8*20], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar gcd to ((lambda (gcd null? car cdr) (begin (set! VarParam(gcd, 0) Box(VarParam(gcd, 0)))  (set! VarParam(null?, 1) Box(VarParam(null?, 1)))  (set! VarParam(car, 2) Box(VarParam(car, 2)))  (set! VarParam(cdr, 3) Box(VarParam(cdr, 3)))  ((lambda (gcd-loop) (begin (set! VarParam(gcd-loop, 0) Box(VarParam(gcd-loop, 0)))  BoxSet(VarParam(gcd-loop, 0), (lambda (x ys) (if (BoxGet(VarBound(null?, 1, 1)) VarParam(ys, 1)) VarParam(x, 0) (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(gcd, 1, 0)) VarParam(x, 0)  (BoxGet(VarBound(car, 1, 2)) VarParam(ys, 1)))  (BoxGet(VarBound(cdr, 1, 3)) VarParam(ys, 1))))))  (lambda x (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(null?, 1, 1)) BoxGet(VarParam(x, 0))) 0/1 (BoxGet(VarBound(gcd-loop, 0, 0)) (BoxGet(VarBound(car, 1, 2)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(cdr, 1, 3)) BoxGet(VarParam(x, 0))))))))) whatever))) VarFree(gcd)  VarFree(null?)  VarFree(car)  VarFree(cdr))

	call write_sob_if_not_void

;; Starting: Set fvar zero? to ((lambda (=) (begin (set! VarParam(=, 0) Box(VarParam(=, 0)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(=, 0, 0)) BoxGet(VarParam(x, 0))  0/1))))) VarFree(=))
;; Starting: Perform Applic#136 of: ((lambda (=) (begin (set! VarParam(=, 0) Box(VarParam(=, 0)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(=, 0, 0)) BoxGet(VarParam(x, 0))  0/1))))) VarFree(=))
;; Starting: Argument 0 of Applic statement #136
mov rax, qword [fvar_tbl+8*21]	; mov fvar = to rax
;; Finished: Argument 0 of Applic statement #136

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #136)
;; Starting: Creating CLOSURE of LambdaSimple#137 -> (lambda (=) (begin (set! VarParam(=, 0) Box(VarParam(=, 0)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(=, 0, 0)) BoxGet(VarParam(x, 0))  0/1)))))
push rbx
; Env Extend Code Section For Closure#137
mov rbx, 0 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend137
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End137

LClosureEnvExtend137:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, -1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 0
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop137:
  jz LClosureEnvExtend_LoopEnd137
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop137

LClosureEnvExtend_LoopEnd137:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd137
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop137:
  jz LClosureEnvExtend_ParamsLoopEnd137

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop137

LClosureEnvExtend_ParamsLoopEnd137:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End137:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode137)
pop rbx
jmp LClosureCont137
LClosureCode137:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #138: (begin (set! VarParam(=, 0) Box(VarParam(=, 0)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(=, 0, 0)) BoxGet(VarParam(x, 0))  0/1))))
;; Starting: Item 0 in Seq statement #138
;; Starting: Set VarParam(name==, minor=0) with Box(VarParam(=, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name==, minor=0) with Box(VarParam(=, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(=, 0)
;; Starting: Get VarParam(name==, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name==, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(=, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name==, minor=0) with Box(VarParam(=, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name==, minor=0) with Box(VarParam(=, 0))

;; Finished: Item 0 in Seq statement #138


;; Starting: Item 1 in Seq statement #138
;; Starting: Creating CLOSURE of LambdaSimple#139 -> (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(=, 0, 0)) BoxGet(VarParam(x, 0))  0/1)))
push rbx
; Env Extend Code Section For Closure#139
mov rbx, 1 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend139
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End139

LClosureEnvExtend139:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 0
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 8
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop139:
  jz LClosureEnvExtend_LoopEnd139
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop139

LClosureEnvExtend_LoopEnd139:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd139
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop139:
  jz LClosureEnvExtend_ParamsLoopEnd139

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop139

LClosureEnvExtend_ParamsLoopEnd139:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End139:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode139)
pop rbx
jmp LClosureCont139
LClosureCode139:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #140: (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(=, 0, 0)) BoxGet(VarParam(x, 0))  0/1))
;; Starting: Item 0 in Seq statement #140
;; Starting: Set VarParam(name=x, minor=0) with Box(VarParam(x, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=x, minor=0) with Box(VarParam(x, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(x, 0)
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(x, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=x, minor=0) with Box(VarParam(x, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=x, minor=0) with Box(VarParam(x, 0))

;; Finished: Item 0 in Seq statement #140


;; Starting: Item 1 in Seq statement #140
;; Starting: Perform Applic#141 of: (BoxGet(VarBound(=, 0, 0)) BoxGet(VarParam(x, 0))  0/1)
;; Starting: Argument 1 of Applic statement #141
mov rax, const_tbl+34	; mov const 0/1 to rax
;; Finished: Argument 1 of Applic statement #141

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #141
;; Starting: BoxGet of VarParam(x, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(x, 0)

;; Finished: Argument 0 of Applic statement #141

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #141)
;; Starting: BoxGet of VarBound(=, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(=, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name==, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name==, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(=, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(=, 0, 0)

;; Finished: Evaluating proc to apply (in Applic #141)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic141
; int3
ContinueApplic141:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #141
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#141 of: (BoxGet(VarBound(=, 0, 0)) BoxGet(VarParam(x, 0))  0/1)

;; Finished: Item 1 in Seq statement #140

;; Finished: Seq statement #140: (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(=, 0, 0)) BoxGet(VarParam(x, 0))  0/1))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont139:

;; Finished: Creating CLOSURE of LambdaSimple#139 -> (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(=, 0, 0)) BoxGet(VarParam(x, 0))  0/1)))

;; Finished: Item 1 in Seq statement #138

;; Finished: Seq statement #138: (begin (set! VarParam(=, 0) Box(VarParam(=, 0)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(=, 0, 0)) BoxGet(VarParam(x, 0))  0/1))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont137:

;; Finished: Creating CLOSURE of LambdaSimple#137 -> (lambda (=) (begin (set! VarParam(=, 0) Box(VarParam(=, 0)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(=, 0, 0)) BoxGet(VarParam(x, 0))  0/1)))))

;; Finished: Evaluating proc to apply (in Applic #136)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic136
; int3
ContinueApplic136:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #136
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#136 of: ((lambda (=) (begin (set! VarParam(=, 0) Box(VarParam(=, 0)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(=, 0, 0)) BoxGet(VarParam(x, 0))  0/1))))) VarFree(=))

mov qword [fvar_tbl+8*28], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar zero? to ((lambda (=) (begin (set! VarParam(=, 0) Box(VarParam(=, 0)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (BoxGet(VarBound(=, 0, 0)) BoxGet(VarParam(x, 0))  0/1))))) VarFree(=))

	call write_sob_if_not_void

;; Starting: Set fvar integer? to ((lambda (rational? = denominator) (begin (set! VarParam(rational?, 0) Box(VarParam(rational?, 0)))  (set! VarParam(=, 1) Box(VarParam(=, 1)))  (set! VarParam(denominator, 2) Box(VarParam(denominator, 2)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(rational?, 0, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(=, 0, 1)) (BoxGet(VarBound(denominator, 0, 2)) BoxGet(VarParam(x, 0)))  1/1) #f))))) VarFree(rational?)  VarFree(=)  VarFree(denominator))
;; Starting: Perform Applic#142 of: ((lambda (rational? = denominator) (begin (set! VarParam(rational?, 0) Box(VarParam(rational?, 0)))  (set! VarParam(=, 1) Box(VarParam(=, 1)))  (set! VarParam(denominator, 2) Box(VarParam(denominator, 2)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(rational?, 0, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(=, 0, 1)) (BoxGet(VarBound(denominator, 0, 2)) BoxGet(VarParam(x, 0)))  1/1) #f))))) VarFree(rational?)  VarFree(=)  VarFree(denominator))
;; Starting: Argument 2 of Applic statement #142
mov rax, qword [fvar_tbl+8*19]	; mov fvar denominator to rax
;; Finished: Argument 2 of Applic statement #142

push rax ; Push argument to stack;; Starting: Argument 1 of Applic statement #142
mov rax, qword [fvar_tbl+8*21]	; mov fvar = to rax
;; Finished: Argument 1 of Applic statement #142

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #142
mov rax, qword [fvar_tbl+8*24]	; mov fvar rational? to rax
;; Finished: Argument 0 of Applic statement #142

push rax ; Push argument to stack
push qword 3 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #142)
;; Starting: Creating CLOSURE of LambdaSimple#143 -> (lambda (rational? = denominator) (begin (set! VarParam(rational?, 0) Box(VarParam(rational?, 0)))  (set! VarParam(=, 1) Box(VarParam(=, 1)))  (set! VarParam(denominator, 2) Box(VarParam(denominator, 2)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(rational?, 0, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(=, 0, 1)) (BoxGet(VarBound(denominator, 0, 2)) BoxGet(VarParam(x, 0)))  1/1) #f)))))
push rbx
; Env Extend Code Section For Closure#143
mov rbx, 0 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend143
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End143

LClosureEnvExtend143:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, -1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 0
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop143:
  jz LClosureEnvExtend_LoopEnd143
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop143

LClosureEnvExtend_LoopEnd143:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd143
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop143:
  jz LClosureEnvExtend_ParamsLoopEnd143

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop143

LClosureEnvExtend_ParamsLoopEnd143:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End143:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode143)
pop rbx
jmp LClosureCont143
LClosureCode143:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #144: (begin (set! VarParam(rational?, 0) Box(VarParam(rational?, 0)))  (set! VarParam(=, 1) Box(VarParam(=, 1)))  (set! VarParam(denominator, 2) Box(VarParam(denominator, 2)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(rational?, 0, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(=, 0, 1)) (BoxGet(VarBound(denominator, 0, 2)) BoxGet(VarParam(x, 0)))  1/1) #f))))
;; Starting: Item 0 in Seq statement #144
;; Starting: Set VarParam(name=rational?, minor=0) with Box(VarParam(rational?, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=rational?, minor=0) with Box(VarParam(rational?, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(rational?, 0)
;; Starting: Get VarParam(name=rational?, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=rational?, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(rational?, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=rational?, minor=0) with Box(VarParam(rational?, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=rational?, minor=0) with Box(VarParam(rational?, 0))

;; Finished: Item 0 in Seq statement #144


;; Starting: Item 1 in Seq statement #144
;; Starting: Set VarParam(name==, minor=1) with Box(VarParam(=, 1))
;; Starting: Evaluating rhs for [ Set VarParam(name==, minor=1) with Box(VarParam(=, 1)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(=, 1)
;; Starting: Get VarParam(name==, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name==, minor=1)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(=, 1)

;; Finished: Evaluating rhs for [ Set VarParam(name==, minor=1) with Box(VarParam(=, 1)) ], value is expected in rax

mov PVAR(1), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name==, minor=1) with Box(VarParam(=, 1))

;; Finished: Item 1 in Seq statement #144


;; Starting: Item 2 in Seq statement #144
;; Starting: Set VarParam(name=denominator, minor=2) with Box(VarParam(denominator, 2))
;; Starting: Evaluating rhs for [ Set VarParam(name=denominator, minor=2) with Box(VarParam(denominator, 2)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(denominator, 2)
;; Starting: Get VarParam(name=denominator, minor=2)
mov rax, PVAR(2)
;; Finished: Get VarParam(name=denominator, minor=2)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(denominator, 2)

;; Finished: Evaluating rhs for [ Set VarParam(name=denominator, minor=2) with Box(VarParam(denominator, 2)) ], value is expected in rax

mov PVAR(2), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=denominator, minor=2) with Box(VarParam(denominator, 2))

;; Finished: Item 2 in Seq statement #144


;; Starting: Item 3 in Seq statement #144
;; Starting: Creating CLOSURE of LambdaSimple#145 -> (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(rational?, 0, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(=, 0, 1)) (BoxGet(VarBound(denominator, 0, 2)) BoxGet(VarParam(x, 0)))  1/1) #f)))
push rbx
; Env Extend Code Section For Closure#145
mov rbx, 1 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend145
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End145

LClosureEnvExtend145:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 0
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 8
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop145:
  jz LClosureEnvExtend_LoopEnd145
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop145

LClosureEnvExtend_LoopEnd145:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd145
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop145:
  jz LClosureEnvExtend_ParamsLoopEnd145

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop145

LClosureEnvExtend_ParamsLoopEnd145:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End145:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode145)
pop rbx
jmp LClosureCont145
LClosureCode145:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #146: (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(rational?, 0, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(=, 0, 1)) (BoxGet(VarBound(denominator, 0, 2)) BoxGet(VarParam(x, 0)))  1/1) #f))
;; Starting: Item 0 in Seq statement #146
;; Starting: Set VarParam(name=x, minor=0) with Box(VarParam(x, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=x, minor=0) with Box(VarParam(x, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(x, 0)
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(x, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=x, minor=0) with Box(VarParam(x, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=x, minor=0) with Box(VarParam(x, 0))

;; Finished: Item 0 in Seq statement #146


;; Starting: Item 1 in Seq statement #146
;; Starting: If statement (#147): (if (BoxGet(VarBound(rational?, 0, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(=, 0, 1)) (BoxGet(VarBound(denominator, 0, 2)) BoxGet(VarParam(x, 0)))  1/1) #f)
Lif147:
;; Starting: Perform Applic#148 of: (BoxGet(VarBound(rational?, 0, 0)) BoxGet(VarParam(x, 0)))
;; Starting: Argument 0 of Applic statement #148
;; Starting: BoxGet of VarParam(x, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(x, 0)

;; Finished: Argument 0 of Applic statement #148

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #148)
;; Starting: BoxGet of VarBound(rational?, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(rational?, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=rational?, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=rational?, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(rational?, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(rational?, 0, 0)

;; Finished: Evaluating proc to apply (in Applic #148)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic148
; int3
ContinueApplic148:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #148
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#148 of: (BoxGet(VarBound(rational?, 0, 0)) BoxGet(VarParam(x, 0)))

cmp rax, SOB_FALSE_ADDRESS
je Lelse147
;; Starting: Perform Applic#149 of: (BoxGet(VarBound(=, 0, 1)) (BoxGet(VarBound(denominator, 0, 2)) BoxGet(VarParam(x, 0)))  1/1)
;; Starting: Argument 1 of Applic statement #149
mov rax, const_tbl+51	; mov const 1/1 to rax
;; Finished: Argument 1 of Applic statement #149

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #149
;; Starting: Perform Applic#150 of: (BoxGet(VarBound(denominator, 0, 2)) BoxGet(VarParam(x, 0)))
;; Starting: Argument 0 of Applic statement #150
;; Starting: BoxGet of VarParam(x, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(x, 0)

;; Finished: Argument 0 of Applic statement #150

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #150)
;; Starting: BoxGet of VarBound(denominator, 0, 2)
;; Starting: Evaluating val for [ BoxGet of VarBound(denominator, 0, 2) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=denominator, major=0, minor=2)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 2]
;; Finished: Get VarBound(name=denominator, major=0, minor=2)

;; Finished: Evaluating val for [ BoxGet of VarBound(denominator, 0, 2) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(denominator, 0, 2)

;; Finished: Evaluating proc to apply (in Applic #150)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic150
; int3
ContinueApplic150:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #150
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#150 of: (BoxGet(VarBound(denominator, 0, 2)) BoxGet(VarParam(x, 0)))

;; Finished: Argument 0 of Applic statement #149

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #149)
;; Starting: BoxGet of VarBound(=, 0, 1)
;; Starting: Evaluating val for [ BoxGet of VarBound(=, 0, 1) ], the VALUE is expected in rax
;; Starting: Get VarBound(name==, major=0, minor=1)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]
;; Finished: Get VarBound(name==, major=0, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarBound(=, 0, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(=, 0, 1)

;; Finished: Evaluating proc to apply (in Applic #149)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic149
; int3
ContinueApplic149:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #149
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#149 of: (BoxGet(VarBound(=, 0, 1)) (BoxGet(VarBound(denominator, 0, 2)) BoxGet(VarParam(x, 0)))  1/1)

jmp LendIf147
Lelse147:
mov rax, const_tbl+2	; mov const #f to rax
LendIf147:
;; Finished: If statement (#147): (if (BoxGet(VarBound(rational?, 0, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(=, 0, 1)) (BoxGet(VarBound(denominator, 0, 2)) BoxGet(VarParam(x, 0)))  1/1) #f)

;; Finished: Item 1 in Seq statement #146

;; Finished: Seq statement #146: (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(rational?, 0, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(=, 0, 1)) (BoxGet(VarBound(denominator, 0, 2)) BoxGet(VarParam(x, 0)))  1/1) #f))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont145:

;; Finished: Creating CLOSURE of LambdaSimple#145 -> (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(rational?, 0, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(=, 0, 1)) (BoxGet(VarBound(denominator, 0, 2)) BoxGet(VarParam(x, 0)))  1/1) #f)))

;; Finished: Item 3 in Seq statement #144

;; Finished: Seq statement #144: (begin (set! VarParam(rational?, 0) Box(VarParam(rational?, 0)))  (set! VarParam(=, 1) Box(VarParam(=, 1)))  (set! VarParam(denominator, 2) Box(VarParam(denominator, 2)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(rational?, 0, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(=, 0, 1)) (BoxGet(VarBound(denominator, 0, 2)) BoxGet(VarParam(x, 0)))  1/1) #f))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont143:

;; Finished: Creating CLOSURE of LambdaSimple#143 -> (lambda (rational? = denominator) (begin (set! VarParam(rational?, 0) Box(VarParam(rational?, 0)))  (set! VarParam(=, 1) Box(VarParam(=, 1)))  (set! VarParam(denominator, 2) Box(VarParam(denominator, 2)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(rational?, 0, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(=, 0, 1)) (BoxGet(VarBound(denominator, 0, 2)) BoxGet(VarParam(x, 0)))  1/1) #f)))))

;; Finished: Evaluating proc to apply (in Applic #142)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic142
; int3
ContinueApplic142:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #142
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#142 of: ((lambda (rational? = denominator) (begin (set! VarParam(rational?, 0) Box(VarParam(rational?, 0)))  (set! VarParam(=, 1) Box(VarParam(=, 1)))  (set! VarParam(denominator, 2) Box(VarParam(denominator, 2)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(rational?, 0, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(=, 0, 1)) (BoxGet(VarBound(denominator, 0, 2)) BoxGet(VarParam(x, 0)))  1/1) #f))))) VarFree(rational?)  VarFree(=)  VarFree(denominator))

mov qword [fvar_tbl+8*29], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar integer? to ((lambda (rational? = denominator) (begin (set! VarParam(rational?, 0) Box(VarParam(rational?, 0)))  (set! VarParam(=, 1) Box(VarParam(=, 1)))  (set! VarParam(denominator, 2) Box(VarParam(denominator, 2)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (if (BoxGet(VarBound(rational?, 0, 0)) BoxGet(VarParam(x, 0))) (BoxGet(VarBound(=, 0, 1)) (BoxGet(VarBound(denominator, 0, 2)) BoxGet(VarParam(x, 0)))  1/1) #f))))) VarFree(rational?)  VarFree(=)  VarFree(denominator))

	call write_sob_if_not_void

;; Starting: Set fvar number? to ((lambda (flonum? rational?) (begin (set! VarParam(flonum?, 0) Box(VarParam(flonum?, 0)))  (set! VarParam(rational?, 1) Box(VarParam(rational?, 1)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (or (BoxGet(VarBound(flonum?, 0, 0)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(rational?, 0, 1)) BoxGet(VarParam(x, 0)))))))) VarFree(flonum?)  VarFree(rational?))
;; Starting: Perform Applic#151 of: ((lambda (flonum? rational?) (begin (set! VarParam(flonum?, 0) Box(VarParam(flonum?, 0)))  (set! VarParam(rational?, 1) Box(VarParam(rational?, 1)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (or (BoxGet(VarBound(flonum?, 0, 0)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(rational?, 0, 1)) BoxGet(VarParam(x, 0)))))))) VarFree(flonum?)  VarFree(rational?))
;; Starting: Argument 1 of Applic statement #151
mov rax, qword [fvar_tbl+8*24]	; mov fvar rational? to rax
;; Finished: Argument 1 of Applic statement #151

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #151
mov rax, qword [fvar_tbl+8*23]	; mov fvar flonum? to rax
;; Finished: Argument 0 of Applic statement #151

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #151)
;; Starting: Creating CLOSURE of LambdaSimple#152 -> (lambda (flonum? rational?) (begin (set! VarParam(flonum?, 0) Box(VarParam(flonum?, 0)))  (set! VarParam(rational?, 1) Box(VarParam(rational?, 1)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (or (BoxGet(VarBound(flonum?, 0, 0)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(rational?, 0, 1)) BoxGet(VarParam(x, 0))))))))
push rbx
; Env Extend Code Section For Closure#152
mov rbx, 0 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend152
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End152

LClosureEnvExtend152:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, -1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 0
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop152:
  jz LClosureEnvExtend_LoopEnd152
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop152

LClosureEnvExtend_LoopEnd152:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd152
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop152:
  jz LClosureEnvExtend_ParamsLoopEnd152

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop152

LClosureEnvExtend_ParamsLoopEnd152:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End152:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode152)
pop rbx
jmp LClosureCont152
LClosureCode152:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #153: (begin (set! VarParam(flonum?, 0) Box(VarParam(flonum?, 0)))  (set! VarParam(rational?, 1) Box(VarParam(rational?, 1)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (or (BoxGet(VarBound(flonum?, 0, 0)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(rational?, 0, 1)) BoxGet(VarParam(x, 0)))))))
;; Starting: Item 0 in Seq statement #153
;; Starting: Set VarParam(name=flonum?, minor=0) with Box(VarParam(flonum?, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=flonum?, minor=0) with Box(VarParam(flonum?, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(flonum?, 0)
;; Starting: Get VarParam(name=flonum?, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=flonum?, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(flonum?, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=flonum?, minor=0) with Box(VarParam(flonum?, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=flonum?, minor=0) with Box(VarParam(flonum?, 0))

;; Finished: Item 0 in Seq statement #153


;; Starting: Item 1 in Seq statement #153
;; Starting: Set VarParam(name=rational?, minor=1) with Box(VarParam(rational?, 1))
;; Starting: Evaluating rhs for [ Set VarParam(name=rational?, minor=1) with Box(VarParam(rational?, 1)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(rational?, 1)
;; Starting: Get VarParam(name=rational?, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=rational?, minor=1)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(rational?, 1)

;; Finished: Evaluating rhs for [ Set VarParam(name=rational?, minor=1) with Box(VarParam(rational?, 1)) ], value is expected in rax

mov PVAR(1), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=rational?, minor=1) with Box(VarParam(rational?, 1))

;; Finished: Item 1 in Seq statement #153


;; Starting: Item 2 in Seq statement #153
;; Starting: Creating CLOSURE of LambdaSimple#154 -> (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (or (BoxGet(VarBound(flonum?, 0, 0)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(rational?, 0, 1)) BoxGet(VarParam(x, 0))))))
push rbx
; Env Extend Code Section For Closure#154
mov rbx, 1 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend154
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End154

LClosureEnvExtend154:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 0
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 8
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop154:
  jz LClosureEnvExtend_LoopEnd154
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop154

LClosureEnvExtend_LoopEnd154:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd154
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop154:
  jz LClosureEnvExtend_ParamsLoopEnd154

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop154

LClosureEnvExtend_ParamsLoopEnd154:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End154:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode154)
pop rbx
jmp LClosureCont154
LClosureCode154:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #155: (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (or (BoxGet(VarBound(flonum?, 0, 0)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(rational?, 0, 1)) BoxGet(VarParam(x, 0)))))
;; Starting: Item 0 in Seq statement #155
;; Starting: Set VarParam(name=x, minor=0) with Box(VarParam(x, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=x, minor=0) with Box(VarParam(x, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(x, 0)
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(x, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=x, minor=0) with Box(VarParam(x, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=x, minor=0) with Box(VarParam(x, 0))

;; Finished: Item 0 in Seq statement #155


;; Starting: Item 1 in Seq statement #155
;; Starting: Or statement (#156): (or (BoxGet(VarBound(flonum?, 0, 0)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(rational?, 0, 1)) BoxGet(VarParam(x, 0))))
Lor156: 
;; Starting: Item 0 in Or statement #156
;; Starting: Perform Applic#157 of: (BoxGet(VarBound(flonum?, 0, 0)) BoxGet(VarParam(x, 0)))
;; Starting: Argument 0 of Applic statement #157
;; Starting: BoxGet of VarParam(x, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(x, 0)

;; Finished: Argument 0 of Applic statement #157

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #157)
;; Starting: BoxGet of VarBound(flonum?, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(flonum?, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=flonum?, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=flonum?, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(flonum?, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(flonum?, 0, 0)

;; Finished: Evaluating proc to apply (in Applic #157)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic157
; int3
ContinueApplic157:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #157
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#157 of: (BoxGet(VarBound(flonum?, 0, 0)) BoxGet(VarParam(x, 0)))

;; Finished: Item 0 in Or statement #156
cmp rax, SOB_FALSE_ADDRESS 
jne LendOr156;; Starting: Item 1 in Or statement #156
;; Starting: Perform Applic#158 of: (BoxGet(VarBound(rational?, 0, 1)) BoxGet(VarParam(x, 0)))
;; Starting: Argument 0 of Applic statement #158
;; Starting: BoxGet of VarParam(x, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(x, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(x, 0)

;; Finished: Argument 0 of Applic statement #158

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #158)
;; Starting: BoxGet of VarBound(rational?, 0, 1)
;; Starting: Evaluating val for [ BoxGet of VarBound(rational?, 0, 1) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=rational?, major=0, minor=1)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]
;; Finished: Get VarBound(name=rational?, major=0, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarBound(rational?, 0, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(rational?, 0, 1)

;; Finished: Evaluating proc to apply (in Applic #158)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic158
; int3
ContinueApplic158:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #158
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#158 of: (BoxGet(VarBound(rational?, 0, 1)) BoxGet(VarParam(x, 0)))

;; Finished: Item 1 in Or statement #156
 
LendOr156:
;; Finished: Or statement (#156): (or (BoxGet(VarBound(flonum?, 0, 0)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(rational?, 0, 1)) BoxGet(VarParam(x, 0))))

;; Finished: Item 1 in Seq statement #155

;; Finished: Seq statement #155: (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (or (BoxGet(VarBound(flonum?, 0, 0)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(rational?, 0, 1)) BoxGet(VarParam(x, 0)))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont154:

;; Finished: Creating CLOSURE of LambdaSimple#154 -> (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (or (BoxGet(VarBound(flonum?, 0, 0)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(rational?, 0, 1)) BoxGet(VarParam(x, 0))))))

;; Finished: Item 2 in Seq statement #153

;; Finished: Seq statement #153: (begin (set! VarParam(flonum?, 0) Box(VarParam(flonum?, 0)))  (set! VarParam(rational?, 1) Box(VarParam(rational?, 1)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (or (BoxGet(VarBound(flonum?, 0, 0)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(rational?, 0, 1)) BoxGet(VarParam(x, 0)))))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont152:

;; Finished: Creating CLOSURE of LambdaSimple#152 -> (lambda (flonum? rational?) (begin (set! VarParam(flonum?, 0) Box(VarParam(flonum?, 0)))  (set! VarParam(rational?, 1) Box(VarParam(rational?, 1)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (or (BoxGet(VarBound(flonum?, 0, 0)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(rational?, 0, 1)) BoxGet(VarParam(x, 0))))))))

;; Finished: Evaluating proc to apply (in Applic #151)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic151
; int3
ContinueApplic151:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #151
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#151 of: ((lambda (flonum? rational?) (begin (set! VarParam(flonum?, 0) Box(VarParam(flonum?, 0)))  (set! VarParam(rational?, 1) Box(VarParam(rational?, 1)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (or (BoxGet(VarBound(flonum?, 0, 0)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(rational?, 0, 1)) BoxGet(VarParam(x, 0)))))))) VarFree(flonum?)  VarFree(rational?))

mov qword [fvar_tbl+8*30], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar number? to ((lambda (flonum? rational?) (begin (set! VarParam(flonum?, 0) Box(VarParam(flonum?, 0)))  (set! VarParam(rational?, 1) Box(VarParam(rational?, 1)))  (lambda (x) (begin (set! VarParam(x, 0) Box(VarParam(x, 0)))  (or (BoxGet(VarBound(flonum?, 0, 0)) BoxGet(VarParam(x, 0)))  (BoxGet(VarBound(rational?, 0, 1)) BoxGet(VarParam(x, 0)))))))) VarFree(flonum?)  VarFree(rational?))

	call write_sob_if_not_void

;; Starting: Set fvar length to ((lambda (fold-left +) (begin (set! VarParam(fold-left, 0) Box(VarParam(fold-left, 0)))  (set! VarParam(+, 1) Box(VarParam(+, 1)))  (lambda (l) (begin (set! VarParam(l, 0) Box(VarParam(l, 0)))  (BoxGet(VarBound(fold-left, 0, 0)) (lambda (acc e) (begin (set! VarParam(acc, 0) Box(VarParam(acc, 0)))  (set! VarParam(e, 1) Box(VarParam(e, 1)))  (BoxGet(VarBound(+, 1, 1)) BoxGet(VarParam(acc, 0))  1/1)))  0/1  BoxGet(VarParam(l, 0))))))) VarFree(fold-left)  VarFree(+))
;; Starting: Perform Applic#159 of: ((lambda (fold-left +) (begin (set! VarParam(fold-left, 0) Box(VarParam(fold-left, 0)))  (set! VarParam(+, 1) Box(VarParam(+, 1)))  (lambda (l) (begin (set! VarParam(l, 0) Box(VarParam(l, 0)))  (BoxGet(VarBound(fold-left, 0, 0)) (lambda (acc e) (begin (set! VarParam(acc, 0) Box(VarParam(acc, 0)))  (set! VarParam(e, 1) Box(VarParam(e, 1)))  (BoxGet(VarBound(+, 1, 1)) BoxGet(VarParam(acc, 0))  1/1)))  0/1  BoxGet(VarParam(l, 0))))))) VarFree(fold-left)  VarFree(+))
;; Starting: Argument 1 of Applic statement #159
mov rax, qword [fvar_tbl+8*15]	; mov fvar + to rax
Debug4:
;; Finished: Argument 1 of Applic statement #159

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #159
mov rax, qword [fvar_tbl+8*6]	; mov fvar fold-left to rax
;; Finished: Argument 0 of Applic statement #159

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #159)
;; Starting: Creating CLOSURE of LambdaSimple#160 -> (lambda (fold-left +) (begin (set! VarParam(fold-left, 0) Box(VarParam(fold-left, 0)))  (set! VarParam(+, 1) Box(VarParam(+, 1)))  (lambda (l) (begin (set! VarParam(l, 0) Box(VarParam(l, 0)))  (BoxGet(VarBound(fold-left, 0, 0)) (lambda (acc e) (begin (set! VarParam(acc, 0) Box(VarParam(acc, 0)))  (set! VarParam(e, 1) Box(VarParam(e, 1)))  (BoxGet(VarBound(+, 1, 1)) BoxGet(VarParam(acc, 0))  1/1)))  0/1  BoxGet(VarParam(l, 0)))))))
push rbx
; Env Extend Code Section For Closure#160
mov rbx, 0 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend160
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End160

LClosureEnvExtend160:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, -1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 0
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop160:
  jz LClosureEnvExtend_LoopEnd160
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop160

LClosureEnvExtend_LoopEnd160:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd160
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop160:
  jz LClosureEnvExtend_ParamsLoopEnd160

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop160

LClosureEnvExtend_ParamsLoopEnd160:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End160:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode160)
pop rbx
jmp LClosureCont160
LClosureCode160:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #161: (begin (set! VarParam(fold-left, 0) Box(VarParam(fold-left, 0)))  (set! VarParam(+, 1) Box(VarParam(+, 1)))  (lambda (l) (begin (set! VarParam(l, 0) Box(VarParam(l, 0)))  (BoxGet(VarBound(fold-left, 0, 0)) (lambda (acc e) (begin (set! VarParam(acc, 0) Box(VarParam(acc, 0)))  (set! VarParam(e, 1) Box(VarParam(e, 1)))  (BoxGet(VarBound(+, 1, 1)) BoxGet(VarParam(acc, 0))  1/1)))  0/1  BoxGet(VarParam(l, 0))))))
;; Starting: Item 0 in Seq statement #161
;; Starting: Set VarParam(name=fold-left, minor=0) with Box(VarParam(fold-left, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=fold-left, minor=0) with Box(VarParam(fold-left, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(fold-left, 0)
;; Starting: Get VarParam(name=fold-left, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=fold-left, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(fold-left, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=fold-left, minor=0) with Box(VarParam(fold-left, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=fold-left, minor=0) with Box(VarParam(fold-left, 0))

;; Finished: Item 0 in Seq statement #161


;; Starting: Item 1 in Seq statement #161
;; Starting: Set VarParam(name=+, minor=1) with Box(VarParam(+, 1))
;; Starting: Evaluating rhs for [ Set VarParam(name=+, minor=1) with Box(VarParam(+, 1)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(+, 1)
;; Starting: Get VarParam(name=+, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=+, minor=1)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(+, 1)

;; Finished: Evaluating rhs for [ Set VarParam(name=+, minor=1) with Box(VarParam(+, 1)) ], value is expected in rax

mov PVAR(1), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=+, minor=1) with Box(VarParam(+, 1))

;; Finished: Item 1 in Seq statement #161


;; Starting: Item 2 in Seq statement #161
;; Starting: Creating CLOSURE of LambdaSimple#162 -> (lambda (l) (begin (set! VarParam(l, 0) Box(VarParam(l, 0)))  (BoxGet(VarBound(fold-left, 0, 0)) (lambda (acc e) (begin (set! VarParam(acc, 0) Box(VarParam(acc, 0)))  (set! VarParam(e, 1) Box(VarParam(e, 1)))  (BoxGet(VarBound(+, 1, 1)) BoxGet(VarParam(acc, 0))  1/1)))  0/1  BoxGet(VarParam(l, 0)))))
push rbx
; Env Extend Code Section For Closure#162
mov rbx, 1 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend162
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End162

LClosureEnvExtend162:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 0
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 8
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop162:
  jz LClosureEnvExtend_LoopEnd162
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop162

LClosureEnvExtend_LoopEnd162:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd162
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop162:
  jz LClosureEnvExtend_ParamsLoopEnd162

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop162

LClosureEnvExtend_ParamsLoopEnd162:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End162:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode162)
pop rbx
jmp LClosureCont162
LClosureCode162:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #163: (begin (set! VarParam(l, 0) Box(VarParam(l, 0)))  (BoxGet(VarBound(fold-left, 0, 0)) (lambda (acc e) (begin (set! VarParam(acc, 0) Box(VarParam(acc, 0)))  (set! VarParam(e, 1) Box(VarParam(e, 1)))  (BoxGet(VarBound(+, 1, 1)) BoxGet(VarParam(acc, 0))  1/1)))  0/1  BoxGet(VarParam(l, 0))))
;; Starting: Item 0 in Seq statement #163
;; Starting: Set VarParam(name=l, minor=0) with Box(VarParam(l, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=l, minor=0) with Box(VarParam(l, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(l, 0)
;; Starting: Get VarParam(name=l, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=l, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(l, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=l, minor=0) with Box(VarParam(l, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=l, minor=0) with Box(VarParam(l, 0))

;; Finished: Item 0 in Seq statement #163


;; Starting: Item 1 in Seq statement #163
;; Starting: Perform Applic#164 of: (BoxGet(VarBound(fold-left, 0, 0)) (lambda (acc e) (begin (set! VarParam(acc, 0) Box(VarParam(acc, 0)))  (set! VarParam(e, 1) Box(VarParam(e, 1)))  (BoxGet(VarBound(+, 1, 1)) BoxGet(VarParam(acc, 0))  1/1)))  0/1  BoxGet(VarParam(l, 0)))
;; Starting: Argument 2 of Applic statement #164
;; Starting: BoxGet of VarParam(l, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(l, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=l, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=l, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(l, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(l, 0)

;; Finished: Argument 2 of Applic statement #164

push rax ; Push argument to stack;; Starting: Argument 1 of Applic statement #164
mov rax, const_tbl+34	; mov const 0/1 to rax
;; Finished: Argument 1 of Applic statement #164

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #164
;; Starting: Creating CLOSURE of LambdaSimple#165 -> (lambda (acc e) (begin (set! VarParam(acc, 0) Box(VarParam(acc, 0)))  (set! VarParam(e, 1) Box(VarParam(e, 1)))  (BoxGet(VarBound(+, 1, 1)) BoxGet(VarParam(acc, 0))  1/1)))
push rbx
; Env Extend Code Section For Closure#165
mov rbx, 2 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend165
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End165

LClosureEnvExtend165:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 16
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop165:
  jz LClosureEnvExtend_LoopEnd165
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop165

LClosureEnvExtend_LoopEnd165:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd165
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop165:
  jz LClosureEnvExtend_ParamsLoopEnd165

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop165

LClosureEnvExtend_ParamsLoopEnd165:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End165:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode165)
pop rbx
jmp LClosureCont165
LClosureCode165:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #166: (begin (set! VarParam(acc, 0) Box(VarParam(acc, 0)))  (set! VarParam(e, 1) Box(VarParam(e, 1)))  (BoxGet(VarBound(+, 1, 1)) BoxGet(VarParam(acc, 0))  1/1))
;; Starting: Item 0 in Seq statement #166
;; Starting: Set VarParam(name=acc, minor=0) with Box(VarParam(acc, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=acc, minor=0) with Box(VarParam(acc, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(acc, 0)
;; Starting: Get VarParam(name=acc, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=acc, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(acc, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=acc, minor=0) with Box(VarParam(acc, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=acc, minor=0) with Box(VarParam(acc, 0))

;; Finished: Item 0 in Seq statement #166


;; Starting: Item 1 in Seq statement #166
;; Starting: Set VarParam(name=e, minor=1) with Box(VarParam(e, 1))
;; Starting: Evaluating rhs for [ Set VarParam(name=e, minor=1) with Box(VarParam(e, 1)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(e, 1)
;; Starting: Get VarParam(name=e, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=e, minor=1)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(e, 1)

;; Finished: Evaluating rhs for [ Set VarParam(name=e, minor=1) with Box(VarParam(e, 1)) ], value is expected in rax

mov PVAR(1), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=e, minor=1) with Box(VarParam(e, 1))

;; Finished: Item 1 in Seq statement #166


;; Starting: Item 2 in Seq statement #166
;; Starting: Perform Applic#167 of: (BoxGet(VarBound(+, 1, 1)) BoxGet(VarParam(acc, 0))  1/1)
;; Starting: Argument 1 of Applic statement #167
mov rax, const_tbl+51	; mov const 1/1 to rax
;; Finished: Argument 1 of Applic statement #167

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #167
;; Starting: BoxGet of VarParam(acc, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(acc, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=acc, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=acc, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(acc, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(acc, 0)

;; Finished: Argument 0 of Applic statement #167

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #167)
;; Starting: BoxGet of VarBound(+, 1, 1)
;; Starting: Evaluating val for [ BoxGet of VarBound(+, 1, 1) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=+, major=1, minor=1)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
;; Finished: Get VarBound(name=+, major=1, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarBound(+, 1, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(+, 1, 1)

;; Finished: Evaluating proc to apply (in Applic #167)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic167
; int3
ContinueApplic167:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #167
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#167 of: (BoxGet(VarBound(+, 1, 1)) BoxGet(VarParam(acc, 0))  1/1)

;; Finished: Item 2 in Seq statement #166

;; Finished: Seq statement #166: (begin (set! VarParam(acc, 0) Box(VarParam(acc, 0)))  (set! VarParam(e, 1) Box(VarParam(e, 1)))  (BoxGet(VarBound(+, 1, 1)) BoxGet(VarParam(acc, 0))  1/1))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont165:

;; Finished: Creating CLOSURE of LambdaSimple#165 -> (lambda (acc e) (begin (set! VarParam(acc, 0) Box(VarParam(acc, 0)))  (set! VarParam(e, 1) Box(VarParam(e, 1)))  (BoxGet(VarBound(+, 1, 1)) BoxGet(VarParam(acc, 0))  1/1)))

;; Finished: Argument 0 of Applic statement #164

push rax ; Push argument to stack
push qword 3 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #164)
;; Starting: BoxGet of VarBound(fold-left, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(fold-left, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=fold-left, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=fold-left, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(fold-left, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(fold-left, 0, 0)

;; Finished: Evaluating proc to apply (in Applic #164)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic164
; int3
ContinueApplic164:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #164
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#164 of: (BoxGet(VarBound(fold-left, 0, 0)) (lambda (acc e) (begin (set! VarParam(acc, 0) Box(VarParam(acc, 0)))  (set! VarParam(e, 1) Box(VarParam(e, 1)))  (BoxGet(VarBound(+, 1, 1)) BoxGet(VarParam(acc, 0))  1/1)))  0/1  BoxGet(VarParam(l, 0)))

;; Finished: Item 1 in Seq statement #163

;; Finished: Seq statement #163: (begin (set! VarParam(l, 0) Box(VarParam(l, 0)))  (BoxGet(VarBound(fold-left, 0, 0)) (lambda (acc e) (begin (set! VarParam(acc, 0) Box(VarParam(acc, 0)))  (set! VarParam(e, 1) Box(VarParam(e, 1)))  (BoxGet(VarBound(+, 1, 1)) BoxGet(VarParam(acc, 0))  1/1)))  0/1  BoxGet(VarParam(l, 0))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont162:

;; Finished: Creating CLOSURE of LambdaSimple#162 -> (lambda (l) (begin (set! VarParam(l, 0) Box(VarParam(l, 0)))  (BoxGet(VarBound(fold-left, 0, 0)) (lambda (acc e) (begin (set! VarParam(acc, 0) Box(VarParam(acc, 0)))  (set! VarParam(e, 1) Box(VarParam(e, 1)))  (BoxGet(VarBound(+, 1, 1)) BoxGet(VarParam(acc, 0))  1/1)))  0/1  BoxGet(VarParam(l, 0)))))

;; Finished: Item 2 in Seq statement #161

;; Finished: Seq statement #161: (begin (set! VarParam(fold-left, 0) Box(VarParam(fold-left, 0)))  (set! VarParam(+, 1) Box(VarParam(+, 1)))  (lambda (l) (begin (set! VarParam(l, 0) Box(VarParam(l, 0)))  (BoxGet(VarBound(fold-left, 0, 0)) (lambda (acc e) (begin (set! VarParam(acc, 0) Box(VarParam(acc, 0)))  (set! VarParam(e, 1) Box(VarParam(e, 1)))  (BoxGet(VarBound(+, 1, 1)) BoxGet(VarParam(acc, 0))  1/1)))  0/1  BoxGet(VarParam(l, 0))))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont160:

;; Finished: Creating CLOSURE of LambdaSimple#160 -> (lambda (fold-left +) (begin (set! VarParam(fold-left, 0) Box(VarParam(fold-left, 0)))  (set! VarParam(+, 1) Box(VarParam(+, 1)))  (lambda (l) (begin (set! VarParam(l, 0) Box(VarParam(l, 0)))  (BoxGet(VarBound(fold-left, 0, 0)) (lambda (acc e) (begin (set! VarParam(acc, 0) Box(VarParam(acc, 0)))  (set! VarParam(e, 1) Box(VarParam(e, 1)))  (BoxGet(VarBound(+, 1, 1)) BoxGet(VarParam(acc, 0))  1/1)))  0/1  BoxGet(VarParam(l, 0)))))))

;; Finished: Evaluating proc to apply (in Applic #159)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic159
; int3
ContinueApplic159:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #159
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#159 of: ((lambda (fold-left +) (begin (set! VarParam(fold-left, 0) Box(VarParam(fold-left, 0)))  (set! VarParam(+, 1) Box(VarParam(+, 1)))  (lambda (l) (begin (set! VarParam(l, 0) Box(VarParam(l, 0)))  (BoxGet(VarBound(fold-left, 0, 0)) (lambda (acc e) (begin (set! VarParam(acc, 0) Box(VarParam(acc, 0)))  (set! VarParam(e, 1) Box(VarParam(e, 1)))  (BoxGet(VarBound(+, 1, 1)) BoxGet(VarParam(acc, 0))  1/1)))  0/1  BoxGet(VarParam(l, 0))))))) VarFree(fold-left)  VarFree(+))

mov qword [fvar_tbl+8*31], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar length to ((lambda (fold-left +) (begin (set! VarParam(fold-left, 0) Box(VarParam(fold-left, 0)))  (set! VarParam(+, 1) Box(VarParam(+, 1)))  (lambda (l) (begin (set! VarParam(l, 0) Box(VarParam(l, 0)))  (BoxGet(VarBound(fold-left, 0, 0)) (lambda (acc e) (begin (set! VarParam(acc, 0) Box(VarParam(acc, 0)))  (set! VarParam(e, 1) Box(VarParam(e, 1)))  (BoxGet(VarBound(+, 1, 1)) BoxGet(VarParam(acc, 0))  1/1)))  0/1  BoxGet(VarParam(l, 0))))))) VarFree(fold-left)  VarFree(+))

	call write_sob_if_not_void

;; Starting: Set fvar string->list to ((lambda (string-ref string-length < - cons) (begin (set! VarParam(string-ref, 0) Box(VarParam(string-ref, 0)))  (set! VarParam(string-length, 1) Box(VarParam(string-length, 1)))  (set! VarParam(<, 2) Box(VarParam(<, 2)))  (set! VarParam(-, 3) Box(VarParam(-, 3)))  (set! VarParam(cons, 4) Box(VarParam(cons, 4)))  (lambda (s) (begin (set! VarParam(s, 0) Box(VarParam(s, 0)))  ((lambda (s->l-loop) (begin (set! VarParam(s->l-loop, 0) Box(VarParam(s->l-loop, 0)))  BoxSet(VarParam(s->l-loop, 0), (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))))  (BoxGet(VarParam(s->l-loop, 0)) (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)  ()))) whatever))))) VarFree(string-ref)  VarFree(string-length)  VarFree(<)  VarFree(-)  VarFree(cons))
;; Starting: Perform Applic#168 of: ((lambda (string-ref string-length < - cons) (begin (set! VarParam(string-ref, 0) Box(VarParam(string-ref, 0)))  (set! VarParam(string-length, 1) Box(VarParam(string-length, 1)))  (set! VarParam(<, 2) Box(VarParam(<, 2)))  (set! VarParam(-, 3) Box(VarParam(-, 3)))  (set! VarParam(cons, 4) Box(VarParam(cons, 4)))  (lambda (s) (begin (set! VarParam(s, 0) Box(VarParam(s, 0)))  ((lambda (s->l-loop) (begin (set! VarParam(s->l-loop, 0) Box(VarParam(s->l-loop, 0)))  BoxSet(VarParam(s->l-loop, 0), (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))))  (BoxGet(VarParam(s->l-loop, 0)) (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)  ()))) whatever))))) VarFree(string-ref)  VarFree(string-length)  VarFree(<)  VarFree(-)  VarFree(cons))
;; Starting: Argument 4 of Applic statement #168
mov rax, qword [fvar_tbl+8*4]	; mov fvar cons to rax
;; Finished: Argument 4 of Applic statement #168

push rax ; Push argument to stack;; Starting: Argument 3 of Applic statement #168
mov rax, qword [fvar_tbl+8*26]	; mov fvar - to rax
;; Finished: Argument 3 of Applic statement #168

push rax ; Push argument to stack;; Starting: Argument 2 of Applic statement #168
mov rax, qword [fvar_tbl+8*22]	; mov fvar < to rax
;; Finished: Argument 2 of Applic statement #168

push rax ; Push argument to stack;; Starting: Argument 1 of Applic statement #168
mov rax, qword [fvar_tbl+8*34]	; mov fvar string-length to rax
;; Finished: Argument 1 of Applic statement #168

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #168
mov rax, qword [fvar_tbl+8*33]	; mov fvar string-ref to rax
;; Finished: Argument 0 of Applic statement #168

push rax ; Push argument to stack
push qword 5 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #168)
;; Starting: Creating CLOSURE of LambdaSimple#169 -> (lambda (string-ref string-length < - cons) (begin (set! VarParam(string-ref, 0) Box(VarParam(string-ref, 0)))  (set! VarParam(string-length, 1) Box(VarParam(string-length, 1)))  (set! VarParam(<, 2) Box(VarParam(<, 2)))  (set! VarParam(-, 3) Box(VarParam(-, 3)))  (set! VarParam(cons, 4) Box(VarParam(cons, 4)))  (lambda (s) (begin (set! VarParam(s, 0) Box(VarParam(s, 0)))  ((lambda (s->l-loop) (begin (set! VarParam(s->l-loop, 0) Box(VarParam(s->l-loop, 0)))  BoxSet(VarParam(s->l-loop, 0), (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))))  (BoxGet(VarParam(s->l-loop, 0)) (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)  ()))) whatever)))))
push rbx
; Env Extend Code Section For Closure#169
mov rbx, 0 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend169
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End169

LClosureEnvExtend169:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, -1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 0
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop169:
  jz LClosureEnvExtend_LoopEnd169
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop169

LClosureEnvExtend_LoopEnd169:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd169
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop169:
  jz LClosureEnvExtend_ParamsLoopEnd169

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop169

LClosureEnvExtend_ParamsLoopEnd169:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End169:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode169)
pop rbx
jmp LClosureCont169
LClosureCode169:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #170: (begin (set! VarParam(string-ref, 0) Box(VarParam(string-ref, 0)))  (set! VarParam(string-length, 1) Box(VarParam(string-length, 1)))  (set! VarParam(<, 2) Box(VarParam(<, 2)))  (set! VarParam(-, 3) Box(VarParam(-, 3)))  (set! VarParam(cons, 4) Box(VarParam(cons, 4)))  (lambda (s) (begin (set! VarParam(s, 0) Box(VarParam(s, 0)))  ((lambda (s->l-loop) (begin (set! VarParam(s->l-loop, 0) Box(VarParam(s->l-loop, 0)))  BoxSet(VarParam(s->l-loop, 0), (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))))  (BoxGet(VarParam(s->l-loop, 0)) (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)  ()))) whatever))))
;; Starting: Item 0 in Seq statement #170
;; Starting: Set VarParam(name=string-ref, minor=0) with Box(VarParam(string-ref, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=string-ref, minor=0) with Box(VarParam(string-ref, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(string-ref, 0)
;; Starting: Get VarParam(name=string-ref, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=string-ref, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(string-ref, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=string-ref, minor=0) with Box(VarParam(string-ref, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=string-ref, minor=0) with Box(VarParam(string-ref, 0))

;; Finished: Item 0 in Seq statement #170


;; Starting: Item 1 in Seq statement #170
;; Starting: Set VarParam(name=string-length, minor=1) with Box(VarParam(string-length, 1))
;; Starting: Evaluating rhs for [ Set VarParam(name=string-length, minor=1) with Box(VarParam(string-length, 1)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(string-length, 1)
;; Starting: Get VarParam(name=string-length, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=string-length, minor=1)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(string-length, 1)

;; Finished: Evaluating rhs for [ Set VarParam(name=string-length, minor=1) with Box(VarParam(string-length, 1)) ], value is expected in rax

mov PVAR(1), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=string-length, minor=1) with Box(VarParam(string-length, 1))

;; Finished: Item 1 in Seq statement #170


;; Starting: Item 2 in Seq statement #170
;; Starting: Set VarParam(name=<, minor=2) with Box(VarParam(<, 2))
;; Starting: Evaluating rhs for [ Set VarParam(name=<, minor=2) with Box(VarParam(<, 2)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(<, 2)
;; Starting: Get VarParam(name=<, minor=2)
mov rax, PVAR(2)
;; Finished: Get VarParam(name=<, minor=2)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(<, 2)

;; Finished: Evaluating rhs for [ Set VarParam(name=<, minor=2) with Box(VarParam(<, 2)) ], value is expected in rax

mov PVAR(2), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=<, minor=2) with Box(VarParam(<, 2))

;; Finished: Item 2 in Seq statement #170


;; Starting: Item 3 in Seq statement #170
;; Starting: Set VarParam(name=-, minor=3) with Box(VarParam(-, 3))
;; Starting: Evaluating rhs for [ Set VarParam(name=-, minor=3) with Box(VarParam(-, 3)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(-, 3)
;; Starting: Get VarParam(name=-, minor=3)
mov rax, PVAR(3)
;; Finished: Get VarParam(name=-, minor=3)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(-, 3)

;; Finished: Evaluating rhs for [ Set VarParam(name=-, minor=3) with Box(VarParam(-, 3)) ], value is expected in rax

mov PVAR(3), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=-, minor=3) with Box(VarParam(-, 3))

;; Finished: Item 3 in Seq statement #170


;; Starting: Item 4 in Seq statement #170
;; Starting: Set VarParam(name=cons, minor=4) with Box(VarParam(cons, 4))
;; Starting: Evaluating rhs for [ Set VarParam(name=cons, minor=4) with Box(VarParam(cons, 4)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(cons, 4)
;; Starting: Get VarParam(name=cons, minor=4)
mov rax, PVAR(4)
;; Finished: Get VarParam(name=cons, minor=4)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(cons, 4)

;; Finished: Evaluating rhs for [ Set VarParam(name=cons, minor=4) with Box(VarParam(cons, 4)) ], value is expected in rax

mov PVAR(4), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=cons, minor=4) with Box(VarParam(cons, 4))

;; Finished: Item 4 in Seq statement #170


;; Starting: Item 5 in Seq statement #170
;; Starting: Creating CLOSURE of LambdaSimple#171 -> (lambda (s) (begin (set! VarParam(s, 0) Box(VarParam(s, 0)))  ((lambda (s->l-loop) (begin (set! VarParam(s->l-loop, 0) Box(VarParam(s->l-loop, 0)))  BoxSet(VarParam(s->l-loop, 0), (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))))  (BoxGet(VarParam(s->l-loop, 0)) (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)  ()))) whatever)))
push rbx
; Env Extend Code Section For Closure#171
mov rbx, 1 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend171
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End171

LClosureEnvExtend171:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 0
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 8
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop171:
  jz LClosureEnvExtend_LoopEnd171
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop171

LClosureEnvExtend_LoopEnd171:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd171
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop171:
  jz LClosureEnvExtend_ParamsLoopEnd171

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop171

LClosureEnvExtend_ParamsLoopEnd171:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End171:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode171)
pop rbx
jmp LClosureCont171
LClosureCode171:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #172: (begin (set! VarParam(s, 0) Box(VarParam(s, 0)))  ((lambda (s->l-loop) (begin (set! VarParam(s->l-loop, 0) Box(VarParam(s->l-loop, 0)))  BoxSet(VarParam(s->l-loop, 0), (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))))  (BoxGet(VarParam(s->l-loop, 0)) (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)  ()))) whatever))
;; Starting: Item 0 in Seq statement #172
;; Starting: Set VarParam(name=s, minor=0) with Box(VarParam(s, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=s, minor=0) with Box(VarParam(s, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(s, 0)
;; Starting: Get VarParam(name=s, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=s, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(s, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=s, minor=0) with Box(VarParam(s, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=s, minor=0) with Box(VarParam(s, 0))

;; Finished: Item 0 in Seq statement #172


;; Starting: Item 1 in Seq statement #172
;; Starting: Perform Applic#173 of: ((lambda (s->l-loop) (begin (set! VarParam(s->l-loop, 0) Box(VarParam(s->l-loop, 0)))  BoxSet(VarParam(s->l-loop, 0), (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))))  (BoxGet(VarParam(s->l-loop, 0)) (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)  ()))) whatever)
;; Starting: Argument 0 of Applic statement #173
mov rax, const_tbl+23	; mov const whatever to rax
;; Finished: Argument 0 of Applic statement #173

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #173)
;; Starting: Creating CLOSURE of LambdaSimple#174 -> (lambda (s->l-loop) (begin (set! VarParam(s->l-loop, 0) Box(VarParam(s->l-loop, 0)))  BoxSet(VarParam(s->l-loop, 0), (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))))  (BoxGet(VarParam(s->l-loop, 0)) (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)  ())))
push rbx
; Env Extend Code Section For Closure#174
mov rbx, 2 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend174
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End174

LClosureEnvExtend174:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 16
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop174:
  jz LClosureEnvExtend_LoopEnd174
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop174

LClosureEnvExtend_LoopEnd174:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd174
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop174:
  jz LClosureEnvExtend_ParamsLoopEnd174

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop174

LClosureEnvExtend_ParamsLoopEnd174:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End174:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode174)
pop rbx
jmp LClosureCont174
LClosureCode174:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #175: (begin (set! VarParam(s->l-loop, 0) Box(VarParam(s->l-loop, 0)))  BoxSet(VarParam(s->l-loop, 0), (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))))  (BoxGet(VarParam(s->l-loop, 0)) (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)  ()))
;; Starting: Item 0 in Seq statement #175
;; Starting: Set VarParam(name=s->l-loop, minor=0) with Box(VarParam(s->l-loop, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=s->l-loop, minor=0) with Box(VarParam(s->l-loop, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(s->l-loop, 0)
;; Starting: Get VarParam(name=s->l-loop, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=s->l-loop, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(s->l-loop, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=s->l-loop, minor=0) with Box(VarParam(s->l-loop, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=s->l-loop, minor=0) with Box(VarParam(s->l-loop, 0))

;; Finished: Item 0 in Seq statement #175


;; Starting: Item 1 in Seq statement #175
;; Starting: BoxSet of VarParam(s->l-loop, 0) with (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1)))))
;; Starting: Evaluating rhs for [ BoxSet of VarParam(s->l-loop, 0) with (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))) ], the VALUE is expected in rax
;; Starting: Creating CLOSURE of LambdaSimple#176 -> (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1)))))
push rbx
; Env Extend Code Section For Closure#176
mov rbx, 3 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend176
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End176

LClosureEnvExtend176:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 2
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 24
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop176:
  jz LClosureEnvExtend_LoopEnd176
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop176

LClosureEnvExtend_LoopEnd176:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd176
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop176:
  jz LClosureEnvExtend_ParamsLoopEnd176

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop176

LClosureEnvExtend_ParamsLoopEnd176:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End176:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode176)
pop rbx
jmp LClosureCont176
LClosureCode176:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: If statement (#177): (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))
Lif177:
;; Starting: Perform Applic#178 of: (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1)
;; Starting: Argument 1 of Applic statement #178
mov rax, const_tbl+34	; mov const 0/1 to rax
;; Finished: Argument 1 of Applic statement #178

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #178
;; Starting: Get VarParam(name=n, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=n, minor=0)

;; Finished: Argument 0 of Applic statement #178

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #178)
;; Starting: BoxGet of VarBound(<, 2, 2)
;; Starting: Evaluating val for [ BoxGet of VarBound(<, 2, 2) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=<, major=2, minor=2)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 2]
;; Finished: Get VarBound(name=<, major=2, minor=2)

;; Finished: Evaluating val for [ BoxGet of VarBound(<, 2, 2) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(<, 2, 2)

;; Finished: Evaluating proc to apply (in Applic #178)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic178
; int3
ContinueApplic178:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #178
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#178 of: (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1)

cmp rax, SOB_FALSE_ADDRESS
je Lelse177
;; Starting: Get VarParam(name=a, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=a, minor=1)

jmp LendIf177
Lelse177:
;; Starting: Perform Applic#179 of: (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1)))
;; Starting: Argument 1 of Applic statement #179
;; Starting: Perform Applic#181 of: (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))
;; Starting: Argument 1 of Applic statement #181
;; Starting: Get VarParam(name=a, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=a, minor=1)

;; Finished: Argument 1 of Applic statement #181

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #181
;; Starting: Perform Applic#182 of: (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))
;; Starting: Argument 1 of Applic statement #182
;; Starting: Get VarParam(name=n, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=n, minor=0)

;; Finished: Argument 1 of Applic statement #182

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #182
;; Starting: BoxGet of VarBound(s, 1, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(s, 1, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=s, major=1, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=s, major=1, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(s, 1, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(s, 1, 0)

;; Finished: Argument 0 of Applic statement #182

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #182)
;; Starting: BoxGet of VarBound(string-ref, 2, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(string-ref, 2, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=string-ref, major=2, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=string-ref, major=2, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(string-ref, 2, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(string-ref, 2, 0)

;; Finished: Evaluating proc to apply (in Applic #182)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic182
; int3
ContinueApplic182:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #182
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#182 of: (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))

;; Finished: Argument 0 of Applic statement #181

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #181)
;; Starting: BoxGet of VarBound(cons, 2, 4)
;; Starting: Evaluating val for [ BoxGet of VarBound(cons, 2, 4) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=cons, major=2, minor=4)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 4]
;; Finished: Get VarBound(name=cons, major=2, minor=4)

;; Finished: Evaluating val for [ BoxGet of VarBound(cons, 2, 4) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(cons, 2, 4)

;; Finished: Evaluating proc to apply (in Applic #181)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic181
; int3
ContinueApplic181:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #181
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#181 of: (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))

;; Finished: Argument 1 of Applic statement #179

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #179
;; Starting: Perform Applic#180 of: (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)
;; Starting: Argument 1 of Applic statement #180
mov rax, const_tbl+51	; mov const 1/1 to rax
;; Finished: Argument 1 of Applic statement #180

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #180
;; Starting: Get VarParam(name=n, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=n, minor=0)

;; Finished: Argument 0 of Applic statement #180

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #180)
;; Starting: BoxGet of VarBound(-, 2, 3)
;; Starting: Evaluating val for [ BoxGet of VarBound(-, 2, 3) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=-, major=2, minor=3)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 3]
;; Finished: Get VarBound(name=-, major=2, minor=3)

;; Finished: Evaluating val for [ BoxGet of VarBound(-, 2, 3) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(-, 2, 3)

;; Finished: Evaluating proc to apply (in Applic #180)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic180
; int3
ContinueApplic180:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #180
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#180 of: (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)

;; Finished: Argument 0 of Applic statement #179

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #179)
;; Starting: BoxGet of VarBound(s->l-loop, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(s->l-loop, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=s->l-loop, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=s->l-loop, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(s->l-loop, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(s->l-loop, 0, 0)

;; Finished: Evaluating proc to apply (in Applic #179)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic179
; int3
ContinueApplic179:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #179
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#179 of: (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1)))

LendIf177:
;; Finished: If statement (#177): (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont176:

;; Finished: Creating CLOSURE of LambdaSimple#176 -> (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1)))))

;; Finished: Evaluating rhs for [ BoxSet of VarParam(s->l-loop, 0) with (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))) ], the VALUE is expected in rax

; Save the value of rhs
push rax
;; Starting: Evaluating var for [ BoxSet of VarParam(s->l-loop, 0) with (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=s->l-loop, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=s->l-loop, minor=0)

;; Finished: Evaluating var for [ BoxSet of VarParam(s->l-loop, 0) with (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))) ], the VALUE is expected in rax

; in RAX there is a address of a box, put the value we saved on stack earlier (from rhs) inside it
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;; Finished: BoxSet of VarParam(s->l-loop, 0) with (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1)))))

;; Finished: Item 1 in Seq statement #175


;; Starting: Item 2 in Seq statement #175
;; Starting: Perform Applic#183 of: (BoxGet(VarParam(s->l-loop, 0)) (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)  ())
;; Starting: Argument 1 of Applic statement #183
mov rax, const_tbl+1	; mov const () to rax
;; Finished: Argument 1 of Applic statement #183

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #183
;; Starting: Perform Applic#184 of: (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)
;; Starting: Argument 1 of Applic statement #184
mov rax, const_tbl+51	; mov const 1/1 to rax
;; Finished: Argument 1 of Applic statement #184

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #184
;; Starting: Perform Applic#185 of: (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))
;; Starting: Argument 0 of Applic statement #185
;; Starting: BoxGet of VarBound(s, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(s, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=s, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=s, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(s, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(s, 0, 0)

;; Finished: Argument 0 of Applic statement #185

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #185)
;; Starting: BoxGet of VarBound(string-length, 1, 1)
;; Starting: Evaluating val for [ BoxGet of VarBound(string-length, 1, 1) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=string-length, major=1, minor=1)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
;; Finished: Get VarBound(name=string-length, major=1, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarBound(string-length, 1, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(string-length, 1, 1)

;; Finished: Evaluating proc to apply (in Applic #185)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic185
; int3
ContinueApplic185:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #185
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#185 of: (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))

;; Finished: Argument 0 of Applic statement #184

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #184)
;; Starting: BoxGet of VarBound(-, 1, 3)
;; Starting: Evaluating val for [ BoxGet of VarBound(-, 1, 3) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=-, major=1, minor=3)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]
;; Finished: Get VarBound(name=-, major=1, minor=3)

;; Finished: Evaluating val for [ BoxGet of VarBound(-, 1, 3) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(-, 1, 3)

;; Finished: Evaluating proc to apply (in Applic #184)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic184
; int3
ContinueApplic184:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #184
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#184 of: (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)

;; Finished: Argument 0 of Applic statement #183

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #183)
;; Starting: BoxGet of VarParam(s->l-loop, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(s->l-loop, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=s->l-loop, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=s->l-loop, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(s->l-loop, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(s->l-loop, 0)

;; Finished: Evaluating proc to apply (in Applic #183)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic183
; int3
ContinueApplic183:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #183
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#183 of: (BoxGet(VarParam(s->l-loop, 0)) (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)  ())

;; Finished: Item 2 in Seq statement #175

;; Finished: Seq statement #175: (begin (set! VarParam(s->l-loop, 0) Box(VarParam(s->l-loop, 0)))  BoxSet(VarParam(s->l-loop, 0), (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))))  (BoxGet(VarParam(s->l-loop, 0)) (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)  ()))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont174:

;; Finished: Creating CLOSURE of LambdaSimple#174 -> (lambda (s->l-loop) (begin (set! VarParam(s->l-loop, 0) Box(VarParam(s->l-loop, 0)))  BoxSet(VarParam(s->l-loop, 0), (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))))  (BoxGet(VarParam(s->l-loop, 0)) (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)  ())))

;; Finished: Evaluating proc to apply (in Applic #173)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic173
; int3
ContinueApplic173:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #173
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#173 of: ((lambda (s->l-loop) (begin (set! VarParam(s->l-loop, 0) Box(VarParam(s->l-loop, 0)))  BoxSet(VarParam(s->l-loop, 0), (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))))  (BoxGet(VarParam(s->l-loop, 0)) (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)  ()))) whatever)

;; Finished: Item 1 in Seq statement #172

;; Finished: Seq statement #172: (begin (set! VarParam(s, 0) Box(VarParam(s, 0)))  ((lambda (s->l-loop) (begin (set! VarParam(s->l-loop, 0) Box(VarParam(s->l-loop, 0)))  BoxSet(VarParam(s->l-loop, 0), (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))))  (BoxGet(VarParam(s->l-loop, 0)) (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)  ()))) whatever))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont171:

;; Finished: Creating CLOSURE of LambdaSimple#171 -> (lambda (s) (begin (set! VarParam(s, 0) Box(VarParam(s, 0)))  ((lambda (s->l-loop) (begin (set! VarParam(s->l-loop, 0) Box(VarParam(s->l-loop, 0)))  BoxSet(VarParam(s->l-loop, 0), (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))))  (BoxGet(VarParam(s->l-loop, 0)) (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)  ()))) whatever)))

;; Finished: Item 5 in Seq statement #170

;; Finished: Seq statement #170: (begin (set! VarParam(string-ref, 0) Box(VarParam(string-ref, 0)))  (set! VarParam(string-length, 1) Box(VarParam(string-length, 1)))  (set! VarParam(<, 2) Box(VarParam(<, 2)))  (set! VarParam(-, 3) Box(VarParam(-, 3)))  (set! VarParam(cons, 4) Box(VarParam(cons, 4)))  (lambda (s) (begin (set! VarParam(s, 0) Box(VarParam(s, 0)))  ((lambda (s->l-loop) (begin (set! VarParam(s->l-loop, 0) Box(VarParam(s->l-loop, 0)))  BoxSet(VarParam(s->l-loop, 0), (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))))  (BoxGet(VarParam(s->l-loop, 0)) (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)  ()))) whatever))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont169:

;; Finished: Creating CLOSURE of LambdaSimple#169 -> (lambda (string-ref string-length < - cons) (begin (set! VarParam(string-ref, 0) Box(VarParam(string-ref, 0)))  (set! VarParam(string-length, 1) Box(VarParam(string-length, 1)))  (set! VarParam(<, 2) Box(VarParam(<, 2)))  (set! VarParam(-, 3) Box(VarParam(-, 3)))  (set! VarParam(cons, 4) Box(VarParam(cons, 4)))  (lambda (s) (begin (set! VarParam(s, 0) Box(VarParam(s, 0)))  ((lambda (s->l-loop) (begin (set! VarParam(s->l-loop, 0) Box(VarParam(s->l-loop, 0)))  BoxSet(VarParam(s->l-loop, 0), (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))))  (BoxGet(VarParam(s->l-loop, 0)) (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)  ()))) whatever)))))

;; Finished: Evaluating proc to apply (in Applic #168)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic168
; int3
ContinueApplic168:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #168
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#168 of: ((lambda (string-ref string-length < - cons) (begin (set! VarParam(string-ref, 0) Box(VarParam(string-ref, 0)))  (set! VarParam(string-length, 1) Box(VarParam(string-length, 1)))  (set! VarParam(<, 2) Box(VarParam(<, 2)))  (set! VarParam(-, 3) Box(VarParam(-, 3)))  (set! VarParam(cons, 4) Box(VarParam(cons, 4)))  (lambda (s) (begin (set! VarParam(s, 0) Box(VarParam(s, 0)))  ((lambda (s->l-loop) (begin (set! VarParam(s->l-loop, 0) Box(VarParam(s->l-loop, 0)))  BoxSet(VarParam(s->l-loop, 0), (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))))  (BoxGet(VarParam(s->l-loop, 0)) (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)  ()))) whatever))))) VarFree(string-ref)  VarFree(string-length)  VarFree(<)  VarFree(-)  VarFree(cons))

mov qword [fvar_tbl+8*32], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar string->list to ((lambda (string-ref string-length < - cons) (begin (set! VarParam(string-ref, 0) Box(VarParam(string-ref, 0)))  (set! VarParam(string-length, 1) Box(VarParam(string-length, 1)))  (set! VarParam(<, 2) Box(VarParam(<, 2)))  (set! VarParam(-, 3) Box(VarParam(-, 3)))  (set! VarParam(cons, 4) Box(VarParam(cons, 4)))  (lambda (s) (begin (set! VarParam(s, 0) Box(VarParam(s, 0)))  ((lambda (s->l-loop) (begin (set! VarParam(s->l-loop, 0) Box(VarParam(s->l-loop, 0)))  BoxSet(VarParam(s->l-loop, 0), (lambda (n a) (if (BoxGet(VarBound(<, 2, 2)) VarParam(n, 0)  0/1) VarParam(a, 1) (BoxGet(VarBound(s->l-loop, 0, 0)) (BoxGet(VarBound(-, 2, 3)) VarParam(n, 0)  1/1)  (BoxGet(VarBound(cons, 2, 4)) (BoxGet(VarBound(string-ref, 2, 0)) BoxGet(VarBound(s, 1, 0))  VarParam(n, 0))  VarParam(a, 1))))))  (BoxGet(VarParam(s->l-loop, 0)) (BoxGet(VarBound(-, 1, 3)) (BoxGet(VarBound(string-length, 1, 1)) BoxGet(VarBound(s, 0, 0)))  1/1)  ()))) whatever))))) VarFree(string-ref)  VarFree(string-length)  VarFree(<)  VarFree(-)  VarFree(cons))

	call write_sob_if_not_void

;; Starting: Set fvar equal? to ((lambda (= string->list rational? flonum? pair? char? string? eq? car cdr char->integer) (begin (set! VarParam(=, 0) Box(VarParam(=, 0)))  (set! VarParam(string->list, 1) Box(VarParam(string->list, 1)))  (set! VarParam(rational?, 2) Box(VarParam(rational?, 2)))  (set! VarParam(flonum?, 3) Box(VarParam(flonum?, 3)))  (set! VarParam(pair?, 4) Box(VarParam(pair?, 4)))  (set! VarParam(char?, 5) Box(VarParam(char?, 5)))  (set! VarParam(string?, 6) Box(VarParam(string?, 6)))  (set! VarParam(eq?, 7) Box(VarParam(eq?, 7)))  (set! VarParam(car, 8) Box(VarParam(car, 8)))  (set! VarParam(cdr, 9) Box(VarParam(cdr, 9)))  (set! VarParam(char->integer, 10) Box(VarParam(char->integer, 10)))  ((lambda (equal?-loop) (begin (set! VarParam(equal?-loop, 0) Box(VarParam(equal?-loop, 0)))  BoxSet(VarParam(equal?-loop, 0), (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))))))  BoxGet(VarParam(equal?-loop, 0)))) whatever))) VarFree(=)  VarFree(string->list)  VarFree(rational?)  VarFree(flonum?)  VarFree(pair?)  VarFree(char?)  VarFree(string?)  VarFree(eq?)  VarFree(car)  VarFree(cdr)  VarFree(char->integer))
;; Starting: Perform Applic#186 of: ((lambda (= string->list rational? flonum? pair? char? string? eq? car cdr char->integer) (begin (set! VarParam(=, 0) Box(VarParam(=, 0)))  (set! VarParam(string->list, 1) Box(VarParam(string->list, 1)))  (set! VarParam(rational?, 2) Box(VarParam(rational?, 2)))  (set! VarParam(flonum?, 3) Box(VarParam(flonum?, 3)))  (set! VarParam(pair?, 4) Box(VarParam(pair?, 4)))  (set! VarParam(char?, 5) Box(VarParam(char?, 5)))  (set! VarParam(string?, 6) Box(VarParam(string?, 6)))  (set! VarParam(eq?, 7) Box(VarParam(eq?, 7)))  (set! VarParam(car, 8) Box(VarParam(car, 8)))  (set! VarParam(cdr, 9) Box(VarParam(cdr, 9)))  (set! VarParam(char->integer, 10) Box(VarParam(char->integer, 10)))  ((lambda (equal?-loop) (begin (set! VarParam(equal?-loop, 0) Box(VarParam(equal?-loop, 0)))  BoxSet(VarParam(equal?-loop, 0), (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))))))  BoxGet(VarParam(equal?-loop, 0)))) whatever))) VarFree(=)  VarFree(string->list)  VarFree(rational?)  VarFree(flonum?)  VarFree(pair?)  VarFree(char?)  VarFree(string?)  VarFree(eq?)  VarFree(car)  VarFree(cdr)  VarFree(char->integer))
;; Starting: Argument 10 of Applic statement #186
mov rax, qword [fvar_tbl+8*39]	; mov fvar char->integer to rax
;; Finished: Argument 10 of Applic statement #186

push rax ; Push argument to stack;; Starting: Argument 9 of Applic statement #186
mov rax, qword [fvar_tbl+8*3]	; mov fvar cdr to rax
;; Finished: Argument 9 of Applic statement #186

push rax ; Push argument to stack;; Starting: Argument 8 of Applic statement #186
mov rax, qword [fvar_tbl+8*2]	; mov fvar car to rax
;; Finished: Argument 8 of Applic statement #186

push rax ; Push argument to stack;; Starting: Argument 7 of Applic statement #186
mov rax, qword [fvar_tbl+8*38]	; mov fvar eq? to rax
;; Finished: Argument 7 of Applic statement #186

push rax ; Push argument to stack;; Starting: Argument 6 of Applic statement #186
mov rax, qword [fvar_tbl+8*37]	; mov fvar string? to rax
;; Finished: Argument 6 of Applic statement #186

push rax ; Push argument to stack;; Starting: Argument 5 of Applic statement #186
mov rax, qword [fvar_tbl+8*36]	; mov fvar char? to rax
;; Finished: Argument 5 of Applic statement #186

push rax ; Push argument to stack;; Starting: Argument 4 of Applic statement #186
mov rax, qword [fvar_tbl+8*12]	; mov fvar pair? to rax
;; Finished: Argument 4 of Applic statement #186

push rax ; Push argument to stack;; Starting: Argument 3 of Applic statement #186
mov rax, qword [fvar_tbl+8*23]	; mov fvar flonum? to rax
;; Finished: Argument 3 of Applic statement #186

push rax ; Push argument to stack;; Starting: Argument 2 of Applic statement #186
mov rax, qword [fvar_tbl+8*24]	; mov fvar rational? to rax
;; Finished: Argument 2 of Applic statement #186

push rax ; Push argument to stack;; Starting: Argument 1 of Applic statement #186
mov rax, qword [fvar_tbl+8*32]	; mov fvar string->list to rax
;; Finished: Argument 1 of Applic statement #186

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #186
mov rax, qword [fvar_tbl+8*21]	; mov fvar = to rax
;; Finished: Argument 0 of Applic statement #186

push rax ; Push argument to stack
push qword 11 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #186)
;; Starting: Creating CLOSURE of LambdaSimple#187 -> (lambda (= string->list rational? flonum? pair? char? string? eq? car cdr char->integer) (begin (set! VarParam(=, 0) Box(VarParam(=, 0)))  (set! VarParam(string->list, 1) Box(VarParam(string->list, 1)))  (set! VarParam(rational?, 2) Box(VarParam(rational?, 2)))  (set! VarParam(flonum?, 3) Box(VarParam(flonum?, 3)))  (set! VarParam(pair?, 4) Box(VarParam(pair?, 4)))  (set! VarParam(char?, 5) Box(VarParam(char?, 5)))  (set! VarParam(string?, 6) Box(VarParam(string?, 6)))  (set! VarParam(eq?, 7) Box(VarParam(eq?, 7)))  (set! VarParam(car, 8) Box(VarParam(car, 8)))  (set! VarParam(cdr, 9) Box(VarParam(cdr, 9)))  (set! VarParam(char->integer, 10) Box(VarParam(char->integer, 10)))  ((lambda (equal?-loop) (begin (set! VarParam(equal?-loop, 0) Box(VarParam(equal?-loop, 0)))  BoxSet(VarParam(equal?-loop, 0), (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))))))  BoxGet(VarParam(equal?-loop, 0)))) whatever)))
push rbx
; Env Extend Code Section For Closure#187
mov rbx, 0 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend187
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End187

LClosureEnvExtend187:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, -1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 0
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop187:
  jz LClosureEnvExtend_LoopEnd187
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop187

LClosureEnvExtend_LoopEnd187:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd187
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop187:
  jz LClosureEnvExtend_ParamsLoopEnd187

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop187

LClosureEnvExtend_ParamsLoopEnd187:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End187:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode187)
pop rbx
jmp LClosureCont187
LClosureCode187:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #188: (begin (set! VarParam(=, 0) Box(VarParam(=, 0)))  (set! VarParam(string->list, 1) Box(VarParam(string->list, 1)))  (set! VarParam(rational?, 2) Box(VarParam(rational?, 2)))  (set! VarParam(flonum?, 3) Box(VarParam(flonum?, 3)))  (set! VarParam(pair?, 4) Box(VarParam(pair?, 4)))  (set! VarParam(char?, 5) Box(VarParam(char?, 5)))  (set! VarParam(string?, 6) Box(VarParam(string?, 6)))  (set! VarParam(eq?, 7) Box(VarParam(eq?, 7)))  (set! VarParam(car, 8) Box(VarParam(car, 8)))  (set! VarParam(cdr, 9) Box(VarParam(cdr, 9)))  (set! VarParam(char->integer, 10) Box(VarParam(char->integer, 10)))  ((lambda (equal?-loop) (begin (set! VarParam(equal?-loop, 0) Box(VarParam(equal?-loop, 0)))  BoxSet(VarParam(equal?-loop, 0), (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))))))  BoxGet(VarParam(equal?-loop, 0)))) whatever))
;; Starting: Item 0 in Seq statement #188
;; Starting: Set VarParam(name==, minor=0) with Box(VarParam(=, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name==, minor=0) with Box(VarParam(=, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(=, 0)
;; Starting: Get VarParam(name==, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name==, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(=, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name==, minor=0) with Box(VarParam(=, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name==, minor=0) with Box(VarParam(=, 0))

;; Finished: Item 0 in Seq statement #188


;; Starting: Item 1 in Seq statement #188
;; Starting: Set VarParam(name=string->list, minor=1) with Box(VarParam(string->list, 1))
;; Starting: Evaluating rhs for [ Set VarParam(name=string->list, minor=1) with Box(VarParam(string->list, 1)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(string->list, 1)
;; Starting: Get VarParam(name=string->list, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=string->list, minor=1)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(string->list, 1)

;; Finished: Evaluating rhs for [ Set VarParam(name=string->list, minor=1) with Box(VarParam(string->list, 1)) ], value is expected in rax

mov PVAR(1), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=string->list, minor=1) with Box(VarParam(string->list, 1))

;; Finished: Item 1 in Seq statement #188


;; Starting: Item 2 in Seq statement #188
;; Starting: Set VarParam(name=rational?, minor=2) with Box(VarParam(rational?, 2))
;; Starting: Evaluating rhs for [ Set VarParam(name=rational?, minor=2) with Box(VarParam(rational?, 2)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(rational?, 2)
;; Starting: Get VarParam(name=rational?, minor=2)
mov rax, PVAR(2)
;; Finished: Get VarParam(name=rational?, minor=2)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(rational?, 2)

;; Finished: Evaluating rhs for [ Set VarParam(name=rational?, minor=2) with Box(VarParam(rational?, 2)) ], value is expected in rax

mov PVAR(2), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=rational?, minor=2) with Box(VarParam(rational?, 2))

;; Finished: Item 2 in Seq statement #188


;; Starting: Item 3 in Seq statement #188
;; Starting: Set VarParam(name=flonum?, minor=3) with Box(VarParam(flonum?, 3))
;; Starting: Evaluating rhs for [ Set VarParam(name=flonum?, minor=3) with Box(VarParam(flonum?, 3)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(flonum?, 3)
;; Starting: Get VarParam(name=flonum?, minor=3)
mov rax, PVAR(3)
;; Finished: Get VarParam(name=flonum?, minor=3)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(flonum?, 3)

;; Finished: Evaluating rhs for [ Set VarParam(name=flonum?, minor=3) with Box(VarParam(flonum?, 3)) ], value is expected in rax

mov PVAR(3), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=flonum?, minor=3) with Box(VarParam(flonum?, 3))

;; Finished: Item 3 in Seq statement #188


;; Starting: Item 4 in Seq statement #188
;; Starting: Set VarParam(name=pair?, minor=4) with Box(VarParam(pair?, 4))
;; Starting: Evaluating rhs for [ Set VarParam(name=pair?, minor=4) with Box(VarParam(pair?, 4)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(pair?, 4)
;; Starting: Get VarParam(name=pair?, minor=4)
mov rax, PVAR(4)
;; Finished: Get VarParam(name=pair?, minor=4)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(pair?, 4)

;; Finished: Evaluating rhs for [ Set VarParam(name=pair?, minor=4) with Box(VarParam(pair?, 4)) ], value is expected in rax

mov PVAR(4), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=pair?, minor=4) with Box(VarParam(pair?, 4))

;; Finished: Item 4 in Seq statement #188


;; Starting: Item 5 in Seq statement #188
;; Starting: Set VarParam(name=char?, minor=5) with Box(VarParam(char?, 5))
;; Starting: Evaluating rhs for [ Set VarParam(name=char?, minor=5) with Box(VarParam(char?, 5)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(char?, 5)
;; Starting: Get VarParam(name=char?, minor=5)
mov rax, PVAR(5)
;; Finished: Get VarParam(name=char?, minor=5)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(char?, 5)

;; Finished: Evaluating rhs for [ Set VarParam(name=char?, minor=5) with Box(VarParam(char?, 5)) ], value is expected in rax

mov PVAR(5), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=char?, minor=5) with Box(VarParam(char?, 5))

;; Finished: Item 5 in Seq statement #188


;; Starting: Item 6 in Seq statement #188
;; Starting: Set VarParam(name=string?, minor=6) with Box(VarParam(string?, 6))
;; Starting: Evaluating rhs for [ Set VarParam(name=string?, minor=6) with Box(VarParam(string?, 6)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(string?, 6)
;; Starting: Get VarParam(name=string?, minor=6)
mov rax, PVAR(6)
;; Finished: Get VarParam(name=string?, minor=6)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(string?, 6)

;; Finished: Evaluating rhs for [ Set VarParam(name=string?, minor=6) with Box(VarParam(string?, 6)) ], value is expected in rax

mov PVAR(6), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=string?, minor=6) with Box(VarParam(string?, 6))

;; Finished: Item 6 in Seq statement #188


;; Starting: Item 7 in Seq statement #188
;; Starting: Set VarParam(name=eq?, minor=7) with Box(VarParam(eq?, 7))
;; Starting: Evaluating rhs for [ Set VarParam(name=eq?, minor=7) with Box(VarParam(eq?, 7)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(eq?, 7)
;; Starting: Get VarParam(name=eq?, minor=7)
mov rax, PVAR(7)
;; Finished: Get VarParam(name=eq?, minor=7)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(eq?, 7)

;; Finished: Evaluating rhs for [ Set VarParam(name=eq?, minor=7) with Box(VarParam(eq?, 7)) ], value is expected in rax

mov PVAR(7), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=eq?, minor=7) with Box(VarParam(eq?, 7))

;; Finished: Item 7 in Seq statement #188


;; Starting: Item 8 in Seq statement #188
;; Starting: Set VarParam(name=car, minor=8) with Box(VarParam(car, 8))
;; Starting: Evaluating rhs for [ Set VarParam(name=car, minor=8) with Box(VarParam(car, 8)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(car, 8)
;; Starting: Get VarParam(name=car, minor=8)
mov rax, PVAR(8)
;; Finished: Get VarParam(name=car, minor=8)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(car, 8)

;; Finished: Evaluating rhs for [ Set VarParam(name=car, minor=8) with Box(VarParam(car, 8)) ], value is expected in rax

mov PVAR(8), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=car, minor=8) with Box(VarParam(car, 8))

;; Finished: Item 8 in Seq statement #188


;; Starting: Item 9 in Seq statement #188
;; Starting: Set VarParam(name=cdr, minor=9) with Box(VarParam(cdr, 9))
;; Starting: Evaluating rhs for [ Set VarParam(name=cdr, minor=9) with Box(VarParam(cdr, 9)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(cdr, 9)
;; Starting: Get VarParam(name=cdr, minor=9)
mov rax, PVAR(9)
;; Finished: Get VarParam(name=cdr, minor=9)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(cdr, 9)

;; Finished: Evaluating rhs for [ Set VarParam(name=cdr, minor=9) with Box(VarParam(cdr, 9)) ], value is expected in rax

mov PVAR(9), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=cdr, minor=9) with Box(VarParam(cdr, 9))

;; Finished: Item 9 in Seq statement #188


;; Starting: Item 10 in Seq statement #188
;; Starting: Set VarParam(name=char->integer, minor=10) with Box(VarParam(char->integer, 10))
;; Starting: Evaluating rhs for [ Set VarParam(name=char->integer, minor=10) with Box(VarParam(char->integer, 10)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(char->integer, 10)
;; Starting: Get VarParam(name=char->integer, minor=10)
mov rax, PVAR(10)
;; Finished: Get VarParam(name=char->integer, minor=10)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(char->integer, 10)

;; Finished: Evaluating rhs for [ Set VarParam(name=char->integer, minor=10) with Box(VarParam(char->integer, 10)) ], value is expected in rax

mov PVAR(10), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=char->integer, minor=10) with Box(VarParam(char->integer, 10))

;; Finished: Item 10 in Seq statement #188


;; Starting: Item 11 in Seq statement #188
;; Starting: Perform Applic#189 of: ((lambda (equal?-loop) (begin (set! VarParam(equal?-loop, 0) Box(VarParam(equal?-loop, 0)))  BoxSet(VarParam(equal?-loop, 0), (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))))))  BoxGet(VarParam(equal?-loop, 0)))) whatever)
;; Starting: Argument 0 of Applic statement #189
mov rax, const_tbl+23	; mov const whatever to rax
;; Finished: Argument 0 of Applic statement #189

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #189)
;; Starting: Creating CLOSURE of LambdaSimple#190 -> (lambda (equal?-loop) (begin (set! VarParam(equal?-loop, 0) Box(VarParam(equal?-loop, 0)))  BoxSet(VarParam(equal?-loop, 0), (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))))))  BoxGet(VarParam(equal?-loop, 0))))
push rbx
; Env Extend Code Section For Closure#190
mov rbx, 1 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend190
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End190

LClosureEnvExtend190:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 0
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 8
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop190:
  jz LClosureEnvExtend_LoopEnd190
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop190

LClosureEnvExtend_LoopEnd190:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd190
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop190:
  jz LClosureEnvExtend_ParamsLoopEnd190

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop190

LClosureEnvExtend_ParamsLoopEnd190:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End190:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode190)
pop rbx
jmp LClosureCont190
LClosureCode190:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: Seq statement #191: (begin (set! VarParam(equal?-loop, 0) Box(VarParam(equal?-loop, 0)))  BoxSet(VarParam(equal?-loop, 0), (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))))))  BoxGet(VarParam(equal?-loop, 0)))
;; Starting: Item 0 in Seq statement #191
;; Starting: Set VarParam(name=equal?-loop, minor=0) with Box(VarParam(equal?-loop, 0))
;; Starting: Evaluating rhs for [ Set VarParam(name=equal?-loop, minor=0) with Box(VarParam(equal?-loop, 0)) ], value is expected in rax
;; Starting: Creating Box for Var: VarParam(equal?-loop, 0)
;; Starting: Get VarParam(name=equal?-loop, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=equal?-loop, minor=0)

; Save the variable value in rbx
push rbx
mov rbx, rax
; Allocate one qword for the pointer
MALLOC rax, 8
; Put var in the address
mov qword [rax], rbx
; Reverse rbx
pop rbx
; address of box in RAX as expected
;; Finished: Creating Box for Var: VarParam(equal?-loop, 0)

;; Finished: Evaluating rhs for [ Set VarParam(name=equal?-loop, minor=0) with Box(VarParam(equal?-loop, 0)) ], value is expected in rax

mov PVAR(0), rax
mov rax, SOB_VOID_ADDRESS
;; Finished: Set VarParam(name=equal?-loop, minor=0) with Box(VarParam(equal?-loop, 0))

;; Finished: Item 0 in Seq statement #191


;; Starting: Item 1 in Seq statement #191
;; Starting: BoxSet of VarParam(equal?-loop, 0) with (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1))))))))
;; Starting: Evaluating rhs for [ BoxSet of VarParam(equal?-loop, 0) with (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))))) ], the VALUE is expected in rax
;; Starting: Creating CLOSURE of LambdaSimple#192 -> (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1))))))))
push rbx
; Env Extend Code Section For Closure#192
mov rbx, 2 ; move the depth (== length of env on stack) to rbx
cmp rbx, 0
jne LClosureEnvExtend192
; if it's equal, we are at the first level
; so there is no env to extend
mov rbx, SOB_NIL_ADDRESS
jmp LClosureEnvExtend_End192

LClosureEnvExtend192:
  ; rbx = the depth == the length of the ext_env
  
  ; store registers for personal use
  push rax
  push rcx
  push rdx

  ; store in rcx the length of the env on the stack
  mov rcx, 1
  ; rax = nothing
  ; rbx = the depth == the length of the ext_env
  ; rcx = length of env on stack
  ; rdx = nothing

  ; get the address of the current major list (on stack)
  mov rbx, qword [ENV_STACK_POSITION]
  ; rax = nothing
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

  ; allocate the ext_env major list
  MALLOC rax, 16
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = nothing

 ; LOOP
  cmp rcx, 0
LClosureEnvExtend_Loop192:
  jz LClosureEnvExtend_LoopEnd192
  mov rdx, rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env
  ; rdx = length of env

  dec rcx
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = length of env - 1
  ; rdx = length of env

  ; annotate rcx = n, so rdx = n + 1
  ; need to do: rax + WORD_SIZE * (n + 1) <- rbx + WORD_SIZE * n
  ; DOING : mov qword [rax + rdx*WORD_SIZE], qword [rbx + rcx*WORD_SIZE]
  ; store registers for personal use
  push r8
  push r9

  lea r8, [rax + rdx*WORD_SIZE]
  lea r9, [rbx + rcx*WORD_SIZE]
  mov r9, qword [r9]
  mov qword [r8], r9

  ; revert registers used for personal use
  pop r9
  pop r8

  jmp LClosureEnvExtend_Loop192

LClosureEnvExtend_LoopEnd192:
  ; rax = address of ext_env major list
  ; rbx = address of env major list
  ; rcx = 0
  ; rdx = 1

  ; copy value of rax
  mov rbx, rax
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = 0
  ; rdx = 1

  ; get the args_count from stack
  mov rcx, qword [ARGS_COUNT_POSITION]
  ; rax = address of ext_env major list
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 1

  ; check if there are params to copy
  cmp rcx, 0
  je LClosureEnvExtend_ParamsLoopEnd192
  
  ; calculate the number of bytes to allocate for extenv[0]
  mov rax, rcx
  mov rdx, WORD_SIZE
  imul rdx
  ; rax = number of bytes to allocate for extenv[0]
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; allocate extenv[0] rib
  MALLOC rax, rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list
  ; rcx = args number
  ; rdx = 8

  ; link address of extenv[0] into ext_env major list in position 0
  mov qword [rbx], rax
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number
  ; rdx = 8

; COPY PARAMS LOOP
cmp rcx, 0
LClosureEnvExtend_ParamsLoop192:
  jz LClosureEnvExtend_ParamsLoopEnd192

  dec rcx
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = args number - 1 [first iteration, from second: rcx = rcx - 1]
  ; rdx = 8

  ; annotate rcx = n
  ; need to do rax + WORD_SIZE * n <- PVAR(n)
  push r8
  mov r8, PVAR(rcx)
  mov qword [rax + WORD_SIZE*rcx], r8
  pop r8

  jmp LClosureEnvExtend_ParamsLoop192

LClosureEnvExtend_ParamsLoopEnd192:
  ; rax = address of extenv[0] rib
  ; rbx = address of ext_env major list (now with all ribs linked)
  ; rcx = 0
  ; rdx = 8

  ; we used these regs at the begining of the extension, so pop them back
  pop rdx
  pop rcx
  pop rax
LClosureEnvExtend_End192:
  ; address is in RBX as expected

;;; EXTEND_ENV puts the address in rbx
MAKE_CLOSURE(rax, rbx, LClosureCode192)
pop rbx
jmp LClosureCont192
LClosureCode192:
  push rbp
  mov rbp, rsp
  ;;; Body Of Closure: 
  ;; Starting: If statement (#193): (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))))
Lif193:
;; Starting: If statement (#194): (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f)
Lif194:
;; Starting: Perform Applic#195 of: (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0))
;; Starting: Argument 0 of Applic statement #195
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Argument 0 of Applic statement #195

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #195)
;; Starting: BoxGet of VarBound(rational?, 1, 2)
;; Starting: Evaluating val for [ BoxGet of VarBound(rational?, 1, 2) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=rational?, major=1, minor=2)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]
;; Finished: Get VarBound(name=rational?, major=1, minor=2)

;; Finished: Evaluating val for [ BoxGet of VarBound(rational?, 1, 2) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(rational?, 1, 2)

;; Finished: Evaluating proc to apply (in Applic #195)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic195
; int3
ContinueApplic195:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #195
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#195 of: (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0))

cmp rax, SOB_FALSE_ADDRESS
je Lelse194
;; Starting: Perform Applic#196 of: (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1))
;; Starting: Argument 0 of Applic statement #196
;; Starting: Get VarParam(name=y, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=y, minor=1)

;; Finished: Argument 0 of Applic statement #196

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #196)
;; Starting: BoxGet of VarBound(rational?, 1, 2)
;; Starting: Evaluating val for [ BoxGet of VarBound(rational?, 1, 2) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=rational?, major=1, minor=2)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]
;; Finished: Get VarBound(name=rational?, major=1, minor=2)

;; Finished: Evaluating val for [ BoxGet of VarBound(rational?, 1, 2) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(rational?, 1, 2)

;; Finished: Evaluating proc to apply (in Applic #196)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic196
; int3
ContinueApplic196:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #196
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#196 of: (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1))

jmp LendIf194
Lelse194:
mov rax, const_tbl+2	; mov const #f to rax
LendIf194:
;; Finished: If statement (#194): (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f)

cmp rax, SOB_FALSE_ADDRESS
je Lelse193
;; Starting: Perform Applic#197 of: (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1))
;; Starting: Argument 1 of Applic statement #197
;; Starting: Get VarParam(name=y, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=y, minor=1)

;; Finished: Argument 1 of Applic statement #197

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #197
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Argument 0 of Applic statement #197

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #197)
;; Starting: BoxGet of VarBound(=, 1, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(=, 1, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name==, major=1, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name==, major=1, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(=, 1, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(=, 1, 0)

;; Finished: Evaluating proc to apply (in Applic #197)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic197
; int3
ContinueApplic197:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #197
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#197 of: (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1))

jmp LendIf193
Lelse193:
;; Starting: If statement (#198): (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1))))))
Lif198:
;; Starting: If statement (#199): (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f)
Lif199:
;; Starting: Perform Applic#200 of: (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0))
;; Starting: Argument 0 of Applic statement #200
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Argument 0 of Applic statement #200

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #200)
;; Starting: BoxGet of VarBound(flonum?, 1, 3)
;; Starting: Evaluating val for [ BoxGet of VarBound(flonum?, 1, 3) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=flonum?, major=1, minor=3)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]
;; Finished: Get VarBound(name=flonum?, major=1, minor=3)

;; Finished: Evaluating val for [ BoxGet of VarBound(flonum?, 1, 3) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(flonum?, 1, 3)

;; Finished: Evaluating proc to apply (in Applic #200)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic200
; int3
ContinueApplic200:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #200
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#200 of: (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0))

cmp rax, SOB_FALSE_ADDRESS
je Lelse199
;; Starting: Perform Applic#201 of: (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1))
;; Starting: Argument 0 of Applic statement #201
;; Starting: Get VarParam(name=y, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=y, minor=1)

;; Finished: Argument 0 of Applic statement #201

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #201)
;; Starting: BoxGet of VarBound(flonum?, 1, 3)
;; Starting: Evaluating val for [ BoxGet of VarBound(flonum?, 1, 3) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=flonum?, major=1, minor=3)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]
;; Finished: Get VarBound(name=flonum?, major=1, minor=3)

;; Finished: Evaluating val for [ BoxGet of VarBound(flonum?, 1, 3) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(flonum?, 1, 3)

;; Finished: Evaluating proc to apply (in Applic #201)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic201
; int3
ContinueApplic201:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #201
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#201 of: (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1))

jmp LendIf199
Lelse199:
mov rax, const_tbl+2	; mov const #f to rax
LendIf199:
;; Finished: If statement (#199): (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f)

cmp rax, SOB_FALSE_ADDRESS
je Lelse198
;; Starting: Perform Applic#202 of: (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1))
;; Starting: Argument 1 of Applic statement #202
;; Starting: Get VarParam(name=y, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=y, minor=1)

;; Finished: Argument 1 of Applic statement #202

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #202
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Argument 0 of Applic statement #202

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #202)
;; Starting: BoxGet of VarBound(=, 1, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(=, 1, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name==, major=1, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name==, major=1, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(=, 1, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(=, 1, 0)

;; Finished: Evaluating proc to apply (in Applic #202)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic202
; int3
ContinueApplic202:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #202
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#202 of: (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1))

jmp LendIf198
Lelse198:
;; Starting: If statement (#203): (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))
Lif203:
;; Starting: If statement (#204): (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f)
Lif204:
;; Starting: Perform Applic#205 of: (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0))
;; Starting: Argument 0 of Applic statement #205
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Argument 0 of Applic statement #205

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #205)
;; Starting: BoxGet of VarBound(char?, 1, 5)
;; Starting: Evaluating val for [ BoxGet of VarBound(char?, 1, 5) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=char?, major=1, minor=5)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 5]
;; Finished: Get VarBound(name=char?, major=1, minor=5)

;; Finished: Evaluating val for [ BoxGet of VarBound(char?, 1, 5) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(char?, 1, 5)

;; Finished: Evaluating proc to apply (in Applic #205)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic205
; int3
ContinueApplic205:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #205
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#205 of: (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0))

cmp rax, SOB_FALSE_ADDRESS
je Lelse204
;; Starting: Perform Applic#206 of: (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1))
;; Starting: Argument 0 of Applic statement #206
;; Starting: Get VarParam(name=y, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=y, minor=1)

;; Finished: Argument 0 of Applic statement #206

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #206)
;; Starting: BoxGet of VarBound(char?, 1, 5)
;; Starting: Evaluating val for [ BoxGet of VarBound(char?, 1, 5) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=char?, major=1, minor=5)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 5]
;; Finished: Get VarBound(name=char?, major=1, minor=5)

;; Finished: Evaluating val for [ BoxGet of VarBound(char?, 1, 5) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(char?, 1, 5)

;; Finished: Evaluating proc to apply (in Applic #206)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic206
; int3
ContinueApplic206:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #206
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#206 of: (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1))

jmp LendIf204
Lelse204:
mov rax, const_tbl+2	; mov const #f to rax
LendIf204:
;; Finished: If statement (#204): (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f)

cmp rax, SOB_FALSE_ADDRESS
je Lelse203
;; Starting: Perform Applic#207 of: (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1)))
;; Starting: Argument 1 of Applic statement #207
;; Starting: Perform Applic#209 of: (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))
;; Starting: Argument 0 of Applic statement #209
;; Starting: Get VarParam(name=y, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=y, minor=1)

;; Finished: Argument 0 of Applic statement #209

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #209)
;; Starting: BoxGet of VarBound(char->integer, 1, 10)
;; Starting: Evaluating val for [ BoxGet of VarBound(char->integer, 1, 10) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=char->integer, major=1, minor=10)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 10]
;; Finished: Get VarBound(name=char->integer, major=1, minor=10)

;; Finished: Evaluating val for [ BoxGet of VarBound(char->integer, 1, 10) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(char->integer, 1, 10)

;; Finished: Evaluating proc to apply (in Applic #209)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic209
; int3
ContinueApplic209:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #209
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#209 of: (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))

;; Finished: Argument 1 of Applic statement #207

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #207
;; Starting: Perform Applic#208 of: (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))
;; Starting: Argument 0 of Applic statement #208
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Argument 0 of Applic statement #208

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #208)
;; Starting: BoxGet of VarBound(char->integer, 1, 10)
;; Starting: Evaluating val for [ BoxGet of VarBound(char->integer, 1, 10) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=char->integer, major=1, minor=10)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 10]
;; Finished: Get VarBound(name=char->integer, major=1, minor=10)

;; Finished: Evaluating val for [ BoxGet of VarBound(char->integer, 1, 10) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(char->integer, 1, 10)

;; Finished: Evaluating proc to apply (in Applic #208)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic208
; int3
ContinueApplic208:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #208
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#208 of: (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))

;; Finished: Argument 0 of Applic statement #207

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #207)
;; Starting: BoxGet of VarBound(=, 1, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(=, 1, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name==, major=1, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name==, major=1, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(=, 1, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(=, 1, 0)

;; Finished: Evaluating proc to apply (in Applic #207)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic207
; int3
ContinueApplic207:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #207
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#207 of: (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1)))

jmp LendIf203
Lelse203:
;; Starting: If statement (#210): (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1))))
Lif210:
;; Starting: If statement (#211): (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f)
Lif211:
;; Starting: Perform Applic#212 of: (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0))
;; Starting: Argument 0 of Applic statement #212
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Argument 0 of Applic statement #212

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #212)
;; Starting: BoxGet of VarBound(pair?, 1, 4)
;; Starting: Evaluating val for [ BoxGet of VarBound(pair?, 1, 4) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=pair?, major=1, minor=4)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 4]
;; Finished: Get VarBound(name=pair?, major=1, minor=4)

;; Finished: Evaluating val for [ BoxGet of VarBound(pair?, 1, 4) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(pair?, 1, 4)

;; Finished: Evaluating proc to apply (in Applic #212)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic212
; int3
ContinueApplic212:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #212
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#212 of: (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0))

cmp rax, SOB_FALSE_ADDRESS
je Lelse211
;; Starting: Perform Applic#213 of: (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1))
;; Starting: Argument 0 of Applic statement #213
;; Starting: Get VarParam(name=y, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=y, minor=1)

;; Finished: Argument 0 of Applic statement #213

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #213)
;; Starting: BoxGet of VarBound(pair?, 1, 4)
;; Starting: Evaluating val for [ BoxGet of VarBound(pair?, 1, 4) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=pair?, major=1, minor=4)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 4]
;; Finished: Get VarBound(name=pair?, major=1, minor=4)

;; Finished: Evaluating val for [ BoxGet of VarBound(pair?, 1, 4) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(pair?, 1, 4)

;; Finished: Evaluating proc to apply (in Applic #213)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic213
; int3
ContinueApplic213:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #213
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#213 of: (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1))

jmp LendIf211
Lelse211:
mov rax, const_tbl+2	; mov const #f to rax
LendIf211:
;; Finished: If statement (#211): (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f)

cmp rax, SOB_FALSE_ADDRESS
je Lelse210
;; Starting: Seq statement #214: (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1))))
;; Starting: Item 0 in Seq statement #214
;; Starting: Perform Applic#215 of: (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))
;; Starting: Argument 1 of Applic statement #215
;; Starting: Perform Applic#217 of: (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1))
;; Starting: Argument 0 of Applic statement #217
;; Starting: Get VarParam(name=y, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=y, minor=1)

;; Finished: Argument 0 of Applic statement #217

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #217)
;; Starting: BoxGet of VarBound(car, 1, 8)
;; Starting: Evaluating val for [ BoxGet of VarBound(car, 1, 8) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=car, major=1, minor=8)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 8]
;; Finished: Get VarBound(name=car, major=1, minor=8)

;; Finished: Evaluating val for [ BoxGet of VarBound(car, 1, 8) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(car, 1, 8)

;; Finished: Evaluating proc to apply (in Applic #217)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic217
; int3
ContinueApplic217:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #217
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#217 of: (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1))

;; Finished: Argument 1 of Applic statement #215

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #215
;; Starting: Perform Applic#216 of: (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))
;; Starting: Argument 0 of Applic statement #216
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Argument 0 of Applic statement #216

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #216)
;; Starting: BoxGet of VarBound(car, 1, 8)
;; Starting: Evaluating val for [ BoxGet of VarBound(car, 1, 8) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=car, major=1, minor=8)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 8]
;; Finished: Get VarBound(name=car, major=1, minor=8)

;; Finished: Evaluating val for [ BoxGet of VarBound(car, 1, 8) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(car, 1, 8)

;; Finished: Evaluating proc to apply (in Applic #216)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic216
; int3
ContinueApplic216:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #216
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#216 of: (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))

;; Finished: Argument 0 of Applic statement #215

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #215)
;; Starting: BoxGet of VarBound(equal?-loop, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(equal?-loop, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=equal?-loop, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=equal?-loop, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(equal?-loop, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(equal?-loop, 0, 0)

;; Finished: Evaluating proc to apply (in Applic #215)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic215
; int3
ContinueApplic215:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #215
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#215 of: (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))

;; Finished: Item 0 in Seq statement #214


;; Starting: Item 1 in Seq statement #214
;; Starting: Perform Applic#218 of: (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))
;; Starting: Argument 1 of Applic statement #218
;; Starting: Perform Applic#220 of: (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1))
;; Starting: Argument 0 of Applic statement #220
;; Starting: Get VarParam(name=y, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=y, minor=1)

;; Finished: Argument 0 of Applic statement #220

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #220)
;; Starting: BoxGet of VarBound(cdr, 1, 9)
;; Starting: Evaluating val for [ BoxGet of VarBound(cdr, 1, 9) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=cdr, major=1, minor=9)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 9]
;; Finished: Get VarBound(name=cdr, major=1, minor=9)

;; Finished: Evaluating val for [ BoxGet of VarBound(cdr, 1, 9) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(cdr, 1, 9)

;; Finished: Evaluating proc to apply (in Applic #220)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic220
; int3
ContinueApplic220:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #220
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#220 of: (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1))

;; Finished: Argument 1 of Applic statement #218

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #218
;; Starting: Perform Applic#219 of: (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))
;; Starting: Argument 0 of Applic statement #219
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Argument 0 of Applic statement #219

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #219)
;; Starting: BoxGet of VarBound(cdr, 1, 9)
;; Starting: Evaluating val for [ BoxGet of VarBound(cdr, 1, 9) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=cdr, major=1, minor=9)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 9]
;; Finished: Get VarBound(name=cdr, major=1, minor=9)

;; Finished: Evaluating val for [ BoxGet of VarBound(cdr, 1, 9) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(cdr, 1, 9)

;; Finished: Evaluating proc to apply (in Applic #219)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic219
; int3
ContinueApplic219:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #219
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#219 of: (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))

;; Finished: Argument 0 of Applic statement #218

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #218)
;; Starting: BoxGet of VarBound(equal?-loop, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(equal?-loop, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=equal?-loop, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=equal?-loop, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(equal?-loop, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(equal?-loop, 0, 0)

;; Finished: Evaluating proc to apply (in Applic #218)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic218
; int3
ContinueApplic218:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #218
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#218 of: (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))

;; Finished: Item 1 in Seq statement #214

;; Finished: Seq statement #214: (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1))))

jmp LendIf210
Lelse210:
;; Starting: If statement (#221): (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))
Lif221:
;; Starting: If statement (#222): (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f)
Lif222:
;; Starting: Perform Applic#223 of: (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0))
;; Starting: Argument 0 of Applic statement #223
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Argument 0 of Applic statement #223

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #223)
;; Starting: BoxGet of VarBound(string?, 1, 6)
;; Starting: Evaluating val for [ BoxGet of VarBound(string?, 1, 6) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=string?, major=1, minor=6)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 6]
;; Finished: Get VarBound(name=string?, major=1, minor=6)

;; Finished: Evaluating val for [ BoxGet of VarBound(string?, 1, 6) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(string?, 1, 6)

;; Finished: Evaluating proc to apply (in Applic #223)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic223
; int3
ContinueApplic223:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #223
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#223 of: (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0))

cmp rax, SOB_FALSE_ADDRESS
je Lelse222
;; Starting: Perform Applic#224 of: (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1))
;; Starting: Argument 0 of Applic statement #224
;; Starting: Get VarParam(name=y, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=y, minor=1)

;; Finished: Argument 0 of Applic statement #224

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #224)
;; Starting: BoxGet of VarBound(string?, 1, 6)
;; Starting: Evaluating val for [ BoxGet of VarBound(string?, 1, 6) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=string?, major=1, minor=6)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 6]
;; Finished: Get VarBound(name=string?, major=1, minor=6)

;; Finished: Evaluating val for [ BoxGet of VarBound(string?, 1, 6) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(string?, 1, 6)

;; Finished: Evaluating proc to apply (in Applic #224)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic224
; int3
ContinueApplic224:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #224
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#224 of: (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1))

jmp LendIf222
Lelse222:
mov rax, const_tbl+2	; mov const #f to rax
LendIf222:
;; Finished: If statement (#222): (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f)

cmp rax, SOB_FALSE_ADDRESS
je Lelse221
;; Starting: Perform Applic#225 of: (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1)))
;; Starting: Argument 1 of Applic statement #225
;; Starting: Perform Applic#227 of: (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))
;; Starting: Argument 0 of Applic statement #227
;; Starting: Get VarParam(name=y, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=y, minor=1)

;; Finished: Argument 0 of Applic statement #227

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #227)
;; Starting: BoxGet of VarBound(string->list, 1, 1)
;; Starting: Evaluating val for [ BoxGet of VarBound(string->list, 1, 1) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=string->list, major=1, minor=1)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
;; Finished: Get VarBound(name=string->list, major=1, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarBound(string->list, 1, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(string->list, 1, 1)

;; Finished: Evaluating proc to apply (in Applic #227)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic227
; int3
ContinueApplic227:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #227
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#227 of: (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))

;; Finished: Argument 1 of Applic statement #225

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #225
;; Starting: Perform Applic#226 of: (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))
;; Starting: Argument 0 of Applic statement #226
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Argument 0 of Applic statement #226

push rax ; Push argument to stack
push qword 1 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #226)
;; Starting: BoxGet of VarBound(string->list, 1, 1)
;; Starting: Evaluating val for [ BoxGet of VarBound(string->list, 1, 1) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=string->list, major=1, minor=1)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
;; Finished: Get VarBound(name=string->list, major=1, minor=1)

;; Finished: Evaluating val for [ BoxGet of VarBound(string->list, 1, 1) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(string->list, 1, 1)

;; Finished: Evaluating proc to apply (in Applic #226)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic226
; int3
ContinueApplic226:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #226
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#226 of: (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))

;; Finished: Argument 0 of Applic statement #225

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #225)
;; Starting: BoxGet of VarBound(equal?-loop, 0, 0)
;; Starting: Evaluating val for [ BoxGet of VarBound(equal?-loop, 0, 0) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=equal?-loop, major=0, minor=0)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
;; Finished: Get VarBound(name=equal?-loop, major=0, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarBound(equal?-loop, 0, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(equal?-loop, 0, 0)

;; Finished: Evaluating proc to apply (in Applic #225)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic225
; int3
ContinueApplic225:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #225
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#225 of: (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1)))

jmp LendIf221
Lelse221:
;; Starting: Perform Applic#228 of: (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1))
;; Starting: Argument 1 of Applic statement #228
;; Starting: Get VarParam(name=y, minor=1)
mov rax, PVAR(1)
;; Finished: Get VarParam(name=y, minor=1)

;; Finished: Argument 1 of Applic statement #228

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #228
;; Starting: Get VarParam(name=x, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=x, minor=0)

;; Finished: Argument 0 of Applic statement #228

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #228)
;; Starting: BoxGet of VarBound(eq?, 1, 7)
;; Starting: Evaluating val for [ BoxGet of VarBound(eq?, 1, 7) ], the VALUE is expected in rax
;; Starting: Get VarBound(name=eq?, major=1, minor=7)
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 7]
;; Finished: Get VarBound(name=eq?, major=1, minor=7)

;; Finished: Evaluating val for [ BoxGet of VarBound(eq?, 1, 7) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarBound(eq?, 1, 7)

;; Finished: Evaluating proc to apply (in Applic #228)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic228
; int3
ContinueApplic228:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #228
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#228 of: (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1))

LendIf221:
;; Finished: If statement (#221): (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))

LendIf210:
;; Finished: If statement (#210): (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1))))

LendIf203:
;; Finished: If statement (#203): (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))

LendIf198:
;; Finished: If statement (#198): (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1))))))

LendIf193:
;; Finished: If statement (#193): (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont192:

;; Finished: Creating CLOSURE of LambdaSimple#192 -> (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1))))))))

;; Finished: Evaluating rhs for [ BoxSet of VarParam(equal?-loop, 0) with (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))))) ], the VALUE is expected in rax

; Save the value of rhs
push rax
;; Starting: Evaluating var for [ BoxSet of VarParam(equal?-loop, 0) with (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))))) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=equal?-loop, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=equal?-loop, minor=0)

;; Finished: Evaluating var for [ BoxSet of VarParam(equal?-loop, 0) with (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))))) ], the VALUE is expected in rax

; in RAX there is a address of a box, put the value we saved on stack earlier (from rhs) inside it
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;; Finished: BoxSet of VarParam(equal?-loop, 0) with (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1))))))))

;; Finished: Item 1 in Seq statement #191


;; Starting: Item 2 in Seq statement #191
;; Starting: BoxGet of VarParam(equal?-loop, 0)
;; Starting: Evaluating val for [ BoxGet of VarParam(equal?-loop, 0) ], the VALUE is expected in rax
;; Starting: Get VarParam(name=equal?-loop, minor=0)
mov rax, PVAR(0)
;; Finished: Get VarParam(name=equal?-loop, minor=0)

;; Finished: Evaluating val for [ BoxGet of VarParam(equal?-loop, 0) ], the VALUE is expected in rax

; now the box address is in RAX, get the value from inside the box
mov rax, qword [rax]
;; Finished: BoxGet of VarParam(equal?-loop, 0)

;; Finished: Item 2 in Seq statement #191

;; Finished: Seq statement #191: (begin (set! VarParam(equal?-loop, 0) Box(VarParam(equal?-loop, 0)))  BoxSet(VarParam(equal?-loop, 0), (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))))))  BoxGet(VarParam(equal?-loop, 0)))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont190:

;; Finished: Creating CLOSURE of LambdaSimple#190 -> (lambda (equal?-loop) (begin (set! VarParam(equal?-loop, 0) Box(VarParam(equal?-loop, 0)))  BoxSet(VarParam(equal?-loop, 0), (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))))))  BoxGet(VarParam(equal?-loop, 0))))

;; Finished: Evaluating proc to apply (in Applic #189)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic189
; int3
ContinueApplic189:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #189
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#189 of: ((lambda (equal?-loop) (begin (set! VarParam(equal?-loop, 0) Box(VarParam(equal?-loop, 0)))  BoxSet(VarParam(equal?-loop, 0), (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))))))  BoxGet(VarParam(equal?-loop, 0)))) whatever)

;; Finished: Item 11 in Seq statement #188

;; Finished: Seq statement #188: (begin (set! VarParam(=, 0) Box(VarParam(=, 0)))  (set! VarParam(string->list, 1) Box(VarParam(string->list, 1)))  (set! VarParam(rational?, 2) Box(VarParam(rational?, 2)))  (set! VarParam(flonum?, 3) Box(VarParam(flonum?, 3)))  (set! VarParam(pair?, 4) Box(VarParam(pair?, 4)))  (set! VarParam(char?, 5) Box(VarParam(char?, 5)))  (set! VarParam(string?, 6) Box(VarParam(string?, 6)))  (set! VarParam(eq?, 7) Box(VarParam(eq?, 7)))  (set! VarParam(car, 8) Box(VarParam(car, 8)))  (set! VarParam(cdr, 9) Box(VarParam(cdr, 9)))  (set! VarParam(char->integer, 10) Box(VarParam(char->integer, 10)))  ((lambda (equal?-loop) (begin (set! VarParam(equal?-loop, 0) Box(VarParam(equal?-loop, 0)))  BoxSet(VarParam(equal?-loop, 0), (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))))))  BoxGet(VarParam(equal?-loop, 0)))) whatever))

  ;;; End Of Body Of Closure:
  leave
  ret
  
LClosureCont187:

;; Finished: Creating CLOSURE of LambdaSimple#187 -> (lambda (= string->list rational? flonum? pair? char? string? eq? car cdr char->integer) (begin (set! VarParam(=, 0) Box(VarParam(=, 0)))  (set! VarParam(string->list, 1) Box(VarParam(string->list, 1)))  (set! VarParam(rational?, 2) Box(VarParam(rational?, 2)))  (set! VarParam(flonum?, 3) Box(VarParam(flonum?, 3)))  (set! VarParam(pair?, 4) Box(VarParam(pair?, 4)))  (set! VarParam(char?, 5) Box(VarParam(char?, 5)))  (set! VarParam(string?, 6) Box(VarParam(string?, 6)))  (set! VarParam(eq?, 7) Box(VarParam(eq?, 7)))  (set! VarParam(car, 8) Box(VarParam(car, 8)))  (set! VarParam(cdr, 9) Box(VarParam(cdr, 9)))  (set! VarParam(char->integer, 10) Box(VarParam(char->integer, 10)))  ((lambda (equal?-loop) (begin (set! VarParam(equal?-loop, 0) Box(VarParam(equal?-loop, 0)))  BoxSet(VarParam(equal?-loop, 0), (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))))))  BoxGet(VarParam(equal?-loop, 0)))) whatever)))

;; Finished: Evaluating proc to apply (in Applic #186)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic186
; int3
ContinueApplic186:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #186
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#186 of: ((lambda (= string->list rational? flonum? pair? char? string? eq? car cdr char->integer) (begin (set! VarParam(=, 0) Box(VarParam(=, 0)))  (set! VarParam(string->list, 1) Box(VarParam(string->list, 1)))  (set! VarParam(rational?, 2) Box(VarParam(rational?, 2)))  (set! VarParam(flonum?, 3) Box(VarParam(flonum?, 3)))  (set! VarParam(pair?, 4) Box(VarParam(pair?, 4)))  (set! VarParam(char?, 5) Box(VarParam(char?, 5)))  (set! VarParam(string?, 6) Box(VarParam(string?, 6)))  (set! VarParam(eq?, 7) Box(VarParam(eq?, 7)))  (set! VarParam(car, 8) Box(VarParam(car, 8)))  (set! VarParam(cdr, 9) Box(VarParam(cdr, 9)))  (set! VarParam(char->integer, 10) Box(VarParam(char->integer, 10)))  ((lambda (equal?-loop) (begin (set! VarParam(equal?-loop, 0) Box(VarParam(equal?-loop, 0)))  BoxSet(VarParam(equal?-loop, 0), (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))))))  BoxGet(VarParam(equal?-loop, 0)))) whatever))) VarFree(=)  VarFree(string->list)  VarFree(rational?)  VarFree(flonum?)  VarFree(pair?)  VarFree(char?)  VarFree(string?)  VarFree(eq?)  VarFree(car)  VarFree(cdr)  VarFree(char->integer))

mov qword [fvar_tbl+8*35], rax 
mov rax, SOB_VOID_ADDRESS
;; Finished: Set fvar equal? to ((lambda (= string->list rational? flonum? pair? char? string? eq? car cdr char->integer) (begin (set! VarParam(=, 0) Box(VarParam(=, 0)))  (set! VarParam(string->list, 1) Box(VarParam(string->list, 1)))  (set! VarParam(rational?, 2) Box(VarParam(rational?, 2)))  (set! VarParam(flonum?, 3) Box(VarParam(flonum?, 3)))  (set! VarParam(pair?, 4) Box(VarParam(pair?, 4)))  (set! VarParam(char?, 5) Box(VarParam(char?, 5)))  (set! VarParam(string?, 6) Box(VarParam(string?, 6)))  (set! VarParam(eq?, 7) Box(VarParam(eq?, 7)))  (set! VarParam(car, 8) Box(VarParam(car, 8)))  (set! VarParam(cdr, 9) Box(VarParam(cdr, 9)))  (set! VarParam(char->integer, 10) Box(VarParam(char->integer, 10)))  ((lambda (equal?-loop) (begin (set! VarParam(equal?-loop, 0) Box(VarParam(equal?-loop, 0)))  BoxSet(VarParam(equal?-loop, 0), (lambda (x y) (if (if (BoxGet(VarBound(rational?, 1, 2)) VarParam(x, 0)) (BoxGet(VarBound(rational?, 1, 2)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(flonum?, 1, 3)) VarParam(x, 0)) (BoxGet(VarBound(flonum?, 1, 3)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) VarParam(x, 0)  VarParam(y, 1)) (if (if (BoxGet(VarBound(char?, 1, 5)) VarParam(x, 0)) (BoxGet(VarBound(char?, 1, 5)) VarParam(y, 1)) #f) (BoxGet(VarBound(=, 1, 0)) (BoxGet(VarBound(char->integer, 1, 10)) VarParam(x, 0))  (BoxGet(VarBound(char->integer, 1, 10)) VarParam(y, 1))) (if (if (BoxGet(VarBound(pair?, 1, 4)) VarParam(x, 0)) (BoxGet(VarBound(pair?, 1, 4)) VarParam(y, 1)) #f) (begin (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(car, 1, 8)) VarParam(x, 0))  (BoxGet(VarBound(car, 1, 8)) VarParam(y, 1)))  (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(cdr, 1, 9)) VarParam(x, 0))  (BoxGet(VarBound(cdr, 1, 9)) VarParam(y, 1)))) (if (if (BoxGet(VarBound(string?, 1, 6)) VarParam(x, 0)) (BoxGet(VarBound(string?, 1, 6)) VarParam(y, 1)) #f) (BoxGet(VarBound(equal?-loop, 0, 0)) (BoxGet(VarBound(string->list, 1, 1)) VarParam(x, 0))  (BoxGet(VarBound(string->list, 1, 1)) VarParam(y, 1))) (BoxGet(VarBound(eq?, 1, 7)) VarParam(x, 0)  VarParam(y, 1)))))))))  BoxGet(VarParam(equal?-loop, 0)))) whatever))) VarFree(=)  VarFree(string->list)  VarFree(rational?)  VarFree(flonum?)  VarFree(pair?)  VarFree(char?)  VarFree(string?)  VarFree(eq?)  VarFree(car)  VarFree(cdr)  VarFree(char->integer))

	call write_sob_if_not_void

;; Starting: Perform Applic#229 of: (VarFree(+) 1/1  2/1)
;; Starting: Argument 1 of Applic statement #229
mov rax, const_tbl+85	; mov const 2/1 to rax
;; Finished: Argument 1 of Applic statement #229

push rax ; Push argument to stack;; Starting: Argument 0 of Applic statement #229
mov rax, const_tbl+51	; mov const 1/1 to rax
;; Finished: Argument 0 of Applic statement #229

push rax ; Push argument to stack
push qword 2 ; Push num of args
;; Starting: Evaluating proc to apply (in Applic #229)
mov rax, qword [fvar_tbl+8*15]	; mov fvar + to rax
Debug5:
;; Finished: Evaluating proc to apply (in Applic #229)

; Check if RAX contains a closure
mov rsi, rax
mov bl, byte [rsi]
cmp bl, T_CLOSURE
je ContinueApplic229
; int3
ContinueApplic229:

push qword [rax + TYPE_SIZE] ; Push closure env
CLOSURE_CODE rax, rax ; Move closure code to rax
call rax ; Call the closure code

; Finished closure code. Returning from Applic #229
add rsp, 8*1 ; pop env
pop rbx      ; pop arg count
shl rbx, 3   ; rbx = rbx * 8
add rsp, rbx ; pop args
;; Finished: Perform Applic#229 of: (VarFree(+) 1/1  2/1)

	call write_sob_if_not_void
;;;Finished User Code
;;; Clean up the dummy frame, set the exit status to 0 ("success"), 
   ;;; and return from main
   pop rbp
   add rsp, 3*8
   mov rax, 0

   ret
boolean?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_BOOL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

flonum?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_FLOAT
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

rational?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_RATIONAL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

pair?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_PAIR
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

null?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_NIL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

char?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_CHAR
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

string?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_STRING
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

symbol?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_SYMBOL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

procedure?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_CLOSURE
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

div:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .div_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  divsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .div_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          MAKE_RATIONAL(rax, rdx, rdi)
         mov PVAR(1), rax
         pop rbp
         jmp mul
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

mul:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .mul_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  mulsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .mul_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          imul rsi, rdi
	 imul rcx, rdx
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

add:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .add_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  addsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .add_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          imul rsi, rdx
	 imul rdi, rcx
	 add rsi, rdi
	 imul rcx, rdx
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

eq:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .eq_rat
             FLOAT_VAL rsi, rsi
	 FLOAT_VAL rdi, rdi
	 cmp rsi, rdi
             jmp .op_return
          .eq_rat:
             NUMERATOR rcx, rsi
	 NUMERATOR rdx, rdi
	 cmp rcx, rdx
	 jne .false
	 DENOMINATOR rcx, rsi
	 DENOMINATOR rdx, rdi
	 cmp rcx, rdx
         .false:
          .op_return:
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

lt:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .lt_rat
             FLOAT_VAL rsi, rsi
	 movq xmm0, rsi
	 FLOAT_VAL rdi, rdi
	 movq xmm1, rdi
	 ucomisd xmm0, xmm1
             jmp .op_return
          .lt_rat:
             DENOMINATOR rcx, rsi
	 DENOMINATOR rdx, rdi
	 NUMERATOR rsi, rsi
	 NUMERATOR rdi, rdi
	 imul rsi, rdx
	 imul rdi, rcx
	 cmp rsi, rdi
          .op_return:
      jl .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

string_length:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	STRING_LENGTH rsi, rsi
         MAKE_RATIONAL(rax, rsi, 1)
         pop rbp
         ret

string_ref:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	STRING_ELEMENTS rsi, rsi
         NUMERATOR rdi, rdi
         add rsi, rdi
         mov sil, byte [rsi]
         MAKE_CHAR(rax, sil)
         pop rbp
         ret

string_set:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov rdx, PVAR(2)
	STRING_ELEMENTS rsi, rsi
         NUMERATOR rdi, rdi
         add rsi, rdi
         CHAR_VAL rax, rdx
         mov byte [rsi], al
         mov rax, SOB_VOID_ADDRESS
         pop rbp
         ret

make_string:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	NUMERATOR rsi, rsi
         CHAR_VAL rdi, rdi
         and rdi, 255
         MAKE_STRING rax, rsi, dil
         pop rbp
         ret

symbol_to_string:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	SYMBOL_VAL rsi, rsi
	 STRING_LENGTH rcx, rsi
	 STRING_ELEMENTS rdi, rsi
	 push rcx
	 push rdi
	 mov dil, byte [rdi]
	 MAKE_CHAR(rax, dil)
	 push rax
	 MAKE_RATIONAL(rax, rcx, 1)
	 push rax
	 push 2
	 push SOB_NIL_ADDRESS
	 call make_string
	 add rsp, 4*8
	 STRING_ELEMENTS rsi, rax   
	 pop rdi
	 pop rcx
	 cmp rcx, 0
	 je .end
         .loop:
	 lea r8, [rdi+rcx]
	 lea r9, [rsi+rcx]
	 mov bl, byte [r8]
	 mov byte [r9], bl
	 loop .loop
         .end:
         pop rbp
         ret

eq?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	cmp rsi, rdi
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

char_to_integer:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	CHAR_VAL rsi, rsi
	 and rsi, 255
	 MAKE_RATIONAL(rax, rsi, 1)
         pop rbp
         ret

integer_to_char:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	NUMERATOR rsi, rsi
	 and rsi, 255
	 MAKE_CHAR(rax, sil)
         pop rbp
         ret

exact_to_inexact:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	DENOMINATOR rdi, rsi
	 NUMERATOR rsi, rsi 
	 cvtsi2sd xmm0, rsi
	 cvtsi2sd xmm1, rdi
	 divsd xmm0, xmm1
	 movq rsi, xmm0
	 MAKE_FLOAT(rax, rsi)
         pop rbp
         ret

numerator:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	NUMERATOR rsi, rsi
	 mov rdi, 1
	 MAKE_RATIONAL(rax, rsi, rdi)
         pop rbp
         ret

denominator:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	DENOMINATOR rsi, rsi
	 mov rdi, 1
	 MAKE_RATIONAL(rax, rsi, rdi)
         pop rbp
         ret

gcd:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	xor rdx, rdx
	 NUMERATOR rax, rsi
         NUMERATOR rdi, rdi
       .loop:
	 and rdi, rdi
	 jz .end_loop
	 xor rdx, rdx 
	 div rdi
	 mov rax, rdi
	 mov rdi, rdx
	 jmp .loop	
       .end_loop:
	 mov rdx, rax
         MAKE_RATIONAL(rax, rdx, 1)
         pop rbp
         ret

car:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	CAR rax, rsi
         pop rbp
         ret

cdr:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	CDR rax, rsi
         pop rbp
         ret

set_car:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	lea rsi, [rsi+TYPE_SIZE]
   mov rsi, rdi
         pop rbp
         ret

set_cdr:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	lea rsi, [rsi+TYPE_SIZE+WORD_SIZE]
   mov rsi, rdi
         pop rbp
         ret

cons:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	MAKE_PAIR(rax, rsi, rdi)
         pop rbp
         ret